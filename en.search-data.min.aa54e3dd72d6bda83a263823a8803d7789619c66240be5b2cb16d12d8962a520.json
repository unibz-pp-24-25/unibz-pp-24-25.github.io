[{"id":0,"href":"/docs/objects/sections/objects/","title":"Objects","section":"Objects and classes","content":" Objects # An object is a way to group data in a meaningful way.\nA simple example: JSON objects # Here is a JSON object (in Javascript syntax) that describes the city of Florence:\n{ name: \u0026#34;Florence\u0026#34;, zipcode: 50100 } A JSON object may contain other objects, as well as arrays (of values, objects or arrays). For instance:\n{ name: \u0026#34;Alice\u0026#34;, age: 26, birthPlace: { name: \u0026#34;Florence\u0026#34;, zipcode: 50100 }, jobs: [ { employer: \u0026#34;Kolping\u0026#34;, start: 2021, end: 2022 }, { employer : \u0026#34;Eurac\u0026#34;, start: 2023 } ] } In JSON: - an **element** can be either: - a scalar (e.g. an integer), or - an array of elements, or - an object, - an **object** is a finite set of key-value pairs, where keys are distinct, and each value is an element. Equivalently, a JSON object can be viewed as a function (with finite domain) that maps keys to JSON elements.\nObjects and programming languages # JSON objects do not exactly correspond to the objects that can be created in Java (and many other programming languages). We highlight here two important differences.\nTypes # Exercise Find a JSON object that satisfies the above description but _cannot_ be represented as an object in a (strongly) _typed_ language such as Java, C/C++, C#, etc. Possible solution ```javascript { key: [1, \"a\"]; } ``` In a typed language (like Java), the elements of an array must be of the same type.\nThis is not required in Javascript, Python, etc.\nReferences # A Java (or Python, C#, etc.) object does not contain objects or arrays, but references to objects or arrays. For instance, the equivalent in Java of the above object may be pictured as follows (abusing notation):\n```javascript _1: { name: _2, age: 26, birthPlace: _3, jobs: _4, } _2: ['A','l','i','c','e'] _3: { name: _5, zipcode: 50100 } _4: [ _6, _7 ] _5: ['F','l','o','r','e','n','c','e'] ``` ```javascript _6: { employer: _8, start: 2021, end: 2022 } _7: { employer: _9, start: 2023 } _8: ['K','o','l','p','i','n','g'] _9: ['E','u','r','a','c'] ``` Each object or array has an ID (e.g. _1 in this example), which can be used to refer to it (you can think of this ID as an address in memory).\nAs a consequence, some objects can be created in Java that have no finite representation in JSON. Exercise Find one of these objects. Possible solution ```javascript _1: { name: _2, friends: _3 } _2: ['A','l','i','c','e'] _3: [ _4, _7 ] _4: { name: _5, friends: _6 } _5: ['B','o','b'] _6: [ _1, _8 ] ``` If we try to represent this object in JSON, we get (assuming that we start with Alice): ```javascript { name: \"Alice\", friends: [ { name: \"Bob\", friends: [ { name: \"Alice\", friends: [ ... ]}]}]} ``` \u003e Cyclic references (like in this exercise) naturally occur in object-oriented code. Identifying them may be essential to debug a program that does not terminate or runs out of memory (stack overflow, \u0026hellip;).\n"},{"id":1,"href":"/docs/objects/sections/classes/","title":"Class and instance","section":"Objects and classes","content":" Class and instance # A class can be viewed as a blueprint for a set of similar objects.\nFor instance, consider the two objects:\n```javascript { name: \"Florence\", zipCode: 50100, region: \"Tuscany\" } ``` ```javascript { name: \"Rome\", zipCode: 00100, region: \"Lazio\" } ``` Each of these objects describes a city, and they share the same keys (name, zipCode and region). A possible class for these two objects may enforce this structure, and it could be named City. An object that follows this blueprint is called an instance of this class.\nDeclaration # In a typed language (like Java), a class must specifies not only the \u0026ldquo;keys\u0026rdquo; of its instances, but also their types. For instance, the class City could be declared as follows in Java:\npublic class City { String name; int zipCode; String region; ... } In Java, a class is often declared in a dedicated file. This file must have the _same name_ as the class (e.g. `City.java` in this example). The three variables (name, zipCode and region) are called attributes (or sometimes member variables).\nConstructor # A class also needs a special method called a constructor.\nThe constructor is in charge of creating a (fresh) instance of the class.\nIn Java (as in Python, C#, etc.), the constructor does not return the instance itself, but a reference (sometimes called \u0026ldquo;pointer\u0026rdquo;) to this instance.\n**_Note._** A class may have several constructors (with different signatures). Writing a constructor in Java # The constructor of a Java class must have the _same name_ as the class. For instance:\npublic class City { String name; int zipCode; String region; public City(String n, int z, String r){ name = n; zipCode = z; region = r; } ... } **_Note._** In this example, the variable names `n`, `z` and `r` are not very explicit. However, using `name`, `zipCode` and `region` would be ambiguous (because these names are already used for the attributes of the class). In Java, we can use the prefix `this.` to refer to attribute names, thus eliminating the ambiguity. For instance: ```java public class City { String name; int zipCode; String region; public City(String name, int zipCode, String region){ this.name = name; this.zipCode = zipcode; this.region = region; } ... } ``` Calling a constructor in Java # A Java constructor is called with the keyword new. For instance:\nCity myCity = new City(\u0026#34;Florence\u0026#34;, 50100, \u0026#34;Tuscany\u0026#34;); City yourCity = new City(\u0026#34;Rome\u0026#34;, 00100, \u0026#34;Lazio\u0026#34;); **_Note._** The object that is created in memory contains extra information, in particular a reference to its class. This allows type checking, casts, etc. (more on this later). Accessing an object in Java # The attributes of an object can be accessed like regular variables, using ., followed by the name of the attribute. For instance,\nCity thatCity = new City(\u0026#34;Siena\u0026#34;, 53100, \u0026#34;Lazio\u0026#34;); System.out.println(\u0026#34;Wrong region: \u0026#34; + thatCity.region); thatCity.region = \u0026#34;Tuscany\u0026#34;; System.out.println(\u0026#34;Better now: \u0026#34; + thatCity.region); will output\nWrong region: Lazio Better now: Tuscany Reference type vs primitive type # Recall that a Java constructor returns a reference to the object that it creates. So in the example above, the value of each variable (myCity and yourCity) is a reference, not the object itself.\nThis also holds for:\nvariables of type String, variable with an array type (like int[] myArray). The types of these variables (e.g. City, String or int[]) are called reference types.\n**_Syntax._** In Java, types that start with a _capital letter_ (like `City` or `Array`) are usually reference types. Types that are not references types (like int or char) are called primitive types.\nThe value of a reference cannot be output (printed, displayed, etc.) by a program. But this value can be modified or compared to another.\nExercise What is the output of the following program? ```java City aCity = new City(\"Matera\", 75100, \"Basilicata\"); City theSameCity = new City(\"Matera\", 75100, \"Basilicata\"); System.out.println(aCity == theSameCity); System.out.println(aCity.zipCode == theSameCity.zipCode); System.out.println(aCity.name == theSameCity.name); ``` Solution ```java false true false ``` Exercise What is the output of the following program? ```java City anotherCity = new City(\"Bologna\", 40100, \"Emilia-Romagna\"); City yetAnotherCity = new City(\"Mantua\", 46100, \"Emilia-Romagna\"); yetAnotherCity.name = anotherCity.name; System.out.println(yetAnotherCity.name); anotherCity = yetAnotherCity; System.out.println(anotherCity.zipCode); System.out.println(anotherCity == yetAnotherCity); ``` Solution \u003e Exercise 2. \u003e \u003e ```java \u003e \"Bologna\" \u003e 46100 \u003e true \u003e ``` Passing by value or by reference # Programming languages differ in the way arguments are passed to methods. Two common strategies are:\npassing by value: the method receives as input a copy of each argument, passing by reference: the method receives as input a reference to each argument. Consider for instance the following program (in pseudocode):\nint myInteger = 0 myMethod(myInteger) print(myInteger) void myMethod(int argument){ argument += 1 } If the argument is passed by value, then the program will print 0. If the argument is passed by reference, then the program will print 1. Java passes by value # In Java (and many other programming languages, like C, Python, Javascript, etc.), arguments are passed by value. So the above program translated in Java will print 0.\n**_Warning._** Consider a method with a [reference type](#refType) argument. Because Java passes by value, this method will receive a copy of this argument. But this is a copy _of the reference_, not a copy of the object itself. Exercise What does the following Java program print? ```java int myInteger = 0; City myFirstCity = new City(\"Florence\", 50100, \"Tuscany\"); City mySecondCity = new City(\"Mantua\", 46100, \"Emilia-Romagna\"); myMethod(myInteger, myFirstCity, mySecondCity); System.out.println(myInteger); System.out.println(myFirstCity.zipCode); System.out.println(mySecondCity.zipCode); public void myMethod(int integer, City firstCity, City secondCity){ integer += 1; System.out.println(integer); firstCity.zipCode = 20590; System.out.println(firstCity.zipCode); secondCity = new City(\"Rome\", 00100, \"Lazio\"); System.out.println(secondCity.zipCode); } ``` Solution ```java 1 20590 00100 0 20590 46100 ``` "},{"id":2,"href":"/docs/objects/sections/inheritance/","title":"Inheritance","section":"Objects and classes","content":" Inheritance # Subclass # In most (class-based) object-oriented languages, a class _A_ can **extend** another class _B_. In this case, _A_ is called a **subclass** of _B_. The intuitive meaning is inclusion between their respective sets of instances, i.e. every instance of A is also an instance of B (but the converse may not hold).\nThis can be paraphrased in English by \u0026ldquo;every A is a B \u0026ldquo;. For instance:\nevery banana is a fruit every square is a rectangle every rectangle is a geometric shape, etc. Transitivity # The \"extend\" relation is **transitive**, meaning that if _A_ extends _B_ and _B_ extends _C_, then _A_ extends _C_ (for any classes _A_, _B_ and _C_ ). For instance, from the above examples, one can infer that \u0026ldquo;every square is a geometric shape\u0026rdquo;.\nInheritance # Naturally, if _A_ is a subclass of _B_ then it **inherits** the properties of _B_. For instance, a rectangle has four right angles. Since every square is a rectangle, a square has four right angles as well.\nFactorizing code with a (possibly abstract) superclass # Inheritance can be used to avoid redundant code.\nDirect inheritance: illustration # Let us model the units of our game as objects.\nEach unit has:\na type (e.g. mage, unicorn, etc.), a color (at least in the original game), and a certain amount of health. The behavior and stats of a unit (e.g number of turns before attacking when combined, default health, etc.) are dictated by its type. So it makes sense to group units by type.\nFor instance, one can create a class Unicorn whose instances are all units of type unicorn. In Java:\npublic class Unicorn { String color; int health; int attackCountdown; public Unicorn(String color) { this.color = color; health = 1; attackCountdown = -1; } } **_Note._** We used the keyword `attackCountdown` in this example to indicate the number of turns before the unit attacks (and a special value of `-1` when it is not set to attack). But there are of course other ways to model this. **_Note._** In this example, we used the prefix `this.` for the attribute `color` only, because there is no ambiguity for the three other attributes. We can also create a class Butterfly on the same model\npublic class Butterfly { String color; int health; int attackCountdown; public Butterfly(String color) { this.color = color; health = 2; int attackCountdown = -1; } } Now consider a method encounter that manages an encounter between two units. Without inheritance, one would need to implement four versions of this method:\nunicorn vs unicorn, unicorn vs butterfly, butterfly vs unicorn, and butterfly vs butterfly. For instance, the first of these four methods could be implemented as follows:\nvoid encounter(Unicorn u1, Unicorn u2) { // save the initial value of the first unit\u0026#39;s health int copy = u1.health; u1.health -= u2.health; u2.health -= copy; } More generally, if the game has \\(n\\) types of units, then the code will contain \\(n^2\\) nearly identical encounter methods.\n**_Question._** Can we use inheritance in this example to avoid duplicate code (and how)? Observe that a unicorn and a butterfly (viewed as object) have identical attributes (a.k.a. \u0026ldquo;keys\u0026rdquo;), namely String color, int health, and int attackCountdown. So we can create a superclass of UnicornandButterflythat carries these attributes, and let the two subclasses inherit it. For instance, this superclass may be called Unit.\nHowever, we may also want every unit in the game to have a concrete type (like \u0026ldquo;unicorn\u0026rdquo; or \u0026ldquo;butterfly\u0026rdquo;), rather than being a generic \u0026ldquo;unit\u0026rdquo;. In Java, this can be achieved with the abstract keyword. This keyword ensures that our superclass cannot be directly instantiated (even though it can still have a constructor). For instance:\npublic abstract class Unit { String color; int health; int attackCountdown; public Unit(String color, int health) { this.color = color; this.health = health; int attackCountdown = -1; } } Because this class is abstract, the following code will not compile:\nUnit myUnit = new Unit(\u0026#34;green\u0026#34;, 2); Next, we can declare that Unicorn extends Unit, by using the Java keyword extends. We can also use the constructor of Unit within the constructor of Unicorn, with the Java keyword super.\n**_Note._** In Java (as opposed to C++ for instance), a class can only have _one_ immediate superclass, so the keyword `super` is never ambiguous. This yields:\npublic class Unicorn extends Unit { public Unicorn(String color) { super(color, 1); } } And we can proceed similarly for the class Butterfly.\nObserve that all the attributes are now carried by the superclass Unit. However, because they are inherited, these attributes can be accessed as if they were regular attributes of the subclass. For instance,\nUnicorn myUnit = new Unicorn(\u0026#34;green\u0026#34;); System.out.println(myUnit.health); outputs\n1 This allows us to write a generic encounter method, as follows:\nvoid encounter(Unit u1, Unit u2) { // save the initial value of the first unit\u0026#39;s health int copy = u1.health; u1.health -= u2.health; u2.health -= copy; } And this method can be used with unicorns and/or butterflies. For instance:\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); Butterfly myButterfly = new Butterfly(\u0026#34;yellow\u0026#34;); encounter(myUnicorn, myButterfly); } Transitive inheritance # In the example above, we assumed that all units have a color and can attack. What if we also want to create a type of unit called Wall that has no color and cannot attack? An instance of this class does not need the attributes color and attackCountdown.\nA quick solution here consists is setting attackCountdown to -1, and color to null. However, unnecessary attributes make code harder to understand, and such a design may not scale well if the game is extended with more units types.\nExercise Modify our model to accommodate for the class `Wall`, so that an instance of `Wall` only has the `health` attribute. Possible solution One solution (among others) is the following: 1. modify the class `Unit` so that it only carries the attribute `health`, 2. `Wall` extends `Unit`, 3. create an (abstract) subclass of `Unit` (for instance `MobileUnit`) that carries the other two attributes, 4. `Butterfly` and `Unicorn` extend `MobileUnit` (therefore they also extend `Unit`, by transitivity). ![](/img/diagrams/plantuml/abstract_inherit_complex.svg) Or in Java: ```java public abstract class Unit { int health; public Unit(int health) { this.heath = health; } } ``` ```java public class Wall extends Unit { public Wall() { super(5); } } ``` ```java public abstract class MobileUnit extends Unit { String color; int attackCountdown; public MobileUnit(String color, int health) { super(health); this.color = color; this.attackCountdown = -1; } } ``` ```java public class Unicorn extends MobileUnit { public Unicorn(String color) { super(color, 1); } } ``` and similarly for `Butterfy`. "},{"id":3,"href":"/docs/objects/","title":"Objects and classes","section":"Docs","content":" Objects and classes # This chapter introduces some basic notions of (class-based) object-oriented programming.\n"},{"id":4,"href":"/docs/objects/sections/methods/","title":"Instance methods","section":"Objects and classes","content":" Instance methods # In most object-oriented languages (like Java), methods are implemented within class declarations.\nAn instance method can only be called using an instance of the class where it is declared.\nFor instance, in Java, an instance method declared in MyClass can be called by appending . to a variable of type MyClass. The object referenced by the variable is accessible in the method, as well as its attributes.\nThis intuitively allows us to write methods with one less argument. For instance, consider the following method, which is not and instance method. It verifies whether two instance of MobileUnit have the same color:\npublic boolean sameColor(MobileUnit u1, MobileUnit u2){ return u1.color.equals(u2.color); } This method may be called as follows:\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); Butterfly myButterfly = new Butterfly(\u0026#34;green\u0026#34;); boolean sameColor = sameColor(myUnicorn, myButterfly); Instead, one may write an equivalent method, as an instance method of our class MobileUnit, with one less argument:\npublic abstract class MobileUnit extends Unit { String color; ... public boolean sameColorAs(MobileUnit otherUnit){ return color.equals(otherUnit.color); } } and we can call this method as follows:\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); Butterfly myButterfly = new Butterfly(\u0026#34;green\u0026#34;); boolean sameColor = myUnicorn.sameColorAs(myButterfly); } Overriding # A same instance method can be declared in a class C and a subclass S or C. In this case, we say that S overrides the method.\nWhen such a method is called, the most specific applicable version is executed.\nFor instance, let us extend our example from the previous section with a method regen, declared in both Unit and MobileUnit, as follows:\npublic abstract class Unit { int health; ... public void regen(){ if(health \u0026lt; 10){ health += 1; } } } public abstract class MobileUnit extends Unit { ... public void regen(){ if(health \u0026lt; 10){ health += 1; } health += 1; } } Now consider this program.\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); myUnicorn.regen(); This program increases the health of (the object referenced by) myUnicorn by 2, because Unicorn is a subclass of MobileUnit. However, the following program increases the health of (the object referenced by) myWall by 1, because Wall is a subclass of Unit, but not a subclass of MobileUnit.\nWall myWall = new Wall(); myWall.regen(); **_Hint._** In Java, you can use the annotation `@Override` to indicate that a method overrides another, as follows: ```Java public abstract class MobileUnit extends Unit { ... @Override public void regen(){ if(health \u003c 10){ health += 1; } health += 1; } } ``` This is not necessary. The benefit is that the program will not compile if the overridden and overriding methods have different signatures. More generally, _syntactic_ mistakes (a.k.a. compile time errors) are easier to fix than _bugs_ (a.k.a. runtime errors). So when possible, it is good practice to use features of a language that prevent compilation if incorrect programs. This is why debugging in an untyped language (like Python, Javascript, Lua, etc.) can be more difficult than in a _typed_ one (such as Java, C#, Typescript, etc.). Dynamic dispatch (a.k.a. runtime polymorphism) # **Dynamic dispatch** consists in determining which version of a method must be called when a program is executed (a.k.a. \"at run time\"), when this cannot be determined by analyzing the program alone. This is a feature of most (class-based) object-oriented languages. For instance, in our example, assume a method generateRandomUnits that generates a random array of units (butterflies, unicorns or walls). And let us call the method regen for each unit in this array:\nUnit[] ramdomUnits = generateRandomUnits(); for (Unit unit: randomUnits){ unit.regen(); } The most specific applicable version of the method regen will be executed for each unit, based on its type, even though this type cannot be determined at compile time. For instance, if there is an instance of Unicorn in this array, then the method MobileUnit.regen() will be executed for this instance (rather than the method Unit.regen()).\nCode factorization # An overriding method often extends the functionality of the overridden one. This is a possible source of duplicate code. For instance, in the example above, both implementations of regen() contain:\nif(health \u0026lt; 10){ health += 1; } A common way to factorize this consists in calling the overridden method inside the overriding one. In Java, the keyword super allows us to distinguish the two methods (since they have the same name). For instance, in the above example, the overriding method may be better written as follows:\npublic abstract class MobileUnit extends Unit { ... public void regen() { super.regen(); health += 1; } } Exercise In this example, what would be the effect of replacing `super.regen()` with `regen()`? Solution The method would not terminate. Exercise Consider the method `encounter` of the previous section. Add it as an instance method to our example, so that: - the method now distinguishes the attacker from the defender, - a wall cannot attack, - a unicorn gets a regen if it defends. Possible solution The trick here consists in viewing an encounter from the point of view of the defender: ![](/img/diagrams/plantuml/method_inherit_complex.svg) ```Java public abstract class Unit { int health; ... public void defend(MobileUnit attacker) { // save the initial value of the first unit's health int copy = health; health -= attacker.health; attacker.health -= copy; } } ``` ```Java public class Unicorn extends Unit { ... public void defend(MobileUnit attacker) { regen(); super.defend(attacker); } } ``` "},{"id":5,"href":"/docs/objects/sections/tostring/","title":"Displaying objects","section":"Objects and classes","content":" Displaying objects # The class Object # Java has a native class called `Object` with [11 instance methods](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html). Every Java class implicitly extends `Object`, _including user-defined classes_. Therefore any Java class _inherits_ these methods. The method toString # toString is one of the methods of the class Object. Here is (part of) its specification:\n/** Returns a string representation of the object. * In general, the toString method returns a string that * \u0026#34;textually represents\u0026#34; this object. */ public String toString(); This is the preferred way to display information about an object. For instance, the debugger of your IDE probably relies on this method to display a string that represents an object.\nThis method is also called by many (native or not) methods and operators. For instance, the following program\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); System.out.println(myUnicorn); String message = \u0026#34;Hello \u0026#34; + myUnicorn; is equivalent to\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); System.out.println(myUnicorn.toString()); String message = \u0026#34;Hello \u0026#34; + myUnicorn.toString(); Overriding toString # The default implementation of toString (in the class Object) displays very little information about the object:\npublic String toString() { return getClass().getName() + \u0026#34;@\u0026#34; + Integer.toHexString(hashCode()); } **_Warning._** The output of `hashCode()` in this example is _not_ the reference (a.k.a. \"memory address\") of the object. So a common practice consists in overriding toString. For instance, here is a possible implementation of the method toString within a class Unicorn:\npublic class Unicorn { String color; int health; @Override public String toString() { return \u0026#34;Unicorn{\u0026#34; + \u0026#34;color=\u0026#34; + color + \u0026#34;, \u0026#34; + \u0026#34;health=\u0026#34; + health + \u0026#34;}\u0026#34;; } } **_Hint._** Your IDE can generate such a method. Recursion # A naive implementation of toString (e.g. generated by an IDE) may have unexpected effects.\nExercise Consider an implementation of our game where units (on each side of the board) are grouped by column. This implementation may use a class `Column` to represent a column and the adjacent one(s), as follows: ```java public class Column { Unit[] units; // null if this is the left-most column Column leftAdjacentColumn; // null if this is the right-most column Column rightAdjacentColumn; public Column(Unit[] units){ this.units = units; } @Override public String toString() { return \"Column{\" + \"left=\" + leftAdjacentColumn +\", \" + \"right=\" + rightAdjacentColumn +\", \" + \"units=\" + units + \"}\"; } } ``` Then a board may be created as follows: ```java Unit[] a1 = new Unit[]{ new Unicorn(\"green\") }; Column c1 = new Column(a1); Unit[] a2 = new Unit[]{ new Butterfly(\"yellow\") }; Column c2 = new Column(a2); c1.rightAdjacentColumn = c2; c2.leftAdjacentColumn = c1; System.out.println(c1); ``` There is an issue with this program. Can you identify it? Solution The program does not terminate, because `toString` is (implicitly) recursive, and each of the two columns refers to the other. "},{"id":6,"href":"/docs/objects/sections/comparing/","title":"Cast and equality","section":"Objects and classes","content":" Cast and Equality # Cast # Java (as well as C# and C++) provides mechanisms to change the type associated with an object _o_, using either a _supertype_ of _o_ (this is an **upcast**), or a _subtype_ of _o_ (this is a **downcast**). Upcast # Explicit upcasts are uncommon, but may still be useful in some scenarios, e.g. to disambiguate two method calls.\nImplicit upcasts on the other hand are very frequent, when the type of an object cannot be determined at compile time.\n**_Example._** Consider the following classes: ![](/img/diagrams/plantuml/downcast_simple.svg) Now consider the following program, where the method `getUnits` produces an array of units that depends on the player's input. The type of objects in this array (`Unicorn` or `Butterfly`) cannot be determined at compile time. Thanks to the implicit upcast, they can nonetheless be treated as (underspecified) units. ```java Unit[] units = getUnits(); for (Unit unit: units){ System.out.println(unit.health); } ``` Downcast # Downcasting in Java is frequent for objects whose type cannot be determined at compile time. However, this may not be safe. For instance, in the above example, downcasting a unit from Unit to Unicorn may cause a ClassCastException (at runtime), because this unit is a instance of Butterfly. This is why downcasting is often used in combination with the instanceof operator. For instance the above example can be modifed as follows:\nUnit[] units = getUnits(); for (Unit unit: units){ if(unit instanceof Unicorn){ ((Unicorn) unit).regen(); } } Here the operation (Unicorn) unit is a downcast. The output of this operation has type Unicorn, thus allowing the call to the method regen.\nObject equality # As we saw in a previous chapter, a constructor in Java creates an object in memory and returns a (fresh) reference to that object. Since two objects have different locations in memory, their respective references must differ, even if the objects are identical.\n**_Example._** Consider (a simplified version of) the class `City` that we saw [earlier](http://localhost:39433/docs/objects/sections/classes/). ```java public class City { String name; int zipCode; public City(String name, int zipCode){ this.name = name; this.zipCode = zipcode; } } ``` The following program will output `false`: ```java City city1 = new City(\"Florence\", 50100); City city2 = new City(\"Florence\", 50100); System.out.println(city1 == city2); ``` However, in some scenarios, it may be useful to compare the objects themselves, rather than their references. Java provides a native method called equals for this purpose.\nLike the method toString that we saw earlier, the equals is an instance method of the native Java class Object, which is an (implicit) superclass of every other class. So every (user-defined of native) class inherits equals.\nHere is the source code of Object.equals:\npublic boolean equals(Object obj) { return (this == obj); } In other words, by default, this method behaves like the == operator. In order to use this method to check whether two objects are equal, it has to be overriden.\nFor instance, here is a prototypical implementation of the method equals within our class City:\n@Override public boolean equals(Object o) { if (this == o) { // same reference return true; } if (o == null || getClass() != o.getClass()) return false; // o is null or has a different type } City downcastObject = (City) o; return zipCode == downcastObject.zipCode \u0026amp;\u0026amp; name.equals(downcastObject.name); } **_Hint._** Your IDE can generate such a method. Note in this example:\nthe (safe) downcast from Object to City, and the recursive call to equals (because String is not a primitive type). Recursion # **_Warning._** Similarly to what we saw with the method [toString](http://localhost:39433/docs/objects/sections/tostring/#recursion), beware of naive (recursive) implementations of `equals` if your program can create an object that refers to itself (directly or indirectly). Built-in implementations # Several native Java classes have their own implementation of equals. We will encounter several of them during this course, notably for the class String and for the implementations of the interface Set.\nThe method hashCode # The method equals is usually overridden together with another method of the class Object, called hashCode. In particular, this is needed for the method equals of the class HashSet to behave correctly. We will explore this topic later in this course, when we introduce the notion of a hash table.\n"},{"id":7,"href":"/docs/objects/sections/classesasobjects/","title":"Classes as objects","section":"Objects and classes","content":" Classes as objects # Some object-oriented languages (like Java, C# or C++) provide ways to access or manipulate classes (almost) as if they were objects.\nStatic attributes and methods # Static attributes # Java (as well as C# and C++) supports attributes that do not depend on a specific object, but on a _class_ instead. These are often called **static attributes** (or sometimes **class attributes** or **class variables**), as opposed to the attributes that we have seen so far, called **instance attributes** (or **member variables**). Static attributes are marked with the keyword static.\n**_Example._** Consider a version of our game where characteristics for each unit type (e.g. default health, etc.) can be declared manually, in a text file. The path to this file could be stored as a static attribute, as follows: ```java public class Unicorn { static String configFile = \"units/unicorn.txt\"; int health; public Unicorn(){ health = getHealthFromConfigFile(configFile); } public regen(){ health++; } } ``` Each instance of Unicorn carries its own value for the attribute health. But the value of configFile is unique.\nFor instance, the following program creates in memory a unique string for configFile, which is carried by the class.\nUnicorn u1 = new Unicorn(); Unicorn u2 = new Unicorn(); Static methods # Similarly to a static attribute, a **static method** does not depend on a specific object, as opposed to an [instance method](http://localhost:39433/docs/objects/sections/methods/). **_Example_** (continued). We can add to our class `Unicorn` a static method that checks whether the configuration file exists: ```java public class Unicorn{ ... static boolean configFileExists() { return Files.exists(Paths.get(configFile)); } } ``` (note that the method `getHealthFromConfigFile` also may also be static, if its execution is identical for all instances of `Unicorn`). Remember that an instance method can be called outside of the class where it is declared, using an instance of the class followed by .:\nUnicorn myUnicorn = new Unicorn(); myUnicorn.regen(); A static method can (syntactically) be called in the same way, for instance:\nUnicorn myUnicorn = new Unicorn(); boolean valid = myUnicorn.configFileExists(); However, this is often discouraged, because this syntax can be misleading (in this example, configFileExists can be mistaken for an instance method).\nAlternatively, since the method depends on the class (rather than an instance), the call can be prefixed with the class name. This syntax is often preferred, because it leaves no ambiguity. For instance:\nboolean valid = Unicorn.configFileExists(); Note that there may be several instances of a same class in memory during the execution of a program, or no instance at all. This is why a static method cannot reference an instance method or attribute. For instance, adding the following static method to our class would cause a compilation error, because health is an instance attribute.\npublic class Unicorn { static void reduceHealth(){ health--; } } Inheritance # Two static methods with the same name and signature can be declared in a class and a superclass. In Java\u0026rsquo;s terminology, this is not called method overriding, but instead method hiding. An important difference is that dynamic dispatch (a.k.a. runtime polymorphism) does not apply to this case (the method to be called is determined at compile time, rather than run time).\n**_Example_** (continued). Let us extend our example with a subclass of Unicorn that **hides** the static method `configFileExists`. ```java public class EvilUnicorn extends Unicorn { static boolean configFileExists(){ return false; } } ``` Now consider the following program, where the method getUnicorns produces an array of unicorns that depend on the player\u0026rsquo;s input. The specific type of objects in this array (Unicorn or EvilUnicorn) cannot be determined at compile time.\nUnicorn[] unicorns = getUnicorns(); for (Unicorn unicorn: unicorns){ System.out.println(unicorn.configFileExists()); } } In this example, the method of the superclass (i.e. Unicorn.configFileExists) will be executed for each object in the array, regardless of its type.\nThis is another reason why calling a static method via an instance (rather than via a class name) is often discouraged. In this example, writing Unicorn.configFileExists() would make it clear that this loop serves no purpose (the same method is executed unicorns.length times).\nReflection # Java (as well as C#) offers a mechanism called reflection to intuitively treat classes analogously to objects. Precisely, each class of a program (e.g. the class Unicorn) is associated with an object that represents it. This object is itself an instance of the Java class called Class. It can be accessed either:\nvia an instance of the class: Unicorn myUnicorn = new Unicorn(); Class unicornClass = myUnicorn.getClass(); or via the qualified name of the class (assuming for instance that the file Unicorn.java is in the folder \u0026lt;workingDirectory\u0026gt;/src/main/java/org/units): Class unicornClass = Class.forName(\u0026#34;org.units.Unicorn\u0026#34;); The instance methods of the class Class are listed here. Among others, they allow:\nlisting the attributes of the class, retrieving its immediate superclass, or the interfaces that it implements, creating a new instance of this class, etc. Reflection is a powerful feature. It is rarely used in everyday code, but can be helpful in specific situations. Notably, it is used (internally) by numerous Java frameworks such as Spring, Jackson or JUnit.\n"},{"id":8,"href":"/docs/objects/sections/clone/","title":"Duplicating objects","section":"Objects and classes","content":" Duplicating objects # In some scenarios, it may be useful to duplicate an object.\nIn Java, as we saw earlier, copying the value of a variable with reference type does not copy the object that it references. For instance, the following program outputs \u0026ldquo;yellow\u0026rdquo;:\nUnicorn unicorn = new Unicorn(\u0026#34;green\u0026#34;); Unicorn shallowCopy = unicorn; unicorn.color = \u0026#34;yellow\u0026#34;; System.out.println(shallowCopy.color); The need to duplicate objects may notably appear in a program that rely on concurrency.\nExercise In our game, the \"view\" component is in charge of rendering the game visually. This component exposes a method called `drawSnapshot` that takes as input a [game snapshot]() and draws this snapshot on screen. The backend calls this method whenever a snapshot must be drawn. However, the backend may send these snapshots _faster_ than they can be displayed (due to the duration of on-screen animations). To deal with this scenario, the \"view\" **buffers** the snapshots that it receives (displaying a new snapshot only after all previously submitted ones have been displayed). For the sake of this exercise, you can think of this buffer as an array with type `Snapshot[]`. Now consider the following method `deleteUnit(int x, int y)`, executed by our backend each time it receives the instruction to delete a unit: ```java public class Backend implements EventHandler { Snapshot currentSnapshot; ... public void deleteUnit(int x, int y){ if(\u003c\"there is a unit on the tile x, y\"\u003e){ removeUnitFromTile(x, y); drawSnapshot(currentSnapshot); shiftUnitsInColumn(x); drawSnapshot(currentSnapshot); performUnitMerges(); drawSnapshot(currentSnapshot); ... } } } ``` where the auxiliary methods `removeUnitFromTile`, `shiftUnitsInColumn` and `performUnitMerges` may modify the object `currentSnapshot`. Observe that the method `deleteUnit` calls `drawSnapshot` three times. Now let us assume that the buffer of the \"view\" is nonempty when this method is executed, so that the 3 snapshots are added to the buffer, before any of them can be rendered on screen. How many of these 3 snapshots will be drawn on screen? Solution Only the third snapshot will be drawn (three times), because the buffer contains three references to the same object. Shallow, deep and hybrid copy # Copying a reference to an object can be viewed as the shallowest possible form of copy. As we saw already, this is what happens in Java when a variable with reference type is passed as argument.\nAt the other end of the spectrum is a so-called deep copy, where all attributes of the copied object are duplicated, recursively. In this case, the copy or any object that it references (recursively) can be modified without affecting their original counterparts.\nBetween these two extremes:\na shallow copy creates a new object (with fresh attributes), but does not copy referenced objects recursively, a hybrid copy is anything between a shallow copy and a deep copy. in Java # Copy constructor # A copy can be performed in Java with a so-called **copy constructor**. This is an additional constructor that takes an instance of the class as input, and returns a copy of this instance. For example:\npublic class Hero { int health; // standard constructor public Hero(){ this.health = 10; } // copy constructor public Hero(Hero original){ this.health = original.health; } } In order to perform a deep(er) copy, a copy constructor may call another copy constructor. For example:\npublic class Snapshot { Hero firstHero; Hero secondHero; Board board; int remainingActions; // standard constructor public Snapshot(Hero firstHero, Hero secondHero, Board board, int remainingActions){ // some code here ... } // copy constructor public Snapshot(Snapshot original){ this.firstHero = new Hero(original.firstHero); this.secondHero = new Hero(original.secondHero); this.board = new Board(original.board); this.remainingActions = original.remainingActions; } } **_Warning._** Similarly to what we saw with the methods [toString](http://localhost:39433/docs/objects/sections/tostring/#recursion) or [equals](http://localhost:39433/docs/objects/sections/comparing/#recursion), beware of recursive implementations of copy constructors, if your program can create an object that refers to itself (directly or indirectly). The method clone # Java also provides a native method called clone to duplicate objects. Like the methods toString and equals that we saw earlier, clone is an instance method of the native Java class Object, which is an (implicit) superclass of every other class.\nOverriding clone can be more concise than using a copy constructor (especially for a class with a large number of attributes).\n**_Warning._** Overriding `clone` can be _error-prone_, especially in presence of a class hierarchy (see [Effective Java](), Item 13 for further insight). Notably, the overriding class must implement the `Cloneable` interface, and an implementation of `clone` usually calls `super.clone` recursively (even for a class whose only superclass is `Object`). For these reasons, overriding `clone` is sometimes discouraged, in favor of conceptually simpler solutions (like copy constructors). "},{"id":9,"href":"/docs/objects/sections/quasi-objects/","title":"Quasi-objects","section":"Objects and classes","content":" Quasi-objects # Enumerated types # Most imperative languages allow the creation of so-called enumerated types.\nAn enumerated type is a datatype for a finite set or enumerated values. For instance, if our game only allows \u0026ldquo;blue\u0026rdquo;, \u0026ldquo;green\u0026rdquo; and \u0026ldquo;red\u0026rdquo; as unit colors, then we may create a dedicated type that only allows these three values.\nIn Java # An enumerated type in Java is a set of constants. These constants are effectively static, meaning that they depends on the class or interface where the enumerated type is declared (similarly to a static attribute). The name of an enumerated type can generally be used like a regular reference type. For instance\npublic class Unit { enum UnitColor {BLUE, GREEN, RED} int health; UnitColor color; public Unit(int health, UnitColor color){ this.health = health; this.color = color; } ... } **_Note._** In the above example, the enumerated type `UnitColor` could equivalently be represented with an integer. For instance, `0` for blue, `1` for green and `2` for red. However, with such an encoding, a conditional statement (e.g. `if` or `switch`) that checks the color of a unit would also need to handle the case of values `\u003c 0` or `\u003e 2`. So (besides readability), a benefit of the enumerated type in this case is that it restricts possible inputs to _valid_ ones. **_Hint._** Enumerated types in Java are significantly more expressive than their counterparts in some other languages. Notably, a Java `enum` can have its own [constructor and methods](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html). Records # A record is an object whose attributes cannot be modified.\nin Java # Records were introduced in Java 14 (2020). They are a convenient way to avoid boilerplate code. Records provide a concise syntax for \u0026ldquo;lightweight\u0026rdquo; classes that are only meant to hold data.\nFor instance, here is the full implementation of a record City:\npublic record City(String name, int zipCode) {} This record has an implicit constructor, and implements equals, hashcode and toString in the expected way. For instance:\nCity florence = new City(\u0026#34;Florence\u0026#34;, 50100); City florenceAgain = new City(\u0026#34;Florence\u0026#34;, 50100); // Outputs true. System.out.println(florence.equals(florenceAgain)); The attributes of a record cannot be modified. For instance, the following program does not compile:\nCity florence = new City(\u0026#34;Florence\u0026#34;, 50100); florence.zipCode = 50121; A record is often declared inside a class or interface. For instance, in our game:\npublic class Board { public record TileCoordinates(int X, int Y){}; ... } Records are convenient for methods that need to return more than one value. For instance:\nTileCoordinates getOngoingMove(); Strings # Interning # Many modern languages (such as Java, C#, Python, Ruby, JavaScript, Go, etc.) support a technique called **interning**, in order to manage strings in memory. This consists in storing only one copy of each distinct string created during the execution of a program. These strings are stored in a shared **pool**, and each of them is an [immutable](http://localhost:39433/docs/objects/sections/mutability/) object (meaning that it cannot be modified). Some benefits are faster string comparisons, lower memory footprint, etc.\nin Java # In Java, a string is an object. Like for regular objects, comparing two variables of type String with == compares their references:\nString myString = new String(\u0026#34;foo\u0026#34;); String sameString = new String(\u0026#34;foo\u0026#34;); // Outputs false, because the two variables hold different references. System.out.println(myString == sameString); A string can be explicitly interned (i.e. added to the shared pool) with the (instance) method intern. This method:\ntries to add the string to the pool, and then returns a reference to the (only) version of the string contained in the pool. For instance, consider the following program:\n// Creates a string \u0026#34;foo\u0026#34;, String myString = new String(\u0026#34;foo\u0026#34;) // adds it to the pool, myString = myString.intern(); // Creates another string \u0026#34;foo\u0026#34;, String sameString = new String(\u0026#34;foo\u0026#34;); // Outputs false. System.out.println(myString == sameString); // Tries to add \u0026#34;foo\u0026#34; to the pool once again. // Because the pool already contains a version of \u0026#34;foo\u0026#34;, returns a reference to it. sameString = sameString.intern(); // Outputs true, because the two variables now hold the same reference. System.out.println(myString == sameString); A string that is initialized without constructor (i.e. directly with \u0026quot; \u0026ldquo;) is interned. For instance\nString myString = \u0026#34;foo\u0026#34;; String sameString = \u0026#34;foo\u0026#34;; // Outputs true, because of (implicit) interning System.out.println(myString == sameString); In order to support interning, string in Java are immutable.\nIn particular, the instance methods of the class String (like substring, etc.) do not modify a string. Instead, some of them may return (a reference to) a different object. For instance:\nString foo = new String(\u0026#34;foo\u0026#34;); String copy = foo; // Outputs true, because the two variables hold the same object reference. System.out.println(copy == foo); foo = foo.replace(\u0026#39;o\u0026#39;,\u0026#39;O\u0026#39;); // Outputs false, because the method \u0026#39;replace\u0026#39; returns a reference // to another object. System.out.println(copy == foo); The class String overrides the method equals so that it implements string comparison in the expected way. For instance:\nString myString = new String(\u0026#34;foo\u0026#34;); String sameString = new String(\u0026#34;foo\u0026#34;); // Outputs false. System.out.println(myString == sameString); // Outputs true. System.out.println(myString.equals(sameString)); **_Hint._** By default, you can always use `equals` to compare the values of two strings. This is less error-prone than `==` (albeit less efficient if the two strings differ). Java boxed types # Java has 8 primitive types: byte, short, int, long, float, double, boolean and char.\nFor each primitive type, Java has a so-called boxed or (wrapper) type: Byte, Short, Integer, Long, Float, Double, Boolean and Character.\nThese types can be used in Java collections (Set, List, etc.), whereas primitive types cannot. Some boxed types also offer additional functionalities, via instance methods (e.g. an Integer can represent a positive numbers up to \\(2^{32} - 1\\) ).\nConstructors for boxed types are deprecated. Instead, instances can be created via so-called autoboxing, for instance:\nInteger myInteger = 2; Character myCharacter = \u0026#39;a\u0026#39;; Several Java operators (like +, ==, \u0026lt;=, etc.) are also overloaded so that they behave with boxed types as they would with primitive types. For instance:\nInteger i = 1; i += 1; Integer j = 2; // Outputs true System.out.println(i == j); Like strings, instances of boxed types are immutable. This can affect performance. For instance:\nfor (Integer i = 0; i \u0026lt; 1000000 ; i++){ ... } may create up to 1 million objects in memory. This is one of the reasons why it is usually recommended to use primitive types whenever possible (see for instance Effective Java, Item 61). Some boxed types are (partially) interned, analogously to strings.\n"},{"id":10,"href":"/docs/objects/sections/encapsulation/","title":"Encapsulation","section":"Objects and classes","content":" Encapsulation # **Encapsulation** is a (vague) principle in object-oriented programming that refers to _\"bundling\"_ data with the code that operates on it, and _restrict visibility_ of this code and data to other components of a system. From Wikipedia: \u0026ldquo;Essentially, encapsulation prevents external code from being concerned [\u0026hellip;]\u0026rdquo;\nEach component hides its internal logic by exposing only data and methods that other components may need.\n**_Example._** As we saw [earlier](http://localhost:39433/docs/objects/sections/clone/), in our game, the \"view\" component (which is in charge of rendering the game on screen) may _buffer_ the game snapshots that it receives from the backend, if these snapshots are received faster than they can be displayed. As a buffer, this component uses a structure called a **queue**. This queue is _not exposed_ to other components, because they do not need to _see_ it, and (most importantly) should not _modify_ it. In other words, this queue is an implementation detail, _internal_ to the \"view\" component. Encapsulation can have many benefits. Among others:\nEasier debugging. If our queue is internal to the \u0026ldquo;view\u0026rdquo; component, then we know that it cannot be responsible for the malfunction of another component. Easier collaboration. Alice may refactor the implementation of the \u0026ldquo;view\u0026rdquo; component, knowing that this will not affect Bob, who is currently working on the backend. This is why a common practice in object-oriented programming consists in hiding all attributes and methods of a new class by default, and make accessible only the ones that need to be (in particular, this is likely to be the default behaviour of your IDE).\nEncapsulation also largely dictates how libraries are structured. For instance, when you create a String in Java, you do not have access to the internal representation of the string object.\nin Java # Each attribute or method of a class can have an access modifier, which specifies which other classes can access it. For instance, the keywords private and protected below are access modifiers.\nprivate int myAttribute; protected int myMethod(){ return 1; } **_Definition._** There are four levels of access in Java: - `private` restricts access to the _current class_, - \"package-private\" relaxes `private` by also allowing access from the _folder_ of the current class (in Java, a folder for source code is called a **package**), _excluding subfolders_, - `protected` relaxes \"package-private\" by also allowing access from the _subclasses_ of the current class, - `public` does not restrict access. **_Warning._** There is no keyword for the \"package-private\" level. Instead, this is the default level for an attribute or method _without_ access modifier. For instance, in the example below, the attribute `myAttribute` is package-private: int myAttribute; Here is a recap table from the Oracle tutorials:\nkeyword class package subclasses world private yes no no no none yes yes no no protected yes yes yes no public yes yes yes yes **_Warning._** A method declared in an [interface]() is (implicitly) public. **_Warning._** If a method _m1_ overrides (or implements) a method _m2_, then _m1_ must be at least as accessible as _m2_. Exercise The following program does not compile. Can you see why, and how to fix this? ```bash ├── Run.java └── units ├── Unit.java └── impl └── Unicorn.java ``` ```java public abstract class Unit { static String configFolder = \"path/to/config\"; } ``` ```java public class Unicorn extends Unit { String name; public Unicorn (String name){ this.name = name; } public static String getConfigFilePath (){ return configFolder + \"/unicorn.properties\"; } } ``` ```java public class Run { void testUnicorn(){ Unicorn myUnicorn = new Unicorn(\"Storm\"); myUnicorn.name = \"Tornado\"; } } ``` Solution - `Unicorn.getConfigFilePath` tries to access the package-private attribute `Unit.configFolder` (it should be made protected of public), - `Run.getConfigFilePath`, tries to access the package-private attribute `name` of `myUnicorn` (it should be made public). **_Hint._** Your IDE may suggest how to fix such compilation errors. To improve encapsulation, it is good practice to restrict access whenever possible (i.e. without compromising compilation).\n**_Hint_.** As a rule of thumb, in Java: - use `private` by default for all attributes and methods that you create, and - if the program does not compile, then use your IDE to relax access. Exercise Encapsulation in this program can be improved. Can you see how? ```bash ├── Run.java └── units ├── Unit.java └── impl └── Unicorn.java ``` ```java public abstract class Unit { public int health; public Unit(int health) { this.health = health; } public void attack(Unit defender){ int copy = health; health -= defender.health; defender.health -= copy; } } ``` ```java public class Unicorn extends Unit { public Unicorn (){ super(1); } @Override public void attack(Unit defender){ regen(); super.attack(defender); } public void regen(){ health += 1; } } ``` ```java public class Run { void testUnicorn(){ Unicorn u1 = new Unicorn(); Unicorn u2 = new Unicorn(); u1.attack(u2); } } ``` Solution - `Unit.health` can be made protected, - the constructor of `Unit` can be made protected, - `Unit.attack` can be made protected, - `Unicorn.regen` can be made private. **_Note._** The constructor of an _abstract_ class can always be made protected (since it can only be called in the constructor of a subclass). Getters and setters # For attributes, the notion of \u0026ldquo;access\u0026rdquo; can be refined. An attribute may be:\nneither visible nor modifiable, or only visible, or only modifiable, or both visible and modifiable. This can be achieved with private attributes and so-called \u0026ldquo;getter\u0026rdquo; and \u0026ldquo;setter\u0026rdquo; methods. For instance, in the following class, the attribute health has public visibility but is not modifiable.\npublic class Unicorn { private int health; public int getHealth(){ return health; } } Conversely, in the following class, the attribute health can be modified but is not visible.\npublic class Butterfly { private int health; public void setHealth(int health){ this.health = health; } } **_Hint._** Getter and setter methods can be automatically generated by your IDE. To go further: inheritance violates encapsulation # Composition # **_Example_** (from [Effective Java](), Item 18). Consider a class `MyHashSet` that extends Java's `Hashset` functionality by keeping track of the number of objects _added_ to the set (as opposed to the output of `HashSet.size()`, which returns the numer of elements _remaining_ in the set). This class `myHashSet` may have an attribute `int counter` (initialized to `0`) that keeps track of the number of elements added to the set so far. And it may be implemented by overriding `add` and `addAll` in the expected way, i.e.: ```java @Override public boolean add(E e){ counter++; return super.add(e); } @Override public boolean addAll(Collection\u003c? extends E\u003e c){ counter += c.size(); return super.addAll(c); } ``` However, this implementation of `addAll` would count every insertion twice, because the implementation of `HashSet.addAll` calls `HashSet.add`. A design pattern called composition can be used to avoid such unintended effects. Intuitively, instead of extending the original class, use an instance Hashset set of it as a (private) attribute of the new class. However, this requires re-implementing all methods of the original class (albeit in a straightforward way), for instance:\npublic boolean isEmpty(){ return set.isempty(); } Prevent overriding or inheritance # As show by the example above, in order to improve encapsulation, one may want in some scenarios to forbid overriding a method or extending a class. In Java, this can be enforced with the keyword final, for instance:\npublic final class NonExtensibleClass { ... } public class MyClass{ public final void nonOverridableMethod(){ ... } } "},{"id":11,"href":"/docs/objects/sections/mutability/","title":"Mutability","section":"Objects and classes","content":" Mutability # Illustration # Exercise The Java method `createUsers` below is incorrect. Can you see why, and how to fix this? ```java public class User { int id; String name; } ``` ```java /* Input: - ids: a nonempty array of user identifiers - names: an array of the same length as 'ids' that contains user names Ouput: an array of users of the same lenght as 'ids', such as the i-th user has identifier ids[i] and name names[i] */ User[] createUsers(int[] ids, String[] names){ User[] users = new User[names.length]; User currentUser = new User(); for(int i = 0; i \u003c ids.length; i++){ currentUser.id = ids[i]; currentUser.name = names[i]; users[i] = currentUser; } return users; } ``` Possible solution The output array contains $i$ times the same user (with the last id and name from the input arrays). One way to fix this is: - add an explicit constructor to the class `User`: ```java public class User { int id; String name; public User(int id, String name){ this.id = id; this.name = name; } } ``` - call this constructor for each new user: ```java public User[] createUsers(int[] ids, String[] names) { User[] users = new User[names.length]; for(int i = 0; i \u003c ids.length; i++){ users[i] = new User(ids[i], names[i]); } return users; } ``` In this example, an instance of the class User is a mutable object, meaning that its attributes (id and name) can be modified after the object is created. However, these two values (or at least the value of the attribute id) are unlikely to change.\nIn Java (or C#, C++, etc.), it is possible to forbid these two values to be modified. This would have prevented compilation of the incorrect program above.\nImmutable object # Informally, an object is mutable if it can be modified after its creation.\nImmutability has many known benefits (but also drawbacks):\nBenefits # Easier debugging: as illustrated above, forcing an object to be immutable may prevent an incorrect program to compile. Compile-time errors are usually easier to fix that bugs. Readability: code that modifies or reuses objects can be harder to understand (and reason about) than code that creates (fresh) immutable objects. Thread-safety: multiple threads can access an immutable object concurrently without race condition. Easier collaboration and maintenance: Alice can safely pass an immutable object to Bob (i.e. make the object visible to Bob\u0026rsquo;s code). This will not affect the correctness of Alice\u0026rsquo;s code (because Bob\u0026rsquo;s code cannot modify this object). Reference. For a more in-depth analysis of the benefits of immutability, we refer to Effective Java, item 17:\n\u0026ldquo;Classes should be immutable unless there\u0026rsquo;s a very good reason to make them mutable.\u0026rdquo;\n**_Observation._** Some programming language (like Haskell or Rust), enforce (a form of) immutability by default. Drawbacks # Performance: on a large scale (e.g. thousands of objects), reusing existing object may be more efficient that creating (fresh) immutable ones. Terminology # The term \u0026ldquo;immutable object\u0026rdquo; (or \u0026ldquo;immutable class\u0026rdquo;) is used with slightly different meanings. In particular:\na weaker notion of immutability only requires the attributes of an object to be non-modifiable, a stronger notion also requires the objects that are referred to (transitively) to be non-modifiable. By convention, we will use in what follows the term \u0026ldquo;final\u0026rdquo; for the weaker requirement, and \u0026ldquo;immutable\u0026rdquo; for the stronger requirement. More precisely:\n**_Definition._** An object is **final** if its attributes cannot be modified after the object's creation. **_Definition._** An object is **immutable** if it is final and the objects that it references are immutable. in Java # final # The Java keyword final ensures that a variable cannot change value after its initialization.\n**_Example._** The following Java program does not compile. ```java final int a = 2; a = 3; ``` **_Warning._** This meaning of the keyword `final` is different from that we already saw in the section on [encapsulation](http://localhost:39433/docs/objects/sections/encapsulation/#final). When the variable is an instance attribute, this also forces the attributes to be explicitly instantiated before the execution of the constructor terminates.\n**_Example._** The following Java program does not compile. ```java public class User { final int id; final String name; public User(int id){ this.id = id; } } ``` **_Example._** The following Java program compiles, and the instances of `User` are immutable (because strings in Java are themselves immutable). ```java public class User { final int id; final String name; public User(int id){ this.id = id; this.name = name; } } ``` **_Note._** Alternatively, a `final` instance attribute can be instantiated immediately after it is declared (because this instruction is executed before the constructor). For instance, the following program compiles. ```java public class User { public final int id; public final String name = \"Alice\"; public User(int id){ this.id = id; } } ``` **_In practice._** Your IDE is likely to create `final` (and `private`) instance attributes by default. final vs immutable # **_Warning._** The `final` keyword may not be sufficient to enforce immutability (at least as it is defined above), in particular when a `final` attribute refers to a mutable object. **_Example._** Instances of the class `User` below are final, but not immutable, because instances of `Address` are not immutable. ```java public class User { final int id; final Address address; public User(int id, Address address){ this.id = id; this.address = address; } } public class Address { int streetNumber; String street; int zipCode; public Address(int streetNumber, String street, int zipCode){ this.streetNumber = streetNumber; this.street = street; this.zipCode = zipCode; } } ``` For instance, the following code compiles. ```java Address myAddress = new Address(14, \"via Goethe\", 39100); User myUser = new User(1, myAddress); myAddress.streetNumber = 12; ``` Final and immutable types # We already encountered several types of Java object and quasi-objects that are:\nfinal: records, sets (resp. lists, maps) that are declared with Set.of() (resp. List.of(), Map.of()), immutable: strings, boxed types (like Integer or Boolean). Record # A record is final.\n**_Examples._** Because strings are immutable, the following records are immutable: ```java record User(int id, String name){}; ``` However, the following records are only final (unless instance of `Address` are immutable): ```java record User(int id, String name, Address address){}; ``` Set, List, Map # If a set (resp. list, map) is created with Set.of() (resp. List.of(), Map.of()), then its content is final.\n**_Example._** The following Java program throws an `UnsupportedOperation` exception. ```java Set mySet = Set.of(2, 3); mySet.add(5); ``` However, if the set (resp. list, map) contains references, then the objects that are referred to may be mutable.\n**_Example._** The following program compiles (assuming that the attribute `streetNumber` of the class `Address` does not have the `final` keyword). ```java Address myAddress = new Address(14, \"via Goethe\", 39100); Set mySet = Set.of(myAddress); myAddress.streetNumber = 12; ``` By design, most other implementations of List, Set and Map are not final (this is expected, for performance reasons).\nHowever, in some scenarios, a program may create a (small) list (resp. set, map) that is not meant to be modified. For instance, the list of all files in a folder. In this case, the list (resp. set, map) can be made final. A common way to achieve this is the class ImmutableList (resp. ImmutableSet, ImmutableMap) of the Guava library.\nTo use Guava in a Maven project, declare this dependency:\n\u0026lt;dependencies\u0026gt; ... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.guava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;guava\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;33.1.0-jre\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; ... \u0026lt;/dependencies\u0026gt; or in a Gradle project:\nimplementation group: \u0026#39;com.google.guava\u0026#39;, name: \u0026#39;guava\u0026#39;, version: \u0026#39;33.1.0-jre\u0026#39; String # Java\u0026rsquo;s strings are immutable.\nHowever, the class StringBuilder implements a mutable string. It provides instance methods like append, insert, delete (a substring), etc.\nBoxed types # Java\u0026rsquo;s boxed types (like Integer or Boolean) are immutable.\nHowever, each boxed types has a mutable \u0026ldquo;atomic\u0026rdquo; counterpart, e.g. AtomicInteger for Integer and AtomicBoolean for Boolean.\nThe main purpose of these classes is to offer build-in thread safety for common sequences of operations. For instance, AtomicInteger provides a method equivalent to i++, but thread-safe (note that i++ is a shortcut for three operations: read the value, increment it and write it back).\nExercise What does the following program output? ```java Boolean b = true; // Create an atomic boolean with value true AtomicBoolean ab = new AtomicBoolean(true); List booleans = new LinkedList\u003c\u003e(); List aBooleans = new LinkedList\u003c\u003e(); booleans.add(b); aBooleans.add(ab); b = false; // Set the value of the atomic boolean to false ab.set(false); booleans.add(b); aBooleans.add(ab); System.out.println(booleans); System.out.println(aBooleans); ``` Solution ``` [true, false] [false, false] ``` "},{"id":12,"href":"/docs/objects/sections/quiz/","title":"Quiz","section":"Objects and classes","content":" Quiz # To answer the quiz (and check your answers), click here or scan this code:\nBoxed type # public class City { int population; public City (int population){ this.population = population; } } int myInteger = 1; Integer myBoxedInteger = 1; Integer myBoxedCopy = myInteger; City myCity = new City(5000); myMethod(myInteger, myBoxedInteger, myBoxedCopy, myCity); System.out.println( myInteger + \u0026#34;, \u0026#34;+ myBoxedInteger + \u0026#34;, \u0026#34;+ myBoxedCopy + \u0026#34;,\u0026#34; + myCity.population); void myMethod(int integer, Integer boxedInteger, Integer boxedCopy, City city) { integer += 1; boxedInteger += 1; boxedCopy += 1; city.population += 1; } This Java program outputs:\n1, 1, 1, 5000 1, 1, 1, 5001 1, 2, 1, 5000 1, 2, 1, 5001 1, 2, 2, 5000 1, 2, 2, 5001 2, 2, 2, 5000 2, 2, 2, 5001 I do not know the answer Objects and references # ```java public class City { String name; Country country; public City(String name, Country country) { this.name = name; this.country = country; } } ``` ```java public class Country { String name; City capital; public Country(String name, City capital) { this.name = name; this.capital = capital; } } ``` Country italy = new Country(\u0026#34;Italy\u0026#34;, null); City florence = new City(\u0026#34;Florence\u0026#34;, italy); City rome = new City(\u0026#34;Rome\u0026#34;, italy); italy.capital = rome; System.out.print(italy.capital.name + \u0026#34;, \u0026#34;); System.out.print(florence.country.capital.name + \u0026#34;, \u0026#34;); System.out.print(rome.country.capital.name + \u0026#34;, \u0026#34;); System.out.print(rome.country.capital.country.capital.name); This Java program:\ndoes not terminate outputs null, null, null, null outputs null, null, Rome, null outputs null, null, Rome, Rome outputs Rome, null, null, null outputs Rome, null, Rome, null outputs Rome, null, Rome, Rome outputs Rome, Rome, Rome, Rome I do not know the answer Copy constructor # ```java public class City { String name; Country country; public City(String name, Country country) { this.name = name; this.country = country; } public City (City original) { this.name = original.name; this.country = original.country; } } ``` ```java public class Country { String name; City capital; public Country(String name, City capital) { this.name = name; this.capital = capital; } public Country(Country original){ this.name = original.name; this.capital = new City(original.capital); } } ``` Country italy = new Country(\u0026#34;Italy\u0026#34;, null); City rome = new City(\u0026#34;Rome\u0026#34;, italy); italy.capital = rome; Country littleItaly = new Country(italy); littleItaly.name = \u0026#34;littleItaly\u0026#34;; littleItaly.capital.name = \u0026#34;littleRome\u0026#34;; System.out.print(littleItaly.capital.name+ \u0026#34;, \u0026#34;); System.out.print(littleItaly.capital.country.name+ \u0026#34;, \u0026#34;); System.out.print(littleItaly.capital.country.capital.name); This Java program:\ndoes not terminate outputs Rome, Italy, Rome outputs Rome, littleItaly, Rome outputs littleRome, Italy, Rome outputs littleRome, littleItaly, Rome outputs littleRome, littleItaly, littleRome I do not know the answer toString # ```java public class City { String name; Country country; public City(String name, Country country) { this.name = name; this.country = country; } @Override public String toString() { return \"City{\"+ \"name=\" + name + \", \"+ \"country=\" + country + \"}\"; } } ``` ```java public class Country { String name; City capital; public Country(String name, City capital) { this.name = name; this.capital = capital; } @Override public String toString() { return \"Country{\"+ \"name=\" + name + \", \"+ \"capital=\" + capital + \"}\"; } } ``` In this program, the method City.toString():\ncan output the empty string always outputs the empty string never outputs the empty string is recursive is not recursive may not terminate always terminates never terminates Static attribute # public class MyClass { static int value; boolean flag; public MyClass(int value, boolean flag){ this.value = value; this.flag = flag; } void print(){ System.out.print(\u0026#34;[\u0026#34;+value+\u0026#34; \u0026#34;+flag+\u0026#34;]\u0026#34;); } void incrementValue(){ value++; } void setFlag(boolean flag){ this.flag = flag; } } MyClass o1 = new MyClass(2, true); MyClass o2 = new MyClass(3, false); o1.print(); myMethod(o1); o1.print(); void myMethod(MyClass object) { object.setFlag(false); object.incrementValue(); object.print(); } This (strange) Java program outputs:\n[2 true][3 false ][3 false] [3 true][4 false ][4 false] [2 true][3 false ][2 true] [3 true][4 false ][3 true] [2 false][3 false ][3 false] [3 false][4 false ][4 false] [2 false][3 false ][2 true] [3 false][4 false ][3 true] I do not know the answer. "}]