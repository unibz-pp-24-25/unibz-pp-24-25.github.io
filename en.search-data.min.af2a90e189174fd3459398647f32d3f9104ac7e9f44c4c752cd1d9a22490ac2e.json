[{"id":0,"href":"/docs/git/sections/basics/","title":"Basics: repository, commits and branches","section":"git","content":" Basics: repository, commits and branches # Repository # A git **repository** is a folder that stores a project. It is identical to a regular folder, except for a hidden folder named `.git`. This folder stores (among others) the whole history of the project. Commit # A **commit** is a snapshot of a repository. Each commit has medatada associated to it. In particular:\nan ID, the name of the commit\u0026rsquo;s author, a timestamp, a message that describes the commit. For instance, Alice may create a fresh git repository, add some files to it, and commit these files. After this step, Alice\u0026rsquo;s repository may be pictured as follows.\nNext, Alice may modify some of these files (and/or add new ones), and commit these changes:\n**_Notation._** In the figures below, for readability, we will omit the commits' metadata. So the above repository will be represented as: ![](/img/git/second_commit_no_pointer.svg) Main branch # By default, Alice\u0026rsquo;s commits belong the main branch of her repository (often called main or master). You can think of a branch as a timeline.\nGit keeps tack of the latest commit on this branch with a so-called \u0026ldquo;pointer\u0026rdquo; (you can think of it as a variable) to that commit: Time travel # Alice can load any previous snapshot of her repository. The history of the repository will not be affected.\nTo achieve this, Git uses another \u0026ldquo;pointer\u0026rdquo; called HEAD, which intuitively keeps track of the current position of Alice in the commit\u0026rsquo;s history. By default, HEAD points to the main pointer: If Alice decides to load her previous snapshot (thanks to the git checkout command), then HEAD will instead point to the corresponding commit: In this case (i.e. when it does not point to a branch pointer, but directly to a commit), the HEAD pointer is said to be in a detached state.\nBranching time # Alice may want to work on an experimental feature of her project. She can develop this feature in an \u0026ldquo;alternative timeline\u0026rdquo;, a.k.a. another branch.\nBefore creating this new branch, Alice most likely wants to travel back to her latest commit. This will move the HEAD pointer back to where it was:\nNow Alice may create a new branch, and name it myFeature. This will create a new branch pointer:\nAlice can also specify that she want to work on this new branch (using the git checkout command still). This will affect the HEAD pointer:\nNext, Alice may implement (part of) her new feature, and commit these changes. This will move the myfeature pointer forward:\nNow Alice may need to fix an urgent bug on her main branch. If she switches to the main branch (again, with git checkout), then HEAD will point to it:\nAlice may fix the bug and commit her changes. This will create a commit and move the main pointer as expected. The two branches now diverge:\nThen Alice may switch back to the myFeature branch to resume her work:\nAnd add a commit to this branch:\nHistory # The history of a branch consists of all commits on a path from the branch\u0026rsquo;s pointer to the original commit. For instance, this is the history of the myFeature branch: And this is the history of main branch: Merging branches # We left Alice\u0026rsquo;s repository in this situation: Alice is now satisfied with her new feature, and she wants to incorporate it into her main branch.\nTo do so, she first switches to the receiving branch (in this case, the main branch): Then she can merge the branch myFeature into the branch main. Because the two branches have diverged, this will generate a new commit, called a merge commit:\nBefore she can create a merge commit, Alice may need to fix potential conflicts between the diverging branches.\nIn this happens, then git will provide Alice a list of files that contain so-called \u0026ldquo;merge conflicts\u0026rdquo;. In each of theses files, each conflict will be identified as follows:\n\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD \u0026lt;Conflicting content from the receiving branch\u0026gt; ======= \u0026lt;Conflicting content from the merged branch\u0026gt; \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026lt;mergedBranchName\u0026gt; After a merge # Observe that a merge commit (usually) has two parent commits. More generally:\na repository with merge commits is not a tree. in such a repository, the history of a \u0026ldquo;branch\u0026rdquo; may consists of commits from different paths. For instance, here is the history of the main branch: Note that after this merge, all commits of the myFeature branch are part of the history of the branch main.\nAlice may keep the myFeature branch for some future usage, or she may decide to delete it. In the latter case, the myFeature pointer will simply be deleted:\nFast-forward merge # If two branches have not diverged, then there is a simpler way to merge them.\nFor instance, consider Carol\u0026rsquo;s repository:\nThe branches main and experimental have not diverged. So experimental can be merged into main by simply moving the main pointer:\nIn this case, no merge commit is needed. This is called a fast-forward merge.\n"},{"id":1,"href":"/docs/errors/sections/callstack/","title":"Call stack","section":"Errors","content":" Call stack # A **call stack** is a [stack](http://localhost:41071/docs/abstractdatatypes/sections/queue/#stack) that keeps track of the methods that are active during the execution of a program. By \"active\", we mean that an execution of the method has started and has not terminated yet. When the execution of a method starts, it is \"added\" to the stack. When it terminates, the method is \"removed\" from the stack, and control is passed back to the method that called it. A debugger provides a representation of the successive states of a call stack, with references to the source code. This gives the illusion of source code being interpreted verbatim.\n**_Example._** In our game, consider the following implementation of the method `callReinforcement`: ```java {linenos=true} public class Backend implements EventHandler { Snapshot currentSnapshot; ... @Override public void callReinforcement() { Player activePlayer = currentSnapshot.getActivePlayer(); int unitsToInsert = currentSnapshot.getSizeOfReinforcement(activePlayer); while (unitsToInsert \u003e 0){ Unit unit = generateRandomUnit(); TileCoordinates coordinates = findInsertionSpot(unit); if(coordinates != null) { addUnit(coordinates, unit); unitsToInsert--; } } } private Unit generateRandomUnit() { ... } private TileCoordinates findInsertionSpot(Unit unit) { ... } private void addUnit(TileCoordinates coordinates, Unit unit) { currentSnapshot.getBoard().addUnit(coordinates.rowIndex(), coordinates.columnIndex(), unit); performUnitMerges(); } private void performUnitMerges() { ... } } ``` When the method callReinforcement is called, it is added (a.k.a. pushed) on top of the call stack. This is rendered by a debugger as:\ncallReinforcement \u0026lt;bottom of the stack\u0026gt; If execution \u0026ldquo;reaches\u0026rdquo; Line 11, then the method generateRandomUnit is called and added to the stack:\ngenerateRandomUnit callReinforcement: 11 \u0026lt;bottom of the stack\u0026gt; When the method generateRandomUnit terminates, it passes control (as well as a Unit) back to the method that called it, namely callReinforcement, which can resume its execution:\ncallReinforcement \u0026lt;bottom of the stack\u0026gt; Similarly, when execution \u0026ldquo;reaches\u0026rdquo; Line 12, findInsertionSpot is added to the stack, executed, and then removed from the stack, passing control back to callReinforcement.\nThen if execution \u0026ldquo;reaches\u0026rdquo; Line 14, addUnit is executed, which in turn calls performUnitMerges:\nperformUnitMerges addUnit: 28 callReinforcement: 14 \u0026lt;bottom of the stack\u0026gt; etc.\n**_Note._** If a method is recursive (i.e. if it calls itself, _directly or indirectly_), then it may appear multiple times in the call stack. E.g.: ``` method1 method2: 16 method1: 8 ``` **_Definition._** A **stack overflow** occurs when the size of the call stack exceeds the capacity allowed by the execution environment. This is generally due to a non-terminating recursive method. "},{"id":2,"href":"/docs/background/sections/problem/","title":"Computational problem","section":"Background","content":" Computational problem # A **computational problem** is (usually) specified as: - a set of possible **inputs**, and - the expected **outputs** (for these inputs). Problem vs algorithm # For instance, here is a problem that you may have encountered already:\nInput: a sorted array A of integers, an integer a Output: true if a appears in A, false otherwise There are (infinitely) many algorithms that can solve this problem. But some of them are more efficient than others. Efficiency (a.k.a. computational cost) refers to the time and/or memory needed to execute an algorithm, expressed as a function of the size of the input (more on this later).\nExercise Can you think of (or do you already know) an algorithm that can solve this problem efficiently? Why is it efficient? Solution **_Algorithm._** Let _n_ be the size of _A_, and let us assume for simplicity that arrays are 1-indexed and that _A_ is nonempty. - If _n_ = 1, then check whether _A_[1] = _a_. - Otherwise: - check whether _A_[_n_/2] = _a_ (where \"/\" is integer division, rounded up or down if _n_ is odd), - depending on the result, repeat on either the left or the right half of _A_. **_Cost._** If _A_ has length _n_, then the number of iterations of the procedure is (in the order of) log*2 \\_n* in the worst case (e.g. if _a_ does not appear in _A_). Here is another problem that you may know:\nInput: an array of integers Output: an array with the same values, but sorted in ascending order And yet another:\nInput: a solvable grid of sudoku Output: the same grid, solved **_Note._** A problem specifies _what_ a program should do, not _how_ to do it. In other words, a computational problem is _not an algorithm_. For instance, the following is not a computational problem:\nInput: an array of integers. Algorithm: initialize a counter to 1. Then iterate through the array, and: increment the counter each time 2 consecutive numbers are encountered, and reset the counter to 1 otherwise. Exercise Which problem does this algorithm solve? Solution - **_Input:_** an array _A_ of integers - **_Output:_** the length of the longest suffix of _A_ that consists of consecutive numbers Formulating a problem # When developing a project, it can be helpful to express some sub(tasks) as computational problems. This is also a common way to document your code.\nFor instance the Javadoc of a class may consist of computational problems (e.g. the Javadoc for the method indexOf of the class String in Java).\nWhen formulating a problem, make sure that:\nthe output is specified for all inputs, and the formulation is non-ambiguous, meaning that it should clearly specify whether any given pair (input, output) is correct. Exercise Consider the class `Unit` (and its subclasses), as defined in [the section about inheritance](http://localhost:41071/docs/objects/sections/inheritance/). The following problem is not properly defined. Can you see why? - **_Input:_** a nonempty array _A_ of instances of the class `Unit` - **_Output:_** the unicorn with highest health in _A_ Solution There may be no unicorn in _A_, or several healthiest unicorns. Exercise The following problem is not properly defined. Can you see why? - **_Input:_** a (finite) family of (finite) sets - **_Output:_** the smallest set that has a nonempty intersection with each of the input sets (where \"smallest\" here refers to the _size_ of a set) For instance, for the input ``` { {a,c,k}, {a,b}, {a,m}, {c,d,f}, {c,e} } ``` the expected output is ``` {a,c} ``` Solution Some inputs admit more than one solution (the simplest example is the input `{a,b}`). **_Note._** A problem may admit several outputs for the same input _without being ambiguous_. For instance: - **_Input._** a graph _G_, two nodes _s_ and _t_ in _G_, - **_Output:_** one of the shortest paths from _s_ to _t_ in _G_ if any, and `null` otherwise. A problem may be [undecidable](https://en.wikipedia.org/wiki/Undecidable_problem), meaning that for any algorithm attempting to solve this problem, there (provably) exist (infinitely many) inputs for which the algorithm either produces an incorrect output or does not terminate. A problem may be decidable but [intractable](https://en.wikipedia.org/wiki/Computational_complexity_theory#Intractability), meaning that (provably) no _efficient_ algorithm can solve it (where cost is once again measured as a function of the size of the input). "},{"id":3,"href":"/docs/multithreading/sections/concurrency/","title":"Concurrency","section":"Multithreading","content":" Concurrency # Core # A **core** is a basic processing unit. A Central Processing Unit (CPU) contains one or several cores (e.g. 4 or 8).\nA Graphical Processing Unit (GPU) can contain thousands of cores.\nParallelism vs concurrency # **_Terminology._** We call **time span** of a (computational) tasks the time interval comprised between the task's start and completion. The time spans of two tasks may overlap.\n**_Example._** While downloading a video, Alice may use git to commit changes to her repository. These two tasks overlap. **_Definitions._** Two overlapping tasks can be executed either: - on _different_ cores: this is called **parallelism**, or - on the _same_ core, in an interleaved fashion: this is called **concurrency**. **_Example._** Consider a core that executes (sequentially) a task $t_1$ that repeatedly reads data from a database (stored on a hard drive). The core is likely to remain unused while data is being fetched from the hard drive. Instead, while $t_1$ is fetching data, the same core could be used to perform computations for a task $t_2$. Context switch # **_Definition._** A **context switch** is the operation that consists in storing the system's state for a running task (so that it can be paused and resumed later on), and restoring a different, previously saved state. "},{"id":4,"href":"/docs/datastructures/sections/list/","title":"Dynamic array and linked list","section":"Data structures","content":" Dynamic arrays and linked lists # Dynamic array # A dynamic array is typically used to implement the abstract data type list.\nStructure # A **dynamic array** stores the elements of a list in a regular array $A$, and keeps track of the size of the list. If the size of the list exceeds the capacity of $A$, then the content of $A$ is copied into a larger array $A'$, and $A$ is replaced with $A'$. Array dequeue # An **array dequeue** is a variant of a dynamic array that allows the list to be extended in both directions. The array is initially populated from its middle index. In addition to a list, an array dequeue is commonly used to implement a queue and/or a stack.\nin Java # The class ArrayList implements the interface List as a dynamic array.\nLinked list # A **linked list** is a sequence of nodes, where each node (except for the last) points to its successor. A linked list maintains a pointer to its first node, called its **head**. **_Example._** ![](/img/linkedLists/labeled/char/withDup/list.svg) In addition to a list, a linked list is often used to implement a stack.\nDoubly linked list # A **doubly linked list** is a linked list where each node points in addition to its predecessor (if any). A doubly linked list maintains a pointer to its head and a pointer to its last node. In addition to a list and/or a stack, a doubly linked list is often used to implement a queue.\nin Java # The classjava.util.LinkedList implements the interfacesList and Dequeue as a double linked list.\nPerformance # Exercise Determine the worst case running time of the following operations on a list, stack and/or queue, if the underlying data structure is: 1. as a dynamic array 1. a linked list 1. a doubly-linked list - as a function of $i$: - read or modify the value at position $i$ - as a function of the size $n$ of the list: - add an element at the beginning of the list - add an element at the end of the list - remove the element at position $i$ - remove the first element of the list - remove the last element of the list - as a function of the cumulated size $n$ of the two lists: - concatenate two lists Solution | problem | dynamic array | linked list | doubly linked list | | --------| --------------| ----------- |--------------------| | read or modify the value at position $i$ | $\\Theta(1)$ | $\\Theta(i)$ | $\\Theta(i)$ | | remove the element at position $i$| $\\Theta(n)$ | $\\Theta(n)$| $\\Theta(n)$ | | add an element at the beginning of the list| $\\Theta(n)$| $\\Theta(1)$ | $\\Theta(1)$ | add an element at the end of the list|$\\Theta(1)$| $\\Theta(n)$ | $\\Theta(n)$ | | remove the first element of the list| $\\Theta(n)$| $\\Theta(1)$ | $\\Theta(1)$ | | remove the last element of the list| $\\Theta(1)$| $\\Theta(n)$ | $\\Theta(1)$ | | concatenate two lists|$\\Theta(n)$| $\\Theta(n)$| $\\Theta(1)$ | Locality # Besides constant time reading and writing, another benefit or arrays (ignored in the standard RAM model) is contiguity in memory. Iterating over an array can be more efficient than iterating over a linked list, because it benefits from caching.\n"},{"id":5,"href":"/docs/simplify/sections/factorization/","title":"Factorizing","section":"Simplifying code","content":" Factorizing # Duplicate code # Duplicate code within a same project has undesirable consequences. In particular:\nDuplicate code means duplicate bugs. The application may be harder to extend: adding a new feature may require modifying several nearly identical copies of the same method and/or class. Factorizing # By **code factorization**, we mean eliminating duplicate statements or expressions, by analogy to the factorization of an algebraic expression (e.g. $(ab) + (ac)$ can be rewritten $a(b+c)$). This usually comes down to simple techniques. We illustrate here a few of them.\nConditional statement # Exercise Factorize the following program: ```java if(){ } else if( \u0026\u0026 ){ } else { } ``` Solution ```java if(){ if(){ } } ``` Auxiliary method # Exercise Factorize the following Java class: ```java public class Extractor { String extractId(String text){ Matcher matcher = Pattern.compile(\"^[A-Z]?\\\\d+\").matcher(text); return matcher.find()? matcher.group(0): null; } String extractSSN(String text){ Matcher matcher = Pattern.compile(\"SSN:(\\\\d+)\").matcher(text); return matcher.find()? matcher.group(1): null; } } ``` Possible solution ```java public class Extractor { String extractId(String text){ return getFirstMatch(text, \"^[A-Z]?\\\\d+\", 0); } String extractSSN(String text){ return getFirstMatch(text, \"SSN:(\\\\d+)\", 1); } String getFirstMatch(String text, String regex, int group){ Matcher matcher = Pattern.compile(regex).matcher(text); return matcher.find()? matcher.group(group): null; } } ``` Abstract class # Exercise Factorize the following Java classes: ```java public class Unicorn extends Unit { public void wait(){ } } ``` ```java public class Buttterfly extends Unit { public void wait(){ } } ``` ```java public class Wall extends Unit { public void wait(){ } } ``` Possible solution ```java public abstract class MobileUnit extends Unit { public abstract void wait(){ } } ``` ```java public class Unicorn extends MobileUnit { @Override public void wait(){ super.wait(); } } ``` ```java public class Buttterfly extends Unit { @Override public void wait(){ super.wait(); } } ``` ```java public class Wall extends Unit { public void wait(){ } } ``` "},{"id":6,"href":"/docs/recursion/sections/linear/","title":"Linear recursion","section":"Recursion","content":" Linear recursion # **_Definition._** A recursive method is **linear recursive** if it performs at most _one_ recursive call each time it is executed. **_Terminology._** The term **unary recursion** is sometimes used to refer to linear recursive algorithms (as opposed to [n-ary recursion](http://localhost:41071/docs/recursion/sections/nary/)). **_Hint._** A linear recursive algorithm is often easy to transform into an iterative one (i.e. an algorithm that uses only loops). Example # Exercise Write in pseudocode a (linear) recursive algorithm for a method `int occ(char[] A, char c)` that: - takes as input a (non-null) array `A` of characters and a character `c`, and - returns the number of occurrences of `c` in `A`. Possible solution ```java int occ(char[] A, char c) { return occRec(A, c, 0) } int occRec(char[] A, char c, int i) { // Base case: the segment under consideration is empty if(i == A.length){ return 0 } // Inductive case. // Count the number of occurrences of c in the \"suffix\" segment A[i+1 .. A.length-1] int occInSuffix = occRec(A, c, i + 1) return A[i] == c ? // If the current character is c, then return this value + 1, occInSuffix + 1 : // otherwise return this value as it is. occInSuffix } ``` Tail recursion # Motivation # Consider a (not necessarily recursive) method method1 that calls a method method2, for instance:\nmethod1() { ... method2() ... } The execution of method1 is interrupted when it calls method2.\nDuring this interruption, the call stack contains:\nmethod2 method1 \u0026lt;bottom of the stack\u0026gt; Variables that are local to the execution of a method are allocated on the so-called [stack](https://en.wikipedia.org/wiki/Stack-based_memory_allocation) memory. In this example, variables that are local to method1 remain in memory during the execution of method2 (because they may be needed when the execution of method1 resumes). However, if no instruction in method1 needs to be executed after the call to method2, then there is no need to maintain this information in memory.\nmethod1() { ... method2() } In other words, the call stack in this case could be safely be reduced to:\nmethod2 \u0026lt;bottom of the stack\u0026gt; This optimization technique is known as tail-call elimination. Some compilers apply it (but most Java compilers do not).\nDuring the execution of a recursive algorithm, the size of the call stack may become important, therefore also the amount of stack memory required. Therefore identifying calls that may be safely be removed from the stack can significantly reduce memory consumption.\nDefinition # A linear recursive method is **tail recursive** if no instruction in this method can be executed _after_ a recursive call. A tail recursive algorithm can easily be transformed into an iterative one. This transformation can be viewed as a \u0026ldquo;manual\u0026rdquo; form of tail-call elimination.\nExercise The algorithm above for the method `int occ(char[] A, char c)` is linear recursive, but not tail-recursive. Rewrite it into a tail-recursive algorithm. Then convert it into an iterative algorithm. Possible solution Tail recursive algorithm: ```java int occ(char[] A, char c) { return occRec(A, c, 0, 0) } int occRec(char[] A, char c, int i, int occurences) { // Base case: the segment under consideration is empty if(i == A.length){ return 0; } // Inductive case. // If the current character is c, then increment the number of occurrences. if (A[i] == c) { occurrences++; } // Recursive call return occRec(A, c, i + 1, occurrences) } ``` Iterative algorithm: ```java int occ(char[] A, char c) { int occurrences = 0 for (int i = 0; i \u003c A.length; i++) { if (A[i] == c) { occurrences++ } } return occurrences } ``` A common strategy to convert a linear recursive method into a tail-recursive one consists in using additional arguments (like the argument occurrences in the above example). These extra arguments are sometimes called accumulators.\nUsage # Linear recursive implementations are not very frequent, because most of them can be easily converted into iterative ones, as illustrated above. Besides, as we explained above, the iterative solution is often more efficient (at least memory-wise) for large inputs.\nHowever, some problems can be easier to solve in a linear recursive form (e.g. as a first attempt). This may also produce code that is easier to read and/or debug.\nIn particular, it may be the case when manipulating linked lists.\nLinked list # **_Definition._** A **linked list** is a set of objects organized in a _sequence_, such that each object (except for the last one) points to its successor. Equivalently, a linked list is a unary tree (and conversely), i.e. a tree where each node has exactly one (possibly null) child.\nFor instance:\n**_Terminology._** - the first object in a linked list is often called the **head** of the list, and - the rest of the list (i.e. the sublist with the second object as head) is often called the **tail** of the list. Example # Exercise Consider linked lists that consist of instances of the following class: ![](/img/diagrams/plantuml/listNode_labeled.svg) Write (in pseudocode) a linear recursive algorithm `Node removeDuplicates(Node head)` that: - takes as input the head of a list with nodes sorted according to their label (in alphabetical order), - returns the head of a list with the same labels, in alphabetical order, but where each label appears exactly once. For instance, for the following input list: ![](/img/linkedLists/labeled/char/withDup/list.svg) the algorithm should output a list with labels: ![](/img/linkedLists/labeled/char/noDup/list.svg) Possible solution ```java Node removeDuplicates(Node head) { // Base case: empty list. if(head == null) { return null } // Inductive case. // Remove all duplicate in the tail. Node tailHead = removeDuplicates(head.next) // Compare the head with the (possibly new) head of the tail. if (tailHead != null \u0026\u0026 head.label == tailHead.label) { // If they have the same label, then return the tail. return tailHead } // Otherwise add the head to the returned list. head.next = tailHead return head } ``` "},{"id":7,"href":"/docs/abstractdatatypes/sections/list/","title":"List","section":"Abstract data types","content":" List # The abstract data type **list** simulates a [tuple](http://localhost:41071/docs/background/sections/set_tuple_map/#tuple). Accordingly, a list may contain duplicates.\nA list may expose the following methods:\nisEmpty is self-explanatory, append adds an element at the end of the list, prepend adds an element at the beginning of the list, tail returns the sub-list identical to the current one, but without its first element, etc. **_Note._** The _size_ of a list is often unbounded (as opposed to the size of an array for instance). This can be implemented in different ways, for instance with a [dynamic array](http://localhost:41071/docs/datastructures/sections/list/#array) or a [linked list](http://localhost:41071/docs/datastructures/sections/list/#linkedList). in Java # Java has an interface List with 8 native implementations (i.e. 8 different classes that implement this interface). The most commonly used are ArrayList and LinkedList.\nThe interface List extends the interface Collection.\nSyntax # Here are code snippets for a few operations specified in the interface List.\nCreate a List and populate it: City milan = new City(\u0026#34;milan\u0026#34;, 20100); City florence = new City(\u0026#34;Florence\u0026#34;, 50100); // Creates an empty list of cities List\u0026lt;City\u0026gt; myList = new ArrayList(); // Appends Milan to the list myList.add(milan); // Appends Florence to the list myList.add(florence); // Appends Milan again to the list myList.add(milan); // Creates a list identical to the previous one, but which cannot be modified List\u0026lt;City\u0026gt; myOtherList = List.of(milan, florence, milan); City[] myArray = new City[]{milan, florence,}; // Creates a fixed-lenght \u0026#34;wrapper\u0026#34; list around the array. // No data is duplicated. List\u0026lt;City\u0026gt; yetAnotherList = Arrays.asList(myArray); Retrieve the size of a list: // Outputs 3 System.out.println(myList.size()); Retrieve the element at index i (the first index being 0, like in an array): // Contains (a reference to) Florence City secondCity = myList.get(1); Insert an element at index i (shift the position of all subsequent elements by 1). City trento = new City(\u0026#34;Trento\u0026#34;, 38100); myList.add(1, trento); // Now contains (a reference to) Trento secondCity = myList.get(1); // contains (a reference to) Florence City thirdCity = myList.get(2); Remove the element a index i (shift the position of all subsequent elements by -1), and return it myList.remove(1); // Outputs 3 Sysetm.out.println(myList.size()); // Now contains (a reference to) Florence secondCity = myList.get(1); Remove the first occurrence of an object in the list (shift the position of all subsequent elements by -1): myList.remove(milan); // contains (a reference to) Florence City firstCity = myList.get(0); For more operations, consult the Javadoc of the interface List.\n"},{"id":8,"href":"/docs/objects/sections/objects/","title":"Objects","section":"Objects and classes","content":" Objects # An object groups data in a meaningful way.\nA simple example: JSON objects # Here is a JSON object (in Javascript syntax) that describes the city of Florence:\n{ name: \u0026#34;Florence\u0026#34;, zipcode: 50100 } A JSON object may contain other objects, as well as arrays (of values, objects or arrays). For instance:\n{ name: \u0026#34;Alice\u0026#34;, age: 26, birthPlace: { name: \u0026#34;Florence\u0026#34;, zipcode: 50100 }, jobs: [ { employer: \u0026#34;Kolping\u0026#34;, start: 2021, end: 2022 }, { employer : \u0026#34;Eurac\u0026#34;, start: 2023 } ] } In JSON:\nan element can be either: a scalar (e.g. an integer), or an array of elements, or an object, an object is a finite set of key-value pairs, where keys are distinct, and each value is an element. Besides, a JSON element must have finite depth.\nEquivalently, a JSON object can be viewed as a function (with finite domain) that maps keys to JSON elements.\nObjects and programming languages # JSON objects do not exactly correspond to the objects that can be created in Java (and many other programming languages). We highlight here two important differences.\nTypes # Exercise Find a JSON object that satisfies the above description but cannot be represented as an object in a (strongly) typed language such as Java, C/C++, C#, etc.\nPossible solution { key: [1, \u0026#34;a\u0026#34;]; } In a typed language (like Java), the elements of an array must be of the same type.\nThis is not required in Javascript, Python, etc.\nReferences # A Java (or Python, C#, etc.) object does not contain objects or arrays, but references to objects or arrays. For instance, the equivalent in Java of the above object may be pictured as follows (abusing notation):\n_1: { name: _2, age: 26, birthPlace: _3, jobs: _4, } _2: [\u0026#39;A\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;e\u0026#39;] _3: { name: _5, zipcode: 50100 } _4: [ _6, _7 ] _5: [\u0026#39;F\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;e\u0026#39;] _6: { employer: _8, start: 2021, end: 2022 } _7: { employer: _9, start: 2023 } _8: [\u0026#39;K\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;g\u0026#39;] _9: [\u0026#39;E\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;] Each object or array has an ID (e.g. _1 in this example), which can be used to refer to it (you can think of this ID as an address in memory).\nAs a consequence, some objects can be created in Java that have no (finite) representation in JSON.\nExercise Find one of these objects.\nPossible solution _1: { name: _2, friends: _3 } _2: [\u0026#39;A\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;e\u0026#39;] _3: [ _4, _7 ] _4: { name: _5, friends: _6 } _5: [\u0026#39;B\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;b\u0026#39;] _6: [ _1, _8 ] If we try to represent this object in JSON, we get (assuming that we start with Alice):\n{ name: \u0026#34;Alice\u0026#34;, friends: [ { name: \u0026#34;Bob\u0026#34;, friends: [ { name: \u0026#34;Alice\u0026#34;, friends: [ ... ]}]}]} Cyclic references (like in this exercise) naturally occur in object-oriented code. Identifying them may be essential to debug a program that does not terminate or runs out of memory (stack overflow, \u0026hellip;).\n"},{"id":9,"href":"/docs/project/sections/free_project/","title":"Option 1: free project","section":"Project","content":" Option 1: free project # The first possible type of group projects is for students to develop a Java application of their choice.\nThis application is only a prototype, so it does not need a comprehensive list of features or functionalities.\nThe evaluation of the project will be mostly based on its backend (rather than the frontend). This means that the application:\ndoes not need a graphical user interface (but may have one), should perform non-trivial backend task(s) (e.g. writing and/or reading to/from files is not sufficient). Guidelines # Motivation # A good projects is driven by an idea.\nFeel free to design your application so that it matches your own interests. For instance:\nrelate it to a hobby (music, cinema, fashion, sport, games, social media, astronomy, etc.), use the project as an opportunity to explore a topic that you are curious about (natural language processing, computer vision, recommender systems, robotics, etc.), develop a functionality that one of your favorite applications is missing. Do not hesitate to be ambitious at first. You can restrict the scope of your project (to certain features or components) later on.\nSpecification # A frequent source of failure for this course is students focusing on tools (e.g. following tutorials) without having a precise objective. The short deadline (June 2024) does not give you this flexibility. Besides, without a precise objective, the amount of libraries that are available to you (especially in Java) can be overwhelming.\nSo we recommend you to clarify what your application should do, before thinking about how you could implement it. In other words, specify which problem(s) (i.e. input and expected output) your program and/or components should solve. Then only think about algorithms, libraries, tools and/or tutorials that can help you solve these problems.\nIn order to determine whether your specification is precise enough, you may check whether it leaves some doubt as to whether an output is correct or not.\nUser interface # Developing a Graphical User Interface (GUI) requires familiarity with a graphical framework. Learning the details of such a framework (terminology, syntax, setup, etc.) can be an important time investment, and this knowledge may not transfer to other graphical frameworks. In other words, developing a GUI may not require lot of thinking, but a lot of reading (and web browsing).\nBeware also that GUIs technologies are still rapidly evolving, and that recent innovation has largely been driven by web development. So learning a graphical framework for Java may not be a strategic investment of your time (compared to learning a Javascript framework like React or Angular). Note that even desktop and mobile applications are increasingly relying on web technologies for their GUIs (thanks to frameworks like Electron or React Native).\nThis is why we recommend you to think carefully before committing to a Java GUI, and to keep it minimal if you do. Note also that we will not evaluate your project based on aesthetic criteria.\nSo in order to design your interface, you may follow the following guidelines:\nAsk yourself whether your application really needs a GUI. A command-line interface (CLI) may be sufficient, because: your program takes files as input and produces files as output, or your program is (primarily) meant to be used by other programs (rather than human beings), or your program is meant to be used by other developers, or external programs with GUIs (such as IDEs) can easily call your application, or you leave the GUI for future work (again, your application is just a prototype), etc. If you really need a GUI, then: decouple frontend and backend (whenever possible), so that the backend could be used with another frontend, and conversely.\n**_Example._** Many applications accessible via GUI have a natural decoupling of frontend and backend. For instance, consider an application that allows booking hotel rooms. The backend takes as input some _data_ (e.g. number or guests, duration, etc.), and outputs data as well (available rooms, prices, etc.). These input and output are independent of the aspect or structure of the GUI (windows, menus, buttons, fields, etc.). **_Example._** Even for some games, frontend and backend can easily be decoupled. Consider for instance a program that plays chess against a human opponent. The backend: - keeps track of the current state of the board, - takes as input either a move from the white player, or a request to play as the black player, - outputs the next state of the board. These input and output do not depend on a specific GUI (they can for instance be encoded using [algebraic notation]()). So the backend can be implemented _without_ any reference to graphical elements or controller inputs (mouse clicks, etc.). develop the backend first (and write unit tests for it),\ndevelop the frontend afterwards (if you have time for it).\nIf you really need a GUI, then try to keep it minimal. In particular, restrict the input to what is essential for your application. The more freedom the user is given, the more likely he/she is to input a sequence of actions that your program cannot handle. Examples # Here are some examples of (past and imaginary) possible projects:\na program that detects texts generated by a large language model, a program that takes as input a dataset of Tweets and identifies communities and/or influencers based on the network formed by re-tweets, a program that retrieves news articles about an input topic (using web APIs), and analyses their polarity (via sentiment analysis) together with their provenance (news outlet, country, etc.), a (toy) recommender system, a program that generates (solvable) sudoku grids with different sizes and/or level of difficulty, a game to help people improve their typing speed, a web crawler that retrieves sport-related statistics from various websites and exposes them via a web API, a classroom reservation system for the Unibz that can computes a default schedule for a whole semester, satisfying a set of constraints (room capacity, etc.) and/or preferences (minimize days of presence per week of a same group, etc.), a flashcard app that incorporates answers produced by a chatbot, an (Obsidian-like) note management application, a program to organize and manage coding contests (similar to this one), a password manager (with encryption), for instance similar to pass, where password update and synchronization are performed via git, a program that analyzes the commit and/or branching history of a git repository (e.g. contributions of the different users, frequency of commits, percentage of preserved code, etc.). "},{"id":10,"href":"/docs/build/sections/packaging/","title":"Packaging a Java application","section":"Build automation","content":" Packaging a Java application # Java (like C# or Python) is a precompiled language, meaning that source code is compiled into a _machine-independent_ representation called **bytecode**. Bytecode can be distributed and executed on any machine.\nIn Java, by convention, a source file MyClass.java is compiled into a bytecode file MyClass.class.\nA **Java Virtual Machine** (JVM) is a program in charge of executing Java bytecode. A **packaged** Java program is usually a zip file that contains: - bytecode, - metadata, and possibly: - [dependencies](http://localhost:41071/docs/build/sections/dependencies/), - other resources (data, images, etc.). Jar file # A **jar** (for [Java ARchive](https://docs.oracle.com/en/java/javase/13/docs/specs/jar/jar.html)) file is a zip file with extension `.jar`. This is the most common packaging format for Java applications. A jar can be:\na thin jar (i.e. excluding dependencies) or a fat (a.k.a. Ã¼ber) jar (i.e. including dependencies), runnable or non-runnable. A jar contains a text file META-INF/MANIFEST.MF that provides metadata about the package, as a set of key: value pairs (one per line). Among others, it may contain:\nthe name, version and author(s) of the program, the entry point of the program (i.e. the class that contains the main method), paths to additional .class files that are part of the program, etc. Details can be found here.\n**_Note._** A jar for an application (including the `META-INF/MANIFEST.MF` file) is usually created via a build automation tool (like Maven or Gradle). But if you are curious, you can also build a (toy) jar via command line. A good illustration can be found [on the website of last year's course](https://programming-project-2022-23.github.io/maven/compiling/#creating-jar-files-from-the-command-line). **_Note._** Unit tests (and test-related resources) are usually _not_ included in the release of a program. Therefore in Java, these are generally absent from a jar. "},{"id":11,"href":"/docs/input/sections/files/","title":"Paths and files in Java","section":"I/O and serialization","content":" Paths and files in Java # Java\u0026rsquo;s initial package for input/output (I/O) is called java.io. A central class in this package is File.\nOver the years, programmers realized that this package had limitations: limited error handling, limited support for file metadata (owner, access rights, etc.), and some performance issues.\nWith Java 7 (2011), A new I/O package called NIO2 was released, with additional features (and in some cases a more concise syntax). A central interface (resp. utility class) in this package is Path (resp. Files).\nHowever, the package java.io is still part of the latest Java release (it has not been deprecated), in part for backward compatibility reasons.\nIn this chapter, we will focus whenever possible on NIO2\u0026rsquo;s classes and methods, rather than java.io. In particular, we will use the Path when possible rather than File.\nNote also that some external libraries (notably Apache commons.io and Guava) provide additional methods for I/O, sometimes with a more concise syntax.\n**_Warning._** Many native Java methods that involve path or file manipulation may throw a [checked exception](http://localhost:41071/docs/errors/sections/checked/#checked) (generally an `IOException`). For instance, among the methods below, this is the case of: - `Path.toRealPath`, - `Files.size`, - `Files.walk`, - etc. As a reminder, when such a method is used, checked exceptions must be either [caught](http://localhost:41071/docs/errors/sections/exceptions/#catch) or [explicitly rethrown](http://localhost:41071/docs/errors/sections/checked/#rethrow), otherwise the program will not compile. Paths # An instance of Path represents a path in the hierarchical file system.\nAn instance of Path can be created in multiple ways. For instance:\nPath myPath = Path.of(\u0026#34;path/to/file.txt\u0026#34;); Path samePath = Path.of(\u0026#34;path\u0026#34;, \u0026#34;to\u0026#34;, \u0026#34;file.txt\u0026#34;); // Extend a path Path folder = Path.of(\u0026#34;path/to\u0026#34;); // identical to myPath Path myPathAgain = folder.resolve(\u0026#34;file.txt\u0026#34;); Path names # **_Note._** If the string `path/to/file.txt` is used to create a Java `Path` (or a Java `File`), then the `/` symbol is interpreted (at runtime) as the path separator _of the operating system_ (OS) that executes the program. So you can safely use this syntax, _regardless of your OS_. Precisely: - if the program is executed on macOS, Linux, Android, etc., then this string will be interpreted as is, - if the program is executed on Windows, then this string will be interpreted as `path\\to\\file.txt`. **_Warning._** If the string `path\\to\\file.txt` is used to create a Java `Path`, then this string will be interpreted _as is_. So the program may run on Windows, but fail on other systems. **_Warning._** Paths are _case sensitive_ on Linux, Android, etc., but _case insensitive_ on Windows and macOS. For maximal compatibility, make sure that path names in your code respect the case of your file and directory names. **_Warning._** Do _not_ use [absolute paths](http://localhost:41071/docs/env/sections/files/#absolute) in your code (e.g. `/home/Alice/workspace/javaProject/myFile.txt`, or `C:\\Users\\Alice\\workspace\\javaProject\\myFile.txt`). Your program may run on your own computer, but will fail on others. Working directory # **_Warning._** When a Java program is executed, relative paths are understood as paths _from_ the current [working directory](http://localhost:41071/docs/env/sections/files/#wd) (WD). If you need to know the WD, you can use the following (among other possibilities):\nPaths.get(\u0026#34;\u0026#34;).toAbsolutePath(); This instruction returns an absolute Path to the WD.\nFor instance,\nSystem.out.println(Paths.get(\u0026#34;\u0026#34;).toAbsolutePath()); may output on Windows:\nC:\\Users\\Alice\\workspace\\javaProject or on macOS:\n/Users/Alice/workspace/javaProject or on Linux:\n/home/Alice/workspace/javaProject The Path interface # Here are examples of outputs for some methods of the Path interface (assuming that the WD is /home/Alice/workspace/javaProject):\nPath path = Path.of(\u0026#34;src/main/../main/resources/myFile.txt\u0026#34;); // Outputs \u0026#39;/home/Alice/workspace/javaProject/src/main/../main/resources/myFile.txt\u0026#39; System.out.println(path.toAbsolutePath()); // Outputs \u0026#39;/home/Alice/workspace/javaProject/src/main/resources/myFile.txt\u0026#39; System.out.println(path.toRealPath()); // Outputs \u0026#39;myFile.txt\u0026#39; System.out.println(path.getFileName()); // Outputs \u0026#39;false\u0026#39; System.out.println(path.isAbsolute()); **_Hint._** The method `String.endsWith` can be used to check whether a file has a certain extension. E.g. ```java // Outputs 'true' path.toString().endsWith(\".txt\"); ``` Existence and metadata # Static methods of the class Files can be used to check whether a file or directory exists, and retrieve metadata about it:\nPath path = Path.of(\u0026#34;src/main/resources/myFile.txt\u0026#34;); System.out.println(\u0026#34;Exists = \u0026#34; + Files.exists(path)); System.out.println(\u0026#34;Is directory = \u0026#34; + Files.isDirectory(path)); System.out.println(\u0026#34;Is file = \u0026#34; + Files.isRegularFile(path)); System.out.println(\u0026#34;Is hidden = \u0026#34; + Files.isHidden(path)); System.out.println(\u0026#34;Size = \u0026#34; + Files.size(path) + \u0026#34; bytes\u0026#34;); System.out.println(\u0026#34;Last modified = \u0026#34; + Files.getLastModifiedTime(path)); Navigation # Path path = Path.of(\u0026#34;src/main/resources/myFile.txt\u0026#34;); // Get the parent directory \u0026#39;src/main/resources\u0026#39; Path dir = path.getParent(); // Contains all files and folders in \u0026#39;src/main/resources\u0026#39; List\u0026lt;Path\u0026gt; children = Files.list(dir).toList(); // Contains all files and folders that have \u0026#39;src/main/resources\u0026#39; // as ancestor, including \u0026#39;src/main/resources\u0026#39; itself. List\u0026lt;Path\u0026gt; descendents = Files.walk(dir).toList(); Manipulation # // Create a directory Path folder = Path.of(\u0026#34;myFolder\u0026#34;); Files.createDirectory(folder); // Create nested directories Path subfolder = Path.of(\u0026#34;myFolder/sub1/sub2\u0026#34;); Files.createDirectories(subfolder); // Create a file Path file = Path.of(\u0026#34;myFolder/hello.txt\u0026#34;); Files.createFile(file); // Move/rename a file Path destination = Path.of(\u0026#34;myFolder/sub1/bye.txt\u0026#34;); Files.move(file, destination); // Copy a file Path copy = Path.of(\u0026#34;myFolder/sub1/sub2/bybye.txt\u0026#34;); Files.copy(renamedFile, copy); // Delete a file. Files.delete(copy); // Delete a directory. // The directory must be empty. Files.delete(subfolder); "},{"id":12,"href":"/docs/regex/sections/pattern/","title":"Pattern matching","section":"Regular expressions","content":" Pattern matching # Two of the main uses of regexes are:\nstring validation, i.e. check whether a string satisfies certain constraints. For instance: has at least one digit and one special character, is a valid address, etc. string search, i.e. identify occurrences of a pattern in a line or in a file. This can be useful for: replacing strings in a file or a folder (e.g. within a codebase), splitting a sentence into (natural language) words, splitting a program into meaningful substrings, e.g. split the instruction int a=5; into int, a, =, 5 and ;, filtering (e.g. with the grep command) of modifying (e.g. with the sed command) lines in a file, etc. In both scenarios, a regex is viewed as a pattern that should be matched against a string.\nSegment # To make the notion of pattern matching more precise, we will represent a word $w$ as an array of characters, and a segment of $w$ as a (possibly empty) subarray of this array.\n**_Notation._** If $w$ is a word, we use $w[i .. j)$ for the subsegment of $w$ that starts at index $i$ _included_, and ends at index $j$ _excluded_. **_Example._** Let $w$ = `abca`. Then: - $w[0 .. 1)$ is a segment of $w$ with length 1 and word `a`, - $w[3 .. 4)$ is another segment of $w$ with length 1 and word `a` - $w[0 .. 3)$ is a segment of $w$ with length 3 and word `abc` - $w[0 .. 0)$ is a segment of $w$ with length 0 and word $\\varepsilon$ - $w[1 .. 1)$ is another segment of $w$ with length 0 and word $\\varepsilon$ Match # We can now define what a match is:\n**_Definition._** Let $w$ be a word (viewed as an array), and let $e$ be a regex that describes the language $L$. A **match** for $e$ in $w$ is a (possibly empty) segment of $w$ whose word belongs to $L$. **_Example._** Let $e$ be the regex `ab*`, and let $w$ be the word `aba`. There are 3 matches for $e$ in $w$: - $w[0 .. 1)$ with word `a`, - $w[0 .. 2)$ with word `ab`, - $w[2 .. 3)$ with word `a` **_Warning._** Several matches may carry the same word (e.g. the first and third matches in the example above). **_Warning._** Some matches may overlap (e.g. the first and second matches in the example above). Exercise Consider the regex $e$ = `a*` and the word $w$ = `aa`. How many matches are there for $e$ in $w$? Solution There are 6 matches for the regex `a*` in the word `aa`: - $w[0 .. 0)$: $\\varepsilon$ - $w[0 .. 1)$: `a` - $w[0 .. 2)$: `aa` - $w[1 .. 1)$: $\\varepsilon$ - $w[1 .. 2)$: `a` - $w[2 .. 2)$: $\\varepsilon$ Best first match # In practice, (most) regex engines do not identify all matches for a regex in a word. Instead, they rely on the notion of best first match (explained below). Reasons include:\nperformance, avoiding overlapping matches (e.g. when performing a global \u0026ldquo;search and replace\u0026rdquo;). Let $e$ be a regex, let $w$ be a word, and let $m_1$ and $m_2$ be two matches for $e$ in $w$. $m_1$ is **preferred** to $m_2$ if: - $m_1$ starts before $m_2$: for instance $w[1 .. 4)$ is preferred to $w[3 .. 8)$, or - they start at the same index and the regex engine favors $m_1$ over $m_2$. Preference is a total order over the matches for for $e$ in $w$, meaning that if there is a match, then there can be at most one best first match.\n**_Note._** When $m_1$ and $m_2$ start at the same index (second case above), whether $m_1$ is favored over $m_2$ can vary in subtle ways from one regex engine to the other. These preferences are usually explained in algorithmic terms (and half-informally). For a reasonably detailed tutorial about the behavior(s) of regex search engine, we refer to [this website](https://www.regular-expressions.info/tutorial.html). For Java, the [Oracle tutorial](https://docs.oracle.com/javase/tutorial/essential/regex/index.html) on regexes can also be a good entry point (although less precise that the previous reference). In this section, we only introduce basic behaviors of regex engines. Left-to-right # Commutative operations are evaluated from left-to-right.\n**_Example._** Consider the word $w$ = `ab`. - the best first match for the regex `ab|a` in $w$ is $w[0 .. 2) (with word `ab`) - the best first match for the regex `a|ab` in $w$ is $w[0 .. 1) (with word `a`) **_Exception._** In this example, A [POSIX-compliant](http://localhost:41071/docs/regex/sections/practice/#flavours) regex engine would produce $w[0 .. 2) (with word `ab`) as best first match for both expressions. **_Warning._** As illustrated with the above example, two regexes that describe the same language may have different best first matches (in the same word). Greedyness # The * operator is evaluated (by default) in a greedy way. This means that the engine tries to matches as many characters as possible for this operator. More precisely, when encountering a subexpression of the form $e$*:\nthe engine first considers the longest possible match for $e$*, if this match does not result in a match for the whole expression, then the engine backtracks by one character (i.e. reduces the length of the match for $e$* by one), and tries again to find a match for the whole expression, if this fails again, then the engine backtracks again by one character, etc. **_Examples._** - The best first match for the regex `a*` in `aa` is the whole word. - The best first match for the regex `a*` in `aab` is $[0 ..2)$ (with word `aa`). - The best first match for the regex `a*` in `aabaa` is $[0 ..2)$ (with word `aa`). - The best first match for the regex `(a|b)*b` in `abab` is the whole word. In this case, - the engine first tries to match `(a|b)*` against the whole word, - this does not result in a match for the whole regex, because the trailing `b` in the regex is not matched, - so the engine backtracks, and matches `(a|b)*` against $[0 .. 3)$ (with word `aba`), - this results in a match for the whole expression. **_Warning._** The interaction of left-to-right evaluation and greedy matching can be hard to predict. This is why we highly recommend writing and debugging regexes with a validation engine, such as [regex101](https://regex101.com). **_Warning._** Nested `*` operators can be costly, due to a combinatorial explosion of the number of attempts to find a match. This is sometimes referred to as [catastrophic backtracking](https://www.regular-expressions.info/catastrophic.html). Successive best first matches # Most regex engines can return best first matches in an iterative way. Intuitively, the engine \u0026ldquo;consumes\u0026rdquo; the best first match. Then the next match is the best first match in the remaining string, etc.\nMore precisely: **_Definition._** Let $e$ be regex and let $w$ be a word with lenght $n$. Then: - the **first match** $w[i_1 .. j_1)$ for $e$ in $w$ is the best first match (if any) for $e$ in $w$, - the **second match** $w[i_2 .. j_2)$ for $e$ in $w$ is the best first match (if any) for $e$ in $w[j_1 .. n)$, - the **third match** $w[i_3 .. j_3)$ for $e$ in $w$ is the best first match (if any) for $e$ in $w[j_2 .. n)$, - etc. **_Example._** Let $e$ be the regex `ab*`, and let $w$ be the word `abac`. - The best first match for $e$ in $w$ is $w[0 ..2)$, with word `ab`. - The second match is the best first match in the rest of $w$, i.e. in $w[2 .. 4)$. This match is $w[2 .. 3)$, with word `a`. - There is no third match. Exercise In each of the cases below, find all successive best first matches for the regex $e$ in word $w$: | regex $e$ | word $w$ | | --------- | -------- | | `a` | `aba` | | `a*b` | `aba` | | `a*` | `a` | | `a*` | `aba` | | `(ab)*` | `aba` | | `(ab)*` | `abab` | Solution | regex $e$ | word $w$ | matches | | --------- | -------- | ------------------------------------------------------------------------------------ | | `a` | `aba` | $[0 .. 1)$:`a`, $[2 .. 3)$:`a` | | `a*b` | `aba` | $[0 .. 2)$:`ab` | | `a*` | `a` | $[0 .. 1)$:`a`, $[1 .. 1)$: $\\varepsilon$ | | `a*` | `aba` | $[0 .. 1)$:`a`, $[1 .. 1)$: $\\varepsilon$, $[2 .. 3)$:`a`, $[3 .. 3)$: $\\varepsilon$ | | `(ab)*` | `aba` | $[0 .. 1)$:`ab`, $[2 .. 2)$: $\\varepsilon$, $[3 .. 3)$: $\\varepsilon$ | | `(ab)*` | `abab` | $[0 .. 3)$:`abab`, $[3 .. 3)$: $\\varepsilon$ | Lazy closure # Some regex engines (notably the ones used by default in Java, Javascript, Python, etc.) support alternative ways to evaluate * operators.\nOne of them is lazy evaluation (also called reluctant). In this case, the star operator matches the shortest possible segment.\n**_Examples._** | regex $e$ | word $w$ | best first match with lazy evaluation of star operators | | --------- | -------- | ------------------------------------------------------- | | `a*` | `aa` | $[0 .. 0)$:$\\varepsilon$ | | `a*ac` | `ac` | $[0 .. 2)$:`ac` | | `a*ac` | `aac` | $[0 .. 3)$:`aac` | **_Note._** In a same regular expression, it is possible to specify that some `*` operators must be evaluated in a lazy way, and others in a greedy way. Exercise In each of the cases below, find all successive best first matches for the regex $e$ in word $w$, where `*` operators are evaluated in a lazy way. | regex $e$ | word $w$ | | --------- | -------- | | `ab*` | `ab` | | `a*b` | `aba` | | `a*ab*` | `ab` | | `a*` | `a` | | `a*` | `aa` | | `b*` | `aa` | Solution | regex $e$ | word $w$ | lazy matches | | --------- | -------- | ---------------------------------------------------------------------------- | | `ab*` | `ab` | $[0 .. 1)$:`a` | | `a*b` | `aba` | $[0 .. 2)$:`ab` | | `a*ab*` | `ab` | $[0 .. 1)$:`a` | | `a*` | `a` | $[0 .. 0)$:$\\varepsilon$, $[1 .. 1)$:$\\varepsilon$ | | `a*` | `aa` | $[0 .. 0)$:$\\varepsilon$, $[1 .. 1)$:$\\varepsilon$, $[2 .. 2)$:$\\varepsilon$ | | `b*` | `aa` | $[0 .. 0)$:$\\varepsilon$, $[1 .. 1)$:$\\varepsilon$, $[2 .. 2)$:$\\varepsilon$ | **_Warning._** Lazy `*` operators can be hard to predict. "},{"id":13,"href":"/docs/stream/sections/pipeline/","title":"Pipeline","section":"Streams in Java","content":" Pipeline # Stream computations are specified as a **pipeline**, which consists of: 1. a **source** (e.g. a collection or an I/O channel), 2. a sequence of zero or more **intermediate operations**, each of which transforms a stream into another stream (e.g. filtering or modifying the stream's elements), 3. _one_ **terminal operation** (e.g. collecting the elements of the transformed stream). Intermediate operations are generally specified via callback methods (the terminal operation may as well). More precisely, the Java interface Stream provides instance methods (like filter or map) that take a callback method as argument, and transform the stream accordingly.\nExample # Consider the following classes Unit, Butterfly, Caterpillar and Unicorn.\nThe pipeline below:\ncreates a stream out of a list of units, retains only butterflies, extracts the color of each butterfly, collects these colors as a set. List\u0026lt;Unit\u0026gt; units = getUnits(); Set\u0026lt;String\u0026gt; butterflyColors = units.stream() // create a stream .filter(u -\u0026gt; u instanceof Butterfly) // retain butterflies .map(b -\u0026gt; b.color) // map each butterfly to its color .collect(Collectors.toSet()); // collect the colors as a set Explanation # This pipeline can be decomposed as follows:\nSource # The instance method Collection.stream generates a stream out of a collection (e.g. out of a List or a Set):\nunits.stream() In this example, because units has type List\u0026lt;Unit\u0026gt;, the stream that is returned by units.stream() has type Stream\u0026lt;Unit\u0026gt;.\nIntermediate operations # Filter # .filter(u -\u0026gt; u instanceof Butterfly) The instance method Stream.filter retains certain elements of the stream.\nLet us assume that the stream has type Stream\u0026lt;$\\mathit{T}$\u0026gt; (for instance, in our example, $\\mathit{T}$ is Unit).\nThe method filter takes as argument a callback function of type\n$\\qquad \\mathit{T} \\to$ Boolean\n(equivalently, in Java\u0026rsquo;s terminology, the callback function must implement the native functional interface Predicate\u0026lt;$\\mathit{T}$\u0026gt;).\nIn this example, the callback function is\nu -\u0026gt; u instanceof Butterfly which has type\n$\\qquad$ Unit $\\to$ Boolean\nThe method filter returns a Stream\u0026lt;$\\mathit{T}$\u0026gt; (e.g. in this example a Stream\u0026lt;Unit\u0026gt;) that consists of the elements for which the callback method evaluates to true (in this case, it retains only butterflies).\nMap # .map(b -\u0026gt; b.color) The instance method Stream.map applies a function to each element of the stream.\nLet us assume that the stream has type Stream\u0026lt;$\\mathit{T}$\u0026gt; (for instance, in our example, $\\mathit{T}$ is Unit).\nThe method map takes as argument a callback function of type\n$\\qquad T \\to T'$\nwhere $T\u0026rsquo;$ can be any type (equivalently, in Java\u0026rsquo;s terminology, the callback function must implement the native functional interface Function\u0026lt;$T$,$T\u0026rsquo;$\u0026gt;, seen earlier).\nIn this example, the callback function is\nb -\u0026gt; b.color which has type\n$\\qquad$ Unit $\\to$ String\nLet us name this callback function $f$.\nThe method map returns a Stream\u0026lt;$\\mathit{T\u0026rsquo;}$\u0026gt; (e.g. in this example a Stream\u0026lt;String\u0026gt;) that consists of all objects $f(a)$ such that $a$ belongs to the original stream.\nTerminal operation # .collect(Collectors.toSet()); The instance method Stream.collect takes as argument a so-called Collector, which is in charge of collecting the elements of the stream into a Collection (e.g. List or Set), or a Map, or a string, etc.\nIn this example, we call the static method Collectors.toSet, which returns a collector that produces a set. Because the stream has type Stream\u0026lt;String\u0026gt;, the instruction .collect(Collectors.toSet()) returns a set with type Set\u0026lt;String\u0026gt;.\nReading a pipeline # Exercise What do the following methods compute? ```java Set method1(Set set1, Set set2) { return set1.stream() .filter(u -\u003e set2.contains(u)) .collect(Collectors.toSet()); } Set method2(Set set1, Set set2) { return set1.stream() .filter(set2::contains) .collect(Collectors.toSet()); } ``` Solution Both methods compute the intersection of `set1` and `set2`. Exercise What do the methods `method1` to `method4` below compute? ```java Stream method1(List units) { return units.stream() .filter(u -\u003e u.health \u003e 0); } List method2(Stream stream) { return stream.map(u -\u003e transform(u)) .toList(); // collects the stream into a list } Unit transform(Unit u) { if (u instanceof Caterpillar) { return new Butterfly(u.color, u.health); } return u; } List method3(List units) { return method2(method1(units)); } List method4(List units) { return units.stream() .filter(u -\u003e u.health \u003e 0) .map(u -\u003e u instanceof Caterpillar ? new Butterfly(u.color, u.health) : u ) .toList(); } ``` Solution - `method1`: - **Input:** A list of units. - **Output:** a stream that contains the same units, but discarding units with no health. - `method2`: - **Input:** A stream of units. - **Output:** A list that contains the same units, but where caterpillars become butterflies. - `method3`: - **Input:** A list of units. - **Output:** A list that contains the same units, but discarding units with no health, and transforming caterpillars into butterflies. - `method4` is equivalent to `method3`. "},{"id":14,"href":"/docs/lambda/sections/pure/","title":"Pure function","section":"Callback methods and lambda expressions","content":" Pure function # Side effects # **_Definition._** A method has **side effects** if it modifies resources (variable, object, array, etc.) that are accessible outside of its scope. Definition # A pure function is a method that intuitively behaves like a mathematical function. More precisely:\n**_Definition._** A **pure function** is a method that: 1. returns a value, 2. returns the _same_ value if called twice with the same arguments, and 3. has no side-effect. Example # Exercise The Java method `createUsers` below violates each of the three properties that define a pure function. Can you see why? How would you rewrite it into a pure function? ```java int[] ids = parseIds(); String[] names = parseNames(); User[] users = new User[ids.length]; createUsers(ids, names, users); void createUsers(int[] ids, String[] names, User[] users) { for(int i = 0; i \u003c ids.length; i++){ users[i] = new User(ids[i], names[i]); } } ``` Possible solution ```java int[] ids = parseIds(); String[] names = parseNames(); User[] users = createUsers(ids, names); User[] createUsers(int[] ids, String[] names) { User[] users = new User[ids.length]; for(int i = 0; i \u003c ids.length; i++){ users[i] = new User(ids[i], names[i]); } return users; } ``` Benefits # Easier debugging # Because it has no side effect, a pure function may cause of a bug only if it returns an incorrect value. Because it only depend on its arguments, the behavior of a pure function is easier to predict. Readability # The behavior of a pure function can be fully documented by describing its signature (arguments and return value).\nEasier parallelization # Consider two pure functions $f$ and $g$. If the input of $f$ (resp. $g$) does not depend on the output of $g$ (resp. $f$), then they can be executed in any order (therefore also in parallel).\n**_Example._** If $f$ and $g$ are pure functions, the two programs below (written in pseudocode) are equivalent: ```perl x = f(a) y = g(b) result = x + y ``` ```perl y = g(b) x = f(a) result = x + y ``` "},{"id":15,"href":"/docs/intro/sections/schedule/","title":"Schedule","section":"This course","content":" Schedule # The course consists of 60 hours of lectures and 30 hours of labs.\nLectures # By default, lectures are scheduled:\nTuesday 10:00 - 12:00 Wednesday 08:00 - 10:00 Thursday 10:00 - 12:00 All students attend the same lectures.\nOne lecture (to be determined) will be dedicated to a visit to Raiffeisen Information Service in Bolzano.\nLabs # By default, labs are scheduled:\nTuesday 16:00 - 18:00 Friday 14:00 - 16:00 Students are split in two groups (to be determined) for the labs, with identical content. Students who collaborate on the same group project are expected to attend the same lab.\nMost labs will be dedicated to the assignments for this course. Two labs will be dedicated to a presentation and discussion of the advancement of the different group projects.\nTimetable # Some weeks will see fewer lectures/labs, and schedules or room numbers may vary from one week to the other. So make sure to check the timetable regularly.\n"},{"id":16,"href":"/docs/interfaces/sections/specification/","title":"Specification and programming interface","section":"Interfaces","content":" Specification and programming interface # Specification # The **specification** of a _method_ usually consists of: - the [computational problem](http://localhost:41071/docs/background/sections/problem/) that the method solves (if any), and - (if needed,) a description of the _format_ of the input and expected output, and - (if applicable,) a description of the behavior of the program for _invalid_ inputs (e.g. errors thrown by the method), and - (_if useful_,) information about the implementation (e.g. if this may have an impact on performance for certain inputs). **_Example._** ``` boolean isSolvable(int[][] grid) ``` - **_Input:_** a 9 x 9 array of integers with numbers between 0 and 9 - **_Output:_** true is this array represents a sudoku grid with a unique solution (where 0 stands for the absence of value) - **_Errors:_** - if the array's size is not 9 x 9 - if the array contains a number smaller that 0 or greater than 9 If a method has no return type or is not a pure function, then the specification may indicate the effect the method on its environment.\nThe specification of a command (for a program with a command line interface) is similar, but may include additional information about the syntax of the command (options, arguments, etc.)\nProgramming interface # In its simplest form, a **programming interface** is a set of method/command specifications. "},{"id":17,"href":"/docs/intro/","title":"This course","section":"Docs","content":" Structure and organization of the course # This chapter explains how the course is structured and briefly summarizes its content.\n"},{"id":18,"href":"/docs/generics/sections/type_checking/","title":"Type checking","section":"Generic programming","content":" Type checking # Statically vs dynamically typed languages # A compiled programming language is said to be **statically typed** if (most) type checks are performed during the compilation of a program, rather than during its execution. Such languages include , C/C++, C#, Go, Java, Kotlin, Typescript, Rust, etc., as well as functional (or functional-like) languages like Haskell or Scala.\n**_Example._** The following Java program does not _compile_. ```java String banana = \"banana\"; banana += 1; ``` Languages that are not statically typed are called **dynamically typed**. This include interpreted (or just-in-time compiled) languages like Javascript, Lua, PHP or Ruby, but also Python (which is precompiled, like Java).\nDynamically typed languages have limited (if any) syntactic support for types (like int or Set\u0026lt;String\u0026gt; in Java), whereas statically-typed languages (especially functional languages) can have complex typing systems.\nStatic and dynamic typing have their respective benefits and drawbacks (each being more adapted to certain use cases). Here are some of some common arguments:\nRobustness: static typing allows some errors to be identified earlier during the development process. In a dynamic context, type-related bugs can only be identified via testing (possibly after release).\nDocumentation: the signature of a method (i.e. its input and return types) can be a useful indication of how it is meant to be used.\nProductivity: dynamically typed languages allow focusing on algorithmic aspects, without the need to write or reason about types. As a result, programs may be written significantly faster. Conversely, the absence of compile-time type checks may increase debugging time.\nConciseness: an algorithm can be significantly easier to understand without the overhead introduced by a (possibly complex) typing system.\nType safety and generic programming # **Type safety** is the extent to which a typing system prevents or discourages type errors. This is usually understood as a property of statically typed languages. Type safety often conflicts with reusing and factorizing code, in particular for algorithms that manipulate data structures. This is one of the main practical motivations behind generic programming, which allows maintaining type safety (to some extent) while abstracting from specific data types.\nFor instance, with generic programming, a sorting algorithm (like Mergesort) can be implemented only once for different types of arrays (Integer[], City[], Unit[], etc.) and sorting criteria, while preventing some typing errors.\n"},{"id":19,"href":"/docs/lambda/sections/anonymous/","title":"Anonymous method","section":"Callback methods and lambda expressions","content":" Anonymous method # An **anonymous** method is a method without a name. Illustration # The two following Java methods only differ by their name:\n```java int square(int x){ return x * x; } ``` ```java int toThePowerOfTwo(int x){ return x * x; } ``` So in a sense, these two methods are the same method.\nAn anonymous method simply abstracts away from the name of the method. For instance, in Java, the two methods above could be described with the following lambda expression:\n(int x) -\u0026gt; { return x * x; } Or (with a more concise syntax):\nx -\u0026gt; x * x "},{"id":20,"href":"/docs/git/sections/collaboration/","title":"Basics: network and collaboration","section":"git","content":" Basics: network and collaboration # Network # In the previous section, Alice created and manipulated a git repository (with two branches).\nShe may also want to backup her work. To this end, she can upload some of her branches to a remote machine (often called \u0026ldquo;a remote\u0026rdquo;). For instance use a cloud hosting service for git repositories (such as GitHub, Gitlab, Bitbucket, etc.).\nWhenever Alice wants to upload the content of a branch, she can push this branch to the remote.\nAlice may also want to work from another computer (or a virtual machine). She can achieve this by cloning the repository from the remote to this second machine.\n**_Warning._** By default, cloning a repository will only clone the main branch. But other branches (or all branches) can also be cloned explicitly. **_Note._** When two machines share a git branch, each of them has a copy of the _full history_ of the branch. **_Note._** A branch can be shared with _several remote servers_ (e.g. one for releases and one for development or continuous integration). For these two reasons, git is sometimes called a \u0026ldquo;distributed\u0026rdquo; versioning system.\nCollaboration # Enters Bob\u0026hellip;\nBob may want to collaborate with Alice on her project. He can clone Alice\u0026rsquo;s repository, and add his own commits.\nIn order to synchronize their work, Alice and Bob may agree to share the content of one or several branches (for instance the main branch).\n**_Warning._** For a smooth collaboration, code on a shared branch is expected to: - compile and - pass all [unit tests]() defined for the project. A basic workflow # Alice and Bob share the main branch of their repository, and this branch is called main. This generally means that there are (at least) 3 copies of this branch: one on Alice\u0026rsquo;s machine, one on Bob\u0026rsquo;s machine, and one on the remote.\nHowever Alice and Bob, do not work directly on this branch. Instead, each of them works on his/her own development branch (e.g. called alice and bob respectively).\nBackup # Alice regularly pushes the content of the branch alice to the remote, for backup purposes only. And so does Bob for the branch bob.\nHowever, Alice does not need a local copy of bob, and Bob does not need a local copy of alice.\nSharing # Bob has been working on a new feature, on the branch bob. His code compiles and passes all unit tests. He now feels ready to share this code with Alice (via the branch main).\nHowever, Alice may have added commits to the main branch since Bob last looked at it.\nIn order to share his work, Bob: 1. switches to (his local copy of) `main` (with the `git checkout` command), then 1. _updates_ his local copy of `main` (with the `git pull` command), then 1. merges `main` into `bob` (this may require fixing merge conflicts), then 1. merges `bob` into `main`, then 1. pushes `main` to the remote. And Alice follows the same procedure to share her code (using alice instead of bob).\nTo go further # There is a vast literature (and diverging opinions) on collaborative git workflows. This is beyond the scope of this course.\nNote that many of these workflows incorporate so-called \u0026ldquo;pull requests\u0026rdquo;, which are a mechanism for to notify team members of your team that you have completed a feature. Pull requests are not a functionality of git itself, but of (some) git hosting services. To learn more about pull requests, you may consult the corresponding GitHub or Atlassian guides.\n"},{"id":21,"href":"/docs/simplify/sections/break/","title":"Break statements and flags","section":"Simplifying code","content":" Break statements and flags # A method with multiple boolean flags can be complex to read and/or debug, in particular when combined with break and/or continue statements.\nThis can usually be avoided:\nusing return statements (possibly with auxiliary functions), and/or (in Java) using streams with anyMatch, allMatch or findFirst. Example # Exercise Rewrite the following Java method: - without boolean flag and - without `break` statement. ```java /** * Returns true iff each of the input lists contains a number \u003e 20 */ boolean check(List"},{"id":22,"href":"/docs/objects/sections/classes/","title":"Class and instance","section":"Objects and classes","content":" Class and instance # A class can be viewed as a blueprint for a set of similar objects.\n{ name: \u0026#34;Florence\u0026#34;, zipCode: 50100, region: \u0026#34;Tuscany\u0026#34; } For instance, consider the two objects: ```javascript { name: \"Florence\", zipCode: 50100, region: \"Tuscany\" } ```` ```javascript { name: \"Rome\", zipCode: 00100, region: \"Lazio\" } ``` Each of these objects describes a city, and they share the same keys (`name`, `zipCode` and `region`). A possible class for these two objects may enforce this structure, and it could be named `City`. An object that follows this blueprint is called an **instance** of this class. ## Declaration In a typed language (like Java), a class must specifies not only the \u0026#34;keys\u0026#34; of its instances, but also their types. For instance, the class City could be declared as follows in Java: ```java public class City { String name; int zipCode; String region; ... } ``` In Java, a class is often declared in a dedicated file. This file must have the _same name_ as the class (e.g. `City.java` in this example). The three variables (`name`, `zipCode` and `region`) are called **attributes** (or sometimes **member variables**). ## Constructor {#constructor} A class also needs a special method called a **constructor**.\u0026lt;br\u0026gt; The constructor is in charge of creating a (fresh) instance of the class.\u0026lt;br\u0026gt; In Java (as in Python, C#, etc.), the constructor does not return the instance itself, but a [reference](http://localhost:41071/docs/objects/sections/objects/#objectRef) (sometimes called \u0026#34;pointer\u0026#34;) to this instance. **_Note._** A class may have several constructors (with different signatures). ### Writing a constructor in Java The constructor of a Java class must have the _same name_ as the class. For instance: ```java public class City { String name; int zipCode; String region; public City(String n, int z, String r){ name = n; zipCode = z; region = r; } ... } ``` **_Note._** In this example, the variable names `n`, `z` and `r` are not very explicit. However, using `name`, `zipCode` and `region` would be ambiguous (because these names are already used for the attributes of the class). In Java, we can use the prefix `this.` to refer to attribute names, thus eliminating the ambiguity. For instance: ```java public class City { String name; int zipCode; String region; public City(String name, int zipCode, String region){ this.name = name; this.zipCode = zipcode; this.region = region; } ... } ``` ### Calling a constructor in Java A Java constructor is called with the keyword `new`. For instance: ```java City myCity = new City(\u0026#34;Florence\u0026#34;, 50100, \u0026#34;Tuscany\u0026#34;); City yourCity = new City(\u0026#34;Rome\u0026#34;, 00100, \u0026#34;Lazio\u0026#34;); ``` **_Note._** The object that is created in memory contains extra information, in particular a reference to its class. This allows type checking, casts, etc. (more on this later). ## Accessing an object in Java The attributes of an object can be accessed like regular variables, using `.`, followed by the name of the attribute. For instance, ```java City thatCity = new City(\u0026#34;Siena\u0026#34;, 53100, \u0026#34;Lazio\u0026#34;); System.out.println(\u0026#34;Wrong region: \u0026#34; + thatCity.region); thatCity.region = \u0026#34;Tuscany\u0026#34;; System.out.println(\u0026#34;Better now: \u0026#34; + thatCity.region); ``` will output ```java Wrong region: Lazio Better now: Tuscany ``` ## Reference type vs primitive type {#refType} Recall that a Java constructor returns a [reference](http://localhost:41071/docs/objects/sections/objects/#objectRef) to the object that it creates. So in the example above, the value of each variable (`myCity` and `yourCity`) is a reference, not the object itself. This also holds for: - variables of type `String`, - variable with an array type (like `int[] myArray`). The types of these variables (e.g. `City`, `String` or `int[]`) are called **reference types**. **_Syntax._** In Java, types that start with a _capital letter_ (like `City` or `Array`) are usually reference types. Types that are not references types (like `int` or `char`) are called **primitive types**. The _value_ of a reference _cannot_ be output (printed, displayed, etc.) by a program. But this value can be modified or compared to another. Exercise What is the output of the following program? ```java City aCity = new City(\"Matera\", 75100, \"Basilicata\"); City theSameCity = new City(\"Matera\", 75100, \"Basilicata\"); System.out.println(aCity == theSameCity); System.out.println(aCity.zipCode == theSameCity.zipCode); System.out.println(aCity.name == theSameCity.name); ``` Solution ```java false true false ``` Exercise What is the output of the following program? ```java City anotherCity = new City(\"Bologna\", 40100, \"Emilia-Romagna\"); City yetAnotherCity = new City(\"Mantua\", 46100, \"Emilia-Romagna\"); yetAnotherCity.name = anotherCity.name; System.out.println(yetAnotherCity.name); anotherCity = yetAnotherCity; System.out.println(anotherCity.zipCode); System.out.println(anotherCity == yetAnotherCity); ``` Solution \u003e Exercise 2. \u003e \u003e ```java \u003e \"Bologna\" \u003e 46100 \u003e true \u003e ``` ## Passing by value or by reference Programming languages differ in the way arguments are passed to methods. Two common strategies are: - **passing by value**: the method receives as input a _copy_ of each argument, - **passing by reference**: the method receives as input a _reference_ to each argument. Consider for instance the following program (in pseudocode): ```java int myInteger = 0 myMethod(myInteger) print(myInteger) void myMethod(int argument){ argument += 1 } ``` - If the argument is passed by value, then the program will print `0`. - If the argument is passed by reference, then the program will print `1`. ### Java passes by value {#javaByValue} In Java (and many other programming languages, like C, Python, Javascript, etc.), arguments are [passed by value](https://www.javadude.com/articles/passbyvalue.htm). So the above program translated in Java will print `0`. **_Warning._** Consider a method with a [reference type](#refType) argument. Because Java passes by value, this method will receive a copy of this argument. But this is a copy _of the reference_, not a copy of the object itself. Exercise What does the following Java program print? ```java int myInteger = 0; City myFirstCity = new City(\"Florence\", 50100, \"Tuscany\"); City mySecondCity = new City(\"Mantua\", 46100, \"Emilia-Romagna\"); myMethod(myInteger, myFirstCity, mySecondCity); System.out.println(myInteger); System.out.println(myFirstCity.zipCode); System.out.println(mySecondCity.zipCode); public void myMethod(int integer, City firstCity, City secondCity){ integer += 1; System.out.println(integer); firstCity.zipCode = 20590; System.out.println(firstCity.zipCode); secondCity = new City(\"Rome\", 00100, \"Lazio\"); System.out.println(secondCity.zipCode); } ``` Solution ```java 1 20590 00100 0 20590 46100 ``` "},{"id":23,"href":"/docs/unittests/sections/structured/","title":"Code units","section":"Unit tests","content":" Code units # A unit test is meant to test to a small unit of code. This is only possible if the program contains small units of code.\nTherefore unit testing is closely related to decomposing complex problems into smaller ones (and creating methods that solve these smaller problems).\nBenefits # Possible benefits of decomposing complex methods into smaller ones are:\nreadability, easier debugging, opportunities to factorize code (the same small methods can be called in several places), easier collaboration (two person modifying the same method in parallel is less likely if the method is small), Some good indicators that auxiliary methods may be helpful are:\nmultiple levels of nested blocks (\u0026ldquo;curly braces\u0026rdquo; in Java), a loop that contains a important amount of code. Exercise Simplify (and factorize) the following pseudocode using auxiliary methods: ```perl if(){ while(){ if(){ } else { } } } else { if(){ } else { } } ``` Possible solution ```perl method1() method1(){ if(){ method2() } else { method3() } } method2(){ while(){ method3() } } method3(){ if(){ } else { } } ``` "},{"id":24,"href":"/docs/unittests/sections/tdd/","title":"Development driven by unit tests","section":"Unit tests","content":" Development driven by unit tests # **Test-driven development (TDD)** consists in converting a program's requirements into test cases, _before_ the program is fully developed. Note that this approach is not restricted to unit tests.\nIn practice # For a _non-trivial_ method: 1. Create a method stub (e.g. `return null` is the method's return type is a reference type). 2. [Specify](http://localhost:41071/docs/interfaces/sections/specification/) the expected behavior (input and expected output) of the method. 3. Write one or several test(s) for this method, _illustrating_ the specification. 4. Implement the method until the test(s) is (are) successful. **_Hint._** Your IDE can generate method stubs. **_Note._** This implementation may be temporary. For instance, it may be refactored later on (moving code where it logically belongs, factorizing duplicate code, etc.). However, the tests that were written before refactoring are (usually) still relevant afterwards, because they correspond to functional requirements. Benefits # Some benefits of TDD are:\nStarting from an example often helps clarifying what a method should do. TDD provides intermediate objectives (milestones) to a developer. The sooner a bug is identified (during the development process), the easier it is to fix. The program is likely to be more robust, because development was guided by requirements (rather than technologies or algorithmic considerations). Each unit test created during TDD provides an alternative entry point (\u0026ldquo;green arrow\u0026rdquo; in an IDE) into the codebase (in addition to the \u0026ldquo;main\u0026rdquo; method). This allows experimenting with a specific feature in isolation, ignoring aspects that are not relevant for this feature (e.g. GUI, network, data storage, etc.). Example # In our game, let us consider once again the method EventHandler.deleteUnit, which modifies the current board when a unit deletion instruction is received.\nProblem decomposition # First, let us decompose this method into simpler ones. For instance as follows:\npublic class Backend implements EventHandler { private Snapshot currentSnapshot; ... void deleteUnit(int rowindex, int columnIndex) { // reduce by 1 the number of remaining actions for the active player decrementNumberOfRemainingActions(); // delete the unit (leaving a blank tile) currentSnapshot.getBoard().removeUnit(rowIndex, columnIndex); // shift up or down the units that followed it (if any) shiftUnitsInColumn(columnIndex); // perform resulting unit merges (if any) performUnitMerges(); // if there is no more action for the active player, then end the turn if (currentSnapshot.getNumberOfRemainingActions() == 0){ endTurn(); } } ... } At first sight, the auxiliary method decrementNumerOfRemainingActions seems trivial, so it may not benefit from unit tests. The method shiftUnitsInColumn seems relatively simple as well. However, the two remaining ones (performUnitMerges and endTurn) seem more complex. So it could be helpful to decompose them and/or devise unit tests for them.\nLet us focus on endTurn. It may for instance be decomposed as follows:\nvoid endTurn() { // perform attacks for units whose counter is 1 // (on the active player\u0026#39;s side) performAttacks(); // change the active player swapActivePlayer(); } And performAttacks may in turn be decomposed as follows:\nvoid performAttacks() { int maxColumnIndex = currentSnapshot.getBoard().getMaxColumnIndex(); // for each column for (int columnIndex = 0; columnIndex \u0026lt;= maxColumnIndex; columnIndex++){ performAttacks(columnIndex); } } void performAttack(int columnIndex) { // for each combined unit in this column (for the active player), // starting from front units for (Unit unit: getCombinedUnits(columnIndex)){ int countdown = unit.getAttackCountdown(); // if the unit is ready to attack if(countdown \u0026gt; 1) { unit.setAttackCountdown(countdown - 1); } else { attack(columnIndex); } } } Unit test # The auxiliary method attack seems non-trivial, so it may be a good candidate for unit testing.\nOne possible (\u0026ldquo;happy path\u0026rdquo;) test could be:\nInput (for column 1): ![](/img/test/board_input.png) ![](/img/test/bob_input.png) ![](/img/test/alice_input.png) Expected output: ![](/img/test/board_output.png) ![](/img/test/bob_output.png) ![](/img/test/alice_output.png) "},{"id":25,"href":"/docs/errors/sections/exceptions/","title":"Exceptions","section":"Errors","content":" Exceptions # Programming languages may significantly differ in the way they support errors messages.\nJava relies on a mechanism called exceptions. Several other languages use exceptions, for instance C++, C#, PHP, Python or Ruby. However, the purpose of exceptions may vary from one language to another.\nAn **exception** is an object or data structure that stores information about an exceptional condition encountered during the execution of a program. in Java # In Java, an exception is an object, instance of the native class Exception.\nAll exception types (e.g. IOException) are subclasses of Exception.\nBy convention, a class name for an exception:\nends with the word Exception, and provides information about the cause of the exception. Stack trace # By default, when an exception is thrown, the program interrupts its execution, and the current call stack is sent to an output stream called System.error. This output is called the stack trace (because it allows tracing back the method calls that led to the exception being thrown).\nFor instance, consider the following class:\n1 2 3 4 5 6 public class MyClass{ void myMethod(){ Integer.parseInt(\u0026#34;clearlyNotANumber\u0026#34;); } } When myMethod is executed, the following stack trace is printed to System.error:\njava.lang.NumberFormatException: For input string: \u0026#34;clearlyNotANumber\u0026#34; at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67) at java.base/java.lang.Integer.parseInt(Integer.java:668) at java.base/java.lang.Integer.parseInt(Integer.java:786) at Myclass.myMethod(Myclass.java:4) \u0026lt;bottom of the stack trace\u0026gt; The explanation is the following:\nmyMethod (Line 4) calls Integer.parseInt(String string), Integer.parseInt(String string) calls Integer.parseInt(String string, int radix) with the same string as argument, and a value of 10 for the radix (meaning that the string should represent an integer in base 10). Integer.parseInt(String string, int radix) throws an exception, because the string \u0026ldquo;clearlyNotANumber\u0026rdquo; does not represent a (base 10) number. **_Hint._** Your IDE allows you to navigate through Java's source code to trace the cause of an exception. **_Hint._** To debug your code, by default: 1. find the _last_ method (from bottom to top) in the stack trace that was written by you (in this example `Myclass.myMethod`), 2. using our IDE, create a breakpoint at the indicated line for this class (4 in this example), 3. run your program in debug mode (e.g. clicking on the \"bug\" icon of your IDE). Throwing an exception # An exception can be thrown with the keyword throw, as follows:\nboolean isSolvable(int[][] sudokuGrid){ if(sudokuGrid.length != 9){ throw new IllegalArgumentException(\u0026#34;A sudoku grid should have 9 rows\u0026#34;); } if(sudokuGrid[0].length != 9){ throw new IllegalArgumentException(\u0026#34;A sudoku grid should have 9 columns\u0026#34;); } ... } Classes for native Java exceptions usually have several constructors, one of which takes a string as input. For instance, in the example above, we used the constructor IllegalArgumentException(String errorMessage).\nCatching an exception # When a runtime exception is thrown by a method, the method immediately below it in the stack trace can either **rethrow** the exception, or **catch** it. If some method in the call stack catches the exception, then the program is not interrupted. Instead, control is passed to the catching method.\nIn other words, when an exception is thrown, the JVM \u0026ldquo;pops\u0026rdquo; method calls from the call stack, until either:\na catching method is found, or the call stack is empty (in which case the program is interrupted). For instance, let us modify myMethod above so that:\nit takes as input a string (maybe supplied at run time), if this string can be converted to an integer, then it returns this integer, otherwise it returns 0. This can be achieved by catching the exception thrown by Integer.parseInt. Syntactically, this is done with a try/catch block, as follows:\nint myMethod(String inputString){ try{ return Integer.parseInt(inputString); } catch (NumberFormatException e) { return 0; } } In this example:\nthe code inside the try block is always executed, the code inside the catch block is only executed if a NumberFormatException is thrown during the execution of the try block, the program is not interrupted. Chaining # The catch clause may itself throw an exception.\nThis is a very common pattern. In particular, it can be used to add information about the context in which an error occurred. In such a case, a common practice consists in chaining these two exceptions.\nMost native Java classes for exceptions have a dedicated constructor for this purpose: it takes as input a string (for the error message), and the exception that was caught. For instance, we can modify our example in such a way that if the input string cannot be converted to an integer, then the program gets interrupted, but with a less generic error message:\n1 2 3 4 5 6 7 8 9 10 public class MyClass{ int myMethod(String inputString){ try{ return Integer.parseInt(inputString); } catch (NumberFormatException e) { throw new IllegalArgumentException(\u0026#34;Please provide a valid number\u0026#34;, e); } } } Note in this example the second argument e of the constructor for IllegalArgumentException.\nIf the method is called as follows,\nmyMethod(\u0026#34;notANumberEither\u0026#34;); then the program will be interrupted, with the following stack trace:\nJava.lang.IllegalArgumentException: Please provide a valid number at MyClass.myMethod(MyClass.java:6) \u0026lt;bottom of the stack trace\u0026gt; Caused by: java.lang.NumberFormatException: For input string: \u0026#34;notANumberEither\u0026#34; at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67) at java.base/java.lang.Integer.parseInt(Integer.java:668) at java.base/java.lang.Integer.parseInt(Integer.java:786) at MyClass.myMethod(MyClass.java:4) "},{"id":26,"href":"/docs/generics/sections/generics/","title":"Generics","section":"Generic programming","content":" Generics # **_Terminology._** The term **generics** usually refers to [generic methods](#genericMethod) and [generic types](#genericType). Type variable # A **type variable** is a variable ranging over types. For instance, in the chapter dedicated to streams, we repeatedly used the variable $T$ to refer to the type of the elements of a stream.\nGeneric method # ### Example Consider the following interface `Unit` and its two implementations `Butterfly` and `Unicorn`. ![](/img/diagrams/plantuml/interface_inherit_basic_noColor.svg) Let us assume a method `healthiestButterfly` with type $\\qquad$ `Butterfly[]` $\\to$ `Butterfly` that returns one of the healthiest butterflies in the input array (or `null` if the array is empty). The following program does not compile, _as expected_ : ```java Butterfly[] butterflies = new Butterfly[]{ new Butterfly(12), new Butterfly(5) }; Unicorn u = healthiestButterfly(butterflies); ``` Neither does the following program (_as expected_ still): ```java Butterfly[] butterflies = new Butterfly[]{ new Butterfly(12), new Unicorn(5) }; Butterfly b = healthiestButterfly(butterflies); ``` Now let us assume that we need to perform the same operation on arrays of unicorns. We could write a nearly identical method `healthiestUnicorn`, with type: $\\qquad$ `Unicorn[]` $\\to$ `Unicorn` which returns one of the healthiest unicorns in the input array (if any). However, this approach is not scalable for a larger number $n$ of units types, because: - modifying the implementation requires modifying $n$ methods, and - duplicated code means duplicated bugs. Alternatively, we could factorize our code by writing a single method `healthiest` with type: $\\qquad$ `Unit[]` $\\to$ `Unit` However, with this solution, the two compile-time type checks that we saw above would be lost. The compiler cannot enforce anymore that: 1. the returned `Unit` has the same type as the units of the input array, 2. the input units must have the same type. For instance, the following program would compile: ```java Unit[] units = new Unit[]{ new Butterfly(12), new Unicorn(5) }; Unit healthiest = healthiest(units); ``` #### Solution We can factorize our code without sacrificing type safety, by using a type variable $T$ that stands for \"any subtype of `Unit`\". In order words, we can create a method `healthiest` with type: $\\qquad T[] \\to T$ where $T$ can be any subtype of `Unit`. Terminology # A method with (one or several) type variables is called a **generic method**. Syntax in Java # Declaration # The generic method in our example can be written as follows:\n\u0026lt;T extends Unit\u0026gt; T healthiest(T[] units) { ... } The block \u0026lt;T extends Unit\u0026gt;:\ndeclares the type variable T, and specifies that the type Unit is an upper bound on the value of T. This variable T can be used not only in the method\u0026rsquo;s signature, but also in its body.\n**_Example._** We could implement our method in the following (unnecessarily verbose) way. Observe that the type `T` also appears in the body of the method: ```java T healthiest (T[] units) { T selected = Arrays.stream(units) .max((u1, u2) -\u003e u1.health - u2.health) .orElse(null); return selected; } ``` **_Warning._** In this example, `T` is a (type) _variable_. So any other variable name could be used, for instance ```java X healthiest (X[] units) { ... } ``` or ```java TypeOfUnit healthiest (TypeOfUnit[] units) { ... } ``` By convention, the letters `T`, `E` and `V` are often used for type variables (as well as `R` if the type variable is used for the return type of a method). If there is no upper bound on the type variable (in other words, if the upper bound is Object), then the extends statement can be omitted.\n**_Example._** ```java T myMethod (T arg1, String arg2) { ... } ``` It is also possible to declare several type variables.\n**_Example._** ```java Unit myMethod (T arg1, V arg2) { } ``` Method call # A generic method can be called by replacing types variables with concrete types (in a way that is consistent with the method declaration).\n**_Examples._** Let us recall the signature of our generic method above: ```java T healthiest(T[] units) { ... } ``` The following program will compile (and run as expected): ```java Butterfly[] butterflies = getButterflies(); Butterfly b = healthiest(butterflies); Unit u = healthiest(butterflies); ``` However, the following program will not compile, _as expected_ : ```java Butterfly[] butterflies = getButterflies(); Unicorn u = healthiest(butterflies); ``` The following program will not compile either, _as expected_ : ```java String[] strings = getStrings(); String u = healthiest(strings); ``` Generic type # **_Terminology._** A **generic type** is a type with type variable(s). **_Examples._** Let `T`, `E` and `R` be type variables. Then in Java: - `Set` is a generic type, - `Set` is equivalent to `Set`, - `Function` is another generic type. **_Terminology._** A **parameterized type** is a generic type whose type variables are instantiated. **_Examples._** In Java: - `Set` is a parameterized type, - `Function` is another parameterized type. Usage # Generic types serve the same purpose as generic methods, i.e. factorizing code without sacrificing type safety.\nFor some object-oriented languages (like Java or C++), generic types are instrumental in factorizing the implementation of abstract data types (such as lists, sets, associative arrays or queues).\n**_Example._** The generic Java class `HashSet` provides a _unique_ instance method to add an element to the set. This method has signature `boolean add(E e)`. Syntax in Java # Declaration # We can declare type variables whose scope is an entire Java class (resp. interface, record).\nThe declaration of these type variables is identical to the one we saw above for methods, but the \u0026ldquo;diamond\u0026rdquo; is immediately next to the class (resp. record, interface) name (rather than left of the method declaration):\n**_Example._** We can create a generic wrapper class `Box` (similar to Java's [Optional](http://localhost:41071/docs/stream/sections/optional/)), as follows: ```java public class Box { ... } ``` These type variables are visible in the whole the class (resp. record, interface) body.\n**_Example._** ```java public class Box { T boxedValue; public Box(T boxedValue){ this.boxedValue = boxedValue; } T get(){ if(boxedValue != null) { return boxedValue; } ... } ... } ``` **_Warning._** The value of the type variables (e.g. the value of `T` in the above example) may vary from one instance of the generic class to the other. Therefore a type variable associated to a class (resp. interface) _cannot_ be used: - in a static method of this class (resp. interface), or - as the type of a static attribute of this class (resp. interface). For instance, the following class does not compile: ```java public class Box { static T myAttribute; ... } ``` Instantiation # An instance of a generic class (resp. record) can be created by providing parameter types when calling its constructor.\n**_Example._** ```java Box myBoxedString = new Box(\"banana\"); ``` **_Syntactic sugar._** In this example, the second type parameter `String` (used with the constructor) is redundant. So it can be safely be omitted: ```java Box myBoxedString = new Box\u003c\u003e(\"banana\"); ``` Instance method call # A method declared in a generic class (or interface or record) can be called like a generic method (with the same restriction as the ones described above).\n**_Example._** Let us recall our generic class `Box`: ```java public class Box { T boxedValue; public Box(T boxedValue){ this.boxedValue = boxedValue; } T get(){ if(boxedValue != null) { return boxedValue; } ... } ... } ``` The following program will compile (and run as expected). ```java Box myBoxedString = new Box\u003c\u003e(\"banana\"); String unboxedString = myBoxedString.get(); ``` The following program will not compile, _as expected_ : ```java Box myBoxedString = new Box\u003c\u003e(\"banana\"); Integer unboxedInteger = myBoxedString.get(); ``` More examples # Exercise Consider the following generic class. ```java public class Pair{ T arg1; V arg2; public Pair(T arg1, V arg2){ this.arg1 = arg1; this.arg2 = arg2; } V someMethod(V mArg){ return mArg; } } ``` Which of the following Java programs compile? 1. ```java Pair myPair = new Pair\u003c\u003e(15, 32); Double someNumber = myPair.someMethod(6.0); ``` 2. ```java Pair myPair = new Pair\u003c\u003e(15, 32); Number someNumber = myPair.someMethod(6.0); ``` 3. ```java Pair myPair = new Pair\u003c\u003e(15, 32); Number someNumber = myPair.someMethod(6); ``` 4. ```java Pair myPair = new Pair\u003c\u003e(15, 32); Number someNumber = myPair.someMethod(6.0); ``` 5. ```java Pair myPair = new Pair\u003c\u003e(32, 15); Integer someNumber = myPair.someMethod(6.0); ``` 6. ```java Pair myPair = new Pair\u003c\u003e(32, 15); Number someNumber = myPair.someMethod(6.0); ``` 7. ```java Pair myPair = new Pair\u003c\u003e(32, 15); Integer someNumber = myPair.someMethod(6.0); ``` 8. ```java Pair myPair = new Pair\u003c\u003e(32, 15); Integer someNumber = myPair.someMethod(6); ``` 9. ```java Pair myPair = new Pair\u003c\u003e(32, 15); Double someNumber = myPair.someMethod(6.0); ``` Solution 3, 4 and 8. Inheritance # If a class extends a generic class, then the subclass must redeclare the type variables of the superclass, or instantiate them (with a type).\n**_Example._** The following program does _not_ compile: ```java public class Superclass { ... } public class Subclass extends Superclass { ... } ``` However, the following are all valid: ```java public class Superclass { ... } public class Subclass extends Superclass { ... } ``` $\\qquad$ ```java public class Superclass { ... } public class Subclass extends Superclass { ... } ``` $\\qquad$ ```java public class Superclass { ... } public class Subclass extends Superclass { ... } ``` $\\qquad$ ```java public class Superclass { ... } public class Subclass extends Superclass { ... } ``` $\\qquad$ The subclass can also declare additional type variable\n**_Example._** ```java public class Superclass { ... } public class Subclass extends Superclass { ... } ``` These rules also apply to:\nan interface that extends an interface, a class that implements an interface, etc. "},{"id":27,"href":"/docs/datastructures/sections/hash/","title":"Hash table","section":"Data structures","content":" Hash table # A hash table is a data structure often used to implement an associative array (like a Java Map).\nAssociative array # **_Reminder._** An **associative array** (or **map**) is a finite set of key-value pairs, where keys are distinct. **_Terminology._** A key-value pair in associative array is also called an **entry**. **_Running example._** The following associative array has 5 entries. $\\qquad$ 1 $\\mapsto$ `Alice` $\\qquad$ 3 $\\mapsto$ `Bob` $\\qquad$ 4 $\\mapsto$ `Carol` $\\qquad$ 9 $\\mapsto$ `Dan` $\\qquad$ 12 $\\mapsto$ `Eve` In this associative array, keys are integers, and values are strings. **_Notation._** We will use $K$ for the type of the keys (integers in this example), and $V$ for the type of the values (strings in this example). Structure # A hash table is an array $A$, whose entries are called **slots** (or **buckets**). Hash tables come in two varieties:\nchaining hash tables and hash tables with open indexing. In a **chaining hash table**, each slot is a pointer to a data structure (typically a linked list). These data structures store the entries (a.k.a. key-value pairs) of the associative array. **_Example (continued)._** The following is a chaining hash table, which stores our associative array. ![](/img/hashTable/ex/hashTable.svg) The array has 4 slots, each of which points to a (possibly empty) linked list. In a hash table with **open indexing**, each slot stores one entry of the associative array. We will discuss open indexing later in this section (and focus for now on chaining hash tables).\nHash function # In a hash table, whether a certain entry is assigned to a certain slot is determined by a so-called hash function.\n**_Definition._** A **hash function** maps each key in $K$ to an index in $A$. **_Example (continued)._** In the above example, we used $\\qquad h(k) = k \\mod 4$ as our hash function. For instance, $\\qquad h(9) = 9 \\mod 4 = 1$ which explains why the entry $\\qquad$ $9 \\mapsto$ `Dan` is assigned to slot $1$. Collision # The size of the set $K$ of possible keys is often (much) larger than the size of the hash table $A$.\n**_Example (continued)._** In our example, $K$ is the set of integers. In Java, this set has size $2^{32}$ (i.e. more than 4 billion), which is unrealistic for the size of $A$. As a consequence, hashing functions are usually not injective.\n**_Terminology._** A **collision** occurs when two entries of an associative array are assigned to the same slot. In other words, a collision occurs if the associative array contains two entries ${k_1 \\mapsto v_1}$ and ${k_2 \\mapsto v_1}$ such that $h(k_1) = h(k_2)$. **_Example (continued)._** In the example above, 1 $\\mapsto$ `Alice` and 9 $\\mapsto$ `Dan` are assigned to the same slot, because $$ h(1) = h(9) = 1 $$ Collisions are often unavoidable (this is a consequence of what is sometimes called the birthday paradox).\n**_Example._** Let us assume that our hashing function $h$ partitions $K$ evenly across slots (like the function $h(x) = x \\mod 4$ used above). - If $A$ has $16$ slots (which is the default size of a hash table in Java), then the probability of a collision is $\\ge 0.5$ for $5$ entries already - If $A$ has $1000$ slots, then the probability of a collision is $\\ge 0.5$ for $38$ entries already, and $\\ge 0.9$ for $69$ entries already. Performance # **_Reminder._** An associative array exposes (at least) the following methods: - **lookup** (or **get**) takes a key as input, and returns the value for this key (if any). - **insert** (or **put** ) inserts a pair _(key, value)_. If an entry for this key was already present, then overwrites its value. - **remove** (or **delete**) deletes the entry for a given key (if any). Worst case # In a chained hash table, in order to check whether the structure contains an entry for an input key $k$, we need to:\ncompute $h(k)$ search for an entry with key $k$ in the data structure that $A[h(k)]$ refers to (if any). Exercise Consider a associative array with $n$ entries, stored as a chained hash table with linked lists (as above). What is the worst case asymptotic running time of the lookup operation? Instead, what would be the best possible scenario? Solution A worst possible input (of size $n$) for the lookup operation consists of an input key $k$ and an input hash table $A$ with hash function $h$ such that, for each pair $k' \\mapsto v$ stored in $A$: - $k' \\neq k$ and - $h(k') = h(k)$. In this case, any algorithm for lookup would need to inspect the whole list $A[h(k)]$. So the worst-case running time of such an algorithm is in $\\Theta(n)$. A best possible input consists of an input key $k$ and an input hash table $A$ with hash function $h$ such that $h(k') \\neq h(k)$ for each pair $k' \\mapsto v$ stored in $A$. A standard algorithm for lookup in this case would have constant running time (expressed as function of $n$). Load factor and rehashing # **_Definition._** Let $n$ be the number of entries in the associative array, and let $m$ be the size of $A$. The ratio $\\alpha = \\frac{n}{m}$ is called the **load factor** of the hash table. A high load factor increases the chances of collision, thus affecting performance.\nWhen the load factor becomes too high, the hash table is typically rehashed, meaning that a larger hash table is created (thus with a different hashing function), in which entries are re-inserted.\nFrom Wikipedia, for a chaining hash table, the maximal acceptable load factor is between 1 and 3.\nAverage running time # A good hash function is usually expected to distribute keys evenly across slots.\nIn a chaining hash table, this means that all lists should have length close to the load factor $\\alpha$.\nUniversal hashing refers to using not one, but a collection of hash functions that satisfies certain properties, and randomly selecting one of these functions at runtime.\nThis guarantees that for a fixed set $S \\subset K$ of keys with size $n$, and for a fixed $k \\in S$, the average length of the slot for $k$ is the load factor $\\alpha$.\nIn other words, the average running time of lookup, insertion and deletion is $\\alpha = \\frac{n}{m}$.\nIf we assume that the size $m$ of $A$ is always reasonable for the number $n$ of entries of the associate array, then $\\alpha$ is independent of $n$. So under this assumption, the average running time of lookup, insertion and deletion is constant (i.e. is in $\\Theta(1)$.\nOpen indexing # In a hash table with **open indexing**, each slot stores at most _one_ entry of the associative array. In case of collision between two entries, one of them is assigned to a free slot. This is achieved via a so-called probing function (from indices to indices), which defines an order over indices. More precisely:\nInsert. When inserting an entry with key $k$, if the slot $A[h(k)]$ is already occupied, then the \u0026ldquo;next\u0026rdquo; free slot is used instead (where \u0026ldquo;next\u0026rdquo; depends on the probing function). Lookup. When searching for the entry with key $k$, the first investigated slot is $A[h(k)]$, then its successor $s$ (according to the probing function), then the successor of $s$, etc., until we reach the entry with key $k$ (if present) or an empty slot. Delete. When deleting a entry, the slot that it was occupying cannot be deleted, because the resulting empty slot may break future searches. Instead, the slot is marked as a so called tombstone, which does not interrupt a search, but can still be used for future insertions. Performance # The (average and worst case) asymptotic costs of these operations are identical to the ones for chained hash tables.\nOpen addressing can be more efficient in practice than chaining, because it is more likely to benefit from caching (since the whole hash table it an array, it is likely to be contiguous in memory).\nA downside is the maximal acceptable load factor, which is (necessarily) $\\le 1$ (from Wikipedia still, between 0.6 and 0.75).\nin Java # Implementation # Java uses chained hash tables internally, with 16 slots by default.\nEach slot points to a linked list by default.\nIf the maximal acceptable load factor is exceeded, then the hash table is rehashed (as expected).\nIn addition, Java uses a maximal load threshold for an individual slot. If this value is exceeded (but the maximal load factor is not), then the linked list for this slot is converted to a red-black tree.\nAssociative array # As we saw in the dedicated section, the interface java.util.Map represents an associative array.\nThe class java.util.HashMap implements the interface as a hash table.\nThe class java.util.LinkedHashMap also implements this interface as a hash table. However, in addition, each entry contains two pointers to its processor and successor (if any) in the order of insertion, thus forming a double linked list, independent of the hash table itself. This allows iterating over the entries of a map in a predictable order (precisely, their insertion order), which is not possible with a HashMap.\n**_Warning._** In a `LinkedHashMap`, overwriting the value of an entry (with the method `Map.put`) does _not_ affect the order of insertion. Set # As we saw in the dedicated section, the interface java.util.Set represents a set.\nThe class java.util.Hashset implements this interface as a hash table, where keys are the elements of the set, and an \u0026ldquo;entry\u0026rdquo; consists of a key only (i.e. has no value).\nThe class java.util.LinkedHashSet also implements this interface as a hash table. It is analogous to LinkedHashMap, i.e. it guarantees that iteration preserves the order of insertion.\nhashCode # In Java, the keys of a `Map` and the entries of a `Set` are _objects_. So a Java hash function must map an _object_ to a hash table slot. Technically, this function is the composition of: - the function `hashCode`, which maps an object to an `int`, and - a proper hash function $h$ that maps this `int` to a hash table slot. The function hashCode is an instance method of the class Object, thus it is inherited by default by all objects. This function behaves like a pure function, in the sense that it must return twice the same int if it is called twice for the same object. This property must be preserved if the method is overridden.\nThe hash function $h$ is also a function in the mathematical sense. Therefore the composition of these two functions has this property. As a consequence, a same key is always mapped to the same slot.\nhashCode and equals # **_Warning._** In a Java hash table, two keys $o_1$ and $o_2$ are considered equal iff $\\qquad o_1$.`equals(`$o_2$`)` returns `true`. Exercise Consider the following Java class `City`, which overrides the method [equals](http://localhost:41071/docs/objects/sections/comparing/#equals), so that two cities are considered equal iff they have the same name and zip code. ```java public class City(){ String name; int zipCode; public City(String name, int zipCode){ this.name = name; this.zipCode = zipCode; } @Override public boolean equals(Object o) { if (this == o) { // same reference return true; } if (o == null || getClass() != o.getClass()) return false; // o is null or has a different type } City downcastObject = (City) o; return zipCode == downcastObject.zipCode \u0026\u0026 name.equals(downcastObject.name); } ``` What does the following program output? ```java City bologna = new City(\"Bologna\", 40100); City bolognaAgain = new City(\"Bologna\", 40100); Set cities = new HashSet(); cities.add(bologna); System.out.println(cities.contains(bolognaAgain)); ``` Solution The output is unpredictable. Observe that the variables `bologna` and `bolognaAgain` point to two different objects $o_1$ and $o_2$. In the hash table that stores the set `cities`: - the slot associated to $o_1$ is $i_1 = h$($o_1$.`hashCode()`), - the slot associated to $o_2$ is $i_2 = h$($o_2$.`hashCode()`). Since $o_1$ and $o_2$ are different objects, $i_1$ and $i_2$ _may of may not_ be identical. The instruction `cities.add(bologna)` adds a node with key $o_1$ to $A[i_1]$. Then the instruction `cities.contains(bolognaAgain)` searches for a node with a key equal to $o_2$ in $A[i_2]$. - If $i_1 = i_2$ (i.e. if we have a collision), since $o_1$`.equals(`$o_2$`)` evaluates to true, the method `contains` will return `true`. - If $i_1 \\neq i_2$, since the slot $A[i_2]$ is empty, the method `contains` will return `false`. **_Warning._** As show with this exercise, if a class overrides `equals` without overriding `hashCode`, then the behavior of the three basic operations on hash tables (insertion, lookup and deletion) may depend on [collisions](#collision). This makes the behavior of several methods implemented by HashMap, LinkedHashMap, HashSet and LinkedHashSet (among others) unpredictable.\nTo avoid this, whenever equals is override, hashCode should be overridden accordingly.\n**_Example(continued)._** `hashCode` could be implemented as follows: ```java public class City(){ ... @Override public int hashCode(){ return name.length + zipCode; } } ``` In the example above, any (pure) function that produces an int out of the values of name and zipCode could in theory be used to implement hashCode in the class City.\nHowever, the choice of this function may affect performance.\n**_Example(continued)._** The following implementation of `hashCode` also complies with the implementation of `equals` above. However, it has the effect of mapping all keys with type `City` to the same hash table slot. ```java public class City(){ ... @Override public int hashCode(){ return 1; } } ``` This is why a common practice consists in implementing hashCode in terms of the method hashCode of the selected attributes (and implement the method hashCode of these attributes similarly, in a recursive fashion).\n**_Note._** Most native Java classes (like `String`, `Integer`, `Boolean`, `ArrayList`, `HasSet`, etc.) already implement `hashCode` (in accordance with `equals`). The utility method Objects.hash takes any number of arguments, and wraps the ones that have primitive types (e.g. int into Integer). It returns an int whose value is a function of the outputs of the respective hashCode methods of the arguments.\n**_Example(continued)._** In our example, we can implement `hashCode` as follows: ```java public class City(){ ... @Override public int hashCode() { return Objects.hash(name, zipCode); } } ``` The returned value depends on the values of `name.hashCode()` and `Integer.valueOf(zipCode).hashCode()`. "},{"id":28,"href":"/docs/env/sections/files/","title":"Hierarchical file system","section":"Development environment","content":" Hierarchical file system # Tree # Most operating system expose files as a tree (or possibly several trees for Windows).\n**_Definition._** A (nonempty) **tree** is either: - a single node (called a **leaf**), or - a node with one or several children that are trees. In this tree, non-leaf nodes are directories, and the leaves can be files, executables, links, empty directories, etc. For instance:\nâââ bin â âââ echo â âââ ... âââ home â âââ alice â â âââ .bashrc â â âââ .m2 â â â âââ ... â â âââ Desktop â â â âââ ... â â âââ music â â â âââ thatSong.mp3 â â âââ workspace â â âââ pp â â âââ assignments â â â âââ ... â â âââ project â â âââ .git â â â âââ ... â â âââ src â â â âââ HelloWorld.java â â âââ test â â âââ testHelloWorld.java â âââ bob â âââ .bashrc â âââ Desktop â â âââ ... â âââ music â âââ thatSong.mp3 â âââ anotherSong.mp3 âââ ... **_Terminology._** In this course, we will use the terms \"folder\" and \"directory\" interchangeably. **_Terminology._** \"File\" is sometimes used (e.g. in the Linux documentation) as a generic term for all nodes in this tree (in combination with \"directory file\", \"executable file\", \"regular file\", etc.) We will _not_ follow this terminology. Windows may expose several trees (e.g. one per physical device).\nPath # **_Definition._** In such a tree, a **path** from a directory _s_ to an arbitrary node _t_ is either: - `.` if _s_ and _t_ are the same node, or - `..` if _t_ is the parent of _s_, or - the name of _t_ if _s_ is the parent of _t_, or - a path from _s_ to some node _i_, followed by `/` (or `\\`on Windows), followed by a path from _i_ to _t_. For instance (on macOS, Linux, etc.), in the tree above:\nhome/alice/workspace/pp/project/src/HelloWorld.java is a path from the root to the file HelloWorld.java, workspace/pp/project/src/HelloWorld.java is a path from the directory alice to the file HelloWorld.java, ../../bob/Desktop is a path from Alice\u0026rsquo;s Desktop to Bob\u0026rsquo;s Desktop, ../../bob/../bob/./Desktop is another path from Alice\u0026rsquo;s Desktop to Bob\u0026rsquo;s Desktop. Exercise How many paths are there from a directory to an arbitrary node? Solution (Countably) infinitely many. **_Warning._** Some operating system (Windows, macOS) use _case-insensitive_ paths, whereas others (Linux, Android) use _case-sensitive_ paths (this may also vary depending on physical storage devices). For instance, on Windows, `src/HelloWorld.java` and `src/helloworld.java` are the _same path_. In order to make sure that your code is portable: - always use _case-sensitive_ paths in your code (i.e. respect the names of your files, folders, executables, etc.), - do not create two files (or subfolders, executables, etc.) in the _same_ folder with identical names modulo upper/lower case (e.g. `Readme.md` and `README.md`). **_Convention._** In what follows (unless explicitly stated), we will adopt by default the conventions for path names adopted on Linux. In particular, we will use `/` as a separator, and case-sensitive file and folder names. Absolute path # **_Definition._** An **absolute path** is a path prefixed with: - `/` on macOS, Linux, Android, IOs, etc. - a capital letter followed by `:\\` on Windows, where the letter identifies a physical device, disk partition, etc. In particular, the identifier of the main partition is often the letter `C`, in which case absolute paths (within this partition) are prefixed with `C:\\`. An absolute path is always a path _from the root of the tree_. For instance (on macOS, Linux, etc.), /home/alice/workspace/pp/project/src/HelloWorld.java is an absolute path to the file HelloWorld.java\nA few simple observations:\ntwo different files may share the same name (but cannot share an absolute path), and two files with the same name may or may not be identical. E.g. in the above example, the two files named thatSong.mp3 may or may not be identical. Relative path # **_Definition._** A **relative path** is a path that is not absolute. For instance (on macOS, Linux, etc.), ../../bob/Desktop is a path to to Bob\u0026rsquo;s Desktop relative to Alice\u0026rsquo;s Desktop.\nNote that if p is a relative path, then p prefixed with ./ (or .\\ on Windows) is a path equivalent to p. This prefix is sometimes used to emphasize that a path is relative (among other purposes).\nWorking directory # Each process (e.g. a process that executes a Java program) has a working directory, which is a directory of the hierarchical file system. This directory may vary depending on the program and/or how it was started.\nMany programs (implicitly) interpret a relative path as relative to their working directory, regardless of whether the path is prefixed with ./ (or .\\ on Windows).\nIn particular, this is the case of:\nJava programs, file browsers, shells. Home directory # Each user of a system has its own home directory. E.g. in this example:\n/home/alice/ for Alice /home/bob/ for Bob **_Warning._** The home directory is usually _not_ the root of the tree (even if there is a single user on the machine). Absolute paths to the home directory # The home directory (of a regular user) is normally:\n/home/\u0026lt;userId\u0026gt; on Linux/BSD, /Users/\u0026lt;userId\u0026gt; on macOS, /User/\u0026lt;userId\u0026gt; on iOS, /data/media/â¨userIdâ© on Android, \u0026lt;mainHardDriveId\u0026gt;:\\Users\\\u0026lt;userId\u0026gt; on Windows (e.g. C:\\Users\\\u0026lt;userId\u0026gt;). On Linux and macOS, the alias ~ can be used as an absolute path to the current user\u0026rsquo;s home directory. For instance, in the above example, if Alice is logged in, then ~/music/thatSong.mp3 and /home/alice/music/thatSong.mp3 are two absolute paths to the same file.\nAccess restriction # Files and programs within the home directory of a user can usually be accessed by this user (or a system admin). Therefore programs that can be executed by all users are usually located in other directories (e.g. the program /bin/echo in the example above). Access restrictions (read, write and/or execute) may apply to the content of such directories. Notably, on Linux systems, (most of) the content of these directories can only be modified by a system admin.\nHidden files and directories # The home directory often contains files (resp. directories) whose names are preceded with a . (e.g. the file /home/alice/.bashrc in the above example). These are sometimes called \u0026ldquo;dot files\u0026rdquo; (resp. \u0026ldquo;dot folders\u0026rdquo;). On Linux and macOS, dot files and dot folder are hidden by default in a terminal or a file browser. On Windows, a (dot or not) file or folder can also be hidden, via a dedicated \u0026ldquo;hidden\u0026rdquo; attribute.\nHidden files and directories may be used to store (user-specific) parameters or options for a program. For instance, the configuration file ~/.gitconfig can be used to declare parameters (e.g. user identifier, etc.) or options (e.g. disable default fast-forward merge, etc.) to be used with git.\n**_Hint._** Configuration files are a convenient way to save your personal preferences and use them on several machines. For instance, you may need to logging to a remote server via [ssh](https://en.wikipedia.org/wiki/Secure_Shell) to perform some tasks (e.g. deploy a database or run costly computations). In such a scenario, you can upload dot files to your home directory on this server. Hidden files or directories may serve other purposes. For instance, the dot folder ~/.m2 is used by Maven to store (in one place) the Java libraries that are required (as dependencies) by any Java project present in the home directory.\nHidden files or directories may also contain information specific to a subdirectory. For instance, every git repository (a.k.a. \u0026ldquo;project\u0026rdquo;) contains a dot folder .git that stores the full history of modification made to the repository.\nUsage and layout # Your home directory is where you generally want to store your projects, documents, scripts, etc.\nYou are free to structure it as you like (using sub-directories). Make sure that this structure allows you to retrieve your own work easily.\n**_Warning_**. When you download or create a project/document in your home directory, _choose its location_. Do _not_: - let an application decide this location for you, - rely exclusively on the \"recently opened\" feature of an app to locate your files, - store files and project directly at the root of your home directory. **_Warning_**. Aside from a few exceptional cases, your home directory should _not_ contain multiple copies of a project or document. **_Hint._** It can be difficult for a new developer to figure out when to accept the default directory or layout suggested by a program, and when to overwrite it. As a (soft) rule of thumb, you generally want to _choose the location_ of: - a file downloaded from your browser (or mail client), - a project created with your IDE, - a cloned git repository, - a file created with an app, - etc. Conversely, it is generally recommended to _follow suggestions_ in the following cases: - internal structure of a project (typically the one generated by an IDE): e.g. the [standard directory layout](http://localhost:41071/docs/build/sections/layout/) for a Maven project, or the [standard directory structure](https://www.geeksforgeeks.org/folder-structure-for-a-node-js-project/) of a Node JS project. - software installed outside of your home directory, - location of dot files and folders, - etc. "},{"id":29,"href":"/docs/regex/sections/practice/","title":"in practice","section":"Regular expressions","content":" Regexes in practice # Concrete regexes deviate from theoretical ones in several ways. In particular:\nConcrete syntaxes include a wide range of syntactic sugar, i.e. operators that could in theory be expressed in terms of |, * and concatenation.\nMany regex engines support expressions with features (such as backreferences) that go beyond the expressivity of theoretical regexes. Technically, such expressions do not qualify as as regexes (they may describe a language that is not regular). However, in practice, they are still referred to as \u0026ldquo;regexes\u0026rdquo;. This is also what we will do in this section.\nFlavours # Multiple syntaxes for regexes coexist, which have a lot in common. Among these:\nRegexes defined by the IEEE POSIX standards are supported by a variety of command-line utilities, scripting languages or database engines.\nThe regex engine of the programming language Perl has been very influential. A widely used variant is the PCRE (Perl Compatible Regular Expressions) library, written in C (and natively used by PHP and R). Besides, many programming languages (Java, Javascript, Python, C#, etc.) have adopted a regex syntax and engine inspired by Perl\u0026rsquo;s.\nA detailed comparison of some the main flavours of regexes can be found here.\n**_Warning._** The patterns used in [.gitigore](http://localhost:41071/docs/git/sections/ignore/) files are _not_ regular expressions. Java regexes # Java regexes are very similar to PCRE regexes (albeit less expressive).\nWe list below some of the main constructs of Java regexes, and refer to the Javadoc for an exhaustive list. Most of these are identical in other regex languages inspired by Perl\u0026rsquo;s.\nCharacters # A character in a Java regex can alternatively be written using its Unicode hexadecimal identifier, preceded with \\u.\n**_Examples._** - the character `A` can be written either in its normal form, or `\\u0041` - the carriage return character can be written either `\\r` or `\\u000D` Special characters (like | or *) need to be escaped to be treated as standard ones (except in some specific contexts, see below).\n**_Examples._** In order to be treated as a standard character: - `*` can be either escaped (`\\*`) or written `\\u002A` - `\\` can be either escaped (`\\\\`) or written `\\u005C` Syntactic sugar # We have seen in previous sections that in theory, regular expressions only admit three operators:\nconcatenation ($e_1e_2$), union ($e_1$|$e_2$) and closure ($e$*). However, this is impractical for most implication.\n**_Example._** In order to match a character that is _not_ a digit, with these three operators only, one would need to write an expression that enumerates all other characters in the underlying [alphabet](http://localhost:41071/docs/background/sections/regular/#alphabet), e.g.: $\\qquad\\qquad$ `a | b | c | .. | A | B | C | .. | \u0026 | ! | \u003e | ..` For the simple [ASCII](https://en.wikipedia.org/wiki/ASCII) alphabet, this is already more than a hundred characters. For the Unicode alphabet, this is more than 100 000. In practice, regexes include additional operators, most of which are syntactic sugar (i.e. could in theory be expressed with only concatenation, union, and closure).\nCharacter class # Square brackets (`[` and `]`) are used to denote a set of characters, called a **character class**. **_Examples._** - `[abcd]` is equivalent to `a|b|c|d` - `gr[ae]y` is equivalent to `gr(a|e)y` A character class can also be defined with _ranges_ of characters. If $c_1$ and $c_2$ are two characters, then $c_1$`-`$c_2$ (within square brackets still) denotes any character _between_ $c_1$ and $c_2$ in the Unicode alphabet. **_Examples._** - `[A-Z]` matches any character between `A` and `Z` - `[A-Za-z0-9]` matches any character between (`A` and `Z`) or between (`a` and `z`) or between (`0` and `9`) - `[A-Za-z@]` matches `@` or any character between (`A` and `Z`) or between (`a` and `z`) The **complement** (in the Unicode alphabet) of a character class is described by adding a `^` after the opening square bracket `[`. **_Examples._** - `[^a]` matches any character different from `a` - `[^abc]` matches any character that is neither `a`, `b` or `c` - `[^0-9]` matches any character that is not a digit - `[^A-Za-z0-9]` matches any character that is not an ASCII letter or digit Most special characters (like * or |) can be used unescaped inside square brackets to refer to a character (some exceptions to this rule are -, ^ or \\).\n**_Examples._** - `[|*]` matches either a `|` or a `*` - `[^|]` matches any character that is not `|` The special character `.` stands for any (Unicode) character **_Examples._** - `..` matches any string of two characters - `.*` matches any Unicode string Exercise List all matches returned by a regex engine for: 1. the regex `gr[ae]y` in `the words grey and gray are homonyms` 2. the regex `[A-Z][^;]*;` in `Alice:12;Bob,35;` 3. the regex `\u003c.*\u003e` in `My Title` Solution 1. $[10 .. 14)$: `grey`, $[19 .. 23)$: `gray` 1. $[0 .. 8)$: `Alice:12;`, $[19 .. 23)$: `Bob:35;` 1. $[0 .. 35)$: `My Title` Exercise Use the regex validation tool [regex101](https://regex101.com) to write a regex whose evaluation matches HTML tags. For instance, in the word $\\qquad\\qquad$`My Title` the regex should match `` and ``. Possible solution `\u003c[^\u003e]*\u003e` Predefined character classes # Some escaped characters denote common character classes:\n- `\\d` is equivalent to `[0-9]` - `\\w` is equivalent to `[A-Za-z0-9]` - `\\s` stands for any whitespace character. It is equivalent to $\\qquad\\qquad$`[ \\t\\n\\x0B\\f\\r]` - `\\R` stands for any Unicode linebreak sequence. It is equivalent to $\\qquad$`\\u000D\\u000A|[\\u000A\\u000B\\u000C\\u000D\\u0085\\u2028\\u2029]` The complements of some of these classes are also available:\n- `\\D` is equivalent to `[^\\d]` - `\\S` is equivalent to `[^\\s]` - `\\W` is equivalent to `[^\\w]` Quantifiers # If $i \\le j \\in \\mathbb{N}$ then $e$`{`$i$`,`$j$`}` concatenates $e$ with itself at least $i$ times and at most $j$ times, and is evaluated in a [greedy](http://localhost:41071/docs/regex/sections/pattern/#greedy) way. **_Examples._** - `a{1,3}` is equivalent to `aaa|aa|a` - `[A-Z]{1,3}` greedily matches a sequence of 1 to 3 capital letters - `[A-Z]{0,3}` greedily matches a (possibly empty) sequence of at most 3 capital letters $e$`{`$i$`}` is equivalent to $e$`{`$i$`,`$i$`}`. **_Examples._** - `a{3}` is equivalent to `aaa` - `[A-Z]{4}` matches a sequence of 4 capital letters $e$`+` is equivalent to $ee$`*`. **_Examples._** - `a+` greedily matches a sequence of at least one `a` - `\\d+` greedily matches a nonempty sequence of digits - `[^\\d]+` greedily matches a nonempty sequence of non-digits If $e$ does not end with a quantifier, then $e$`?` is equivalent to $e$`|`$\\varepsilon$. **_Examples._** - `a?` greedily matches at most one occurrence of `a` - `(ab)?` greedily matches at most one occurrence of `ab` - `[A-Z]?` greedily matches at most one capital letter Lazy quantification # If $e$ ends with a quantifier (e.g. with `*` or `+`) then $e$`?` forces a [lazy](http://localhost:41071/docs/regex/sections/pattern/#lazy) evaluation of this quantifier. **_Examples._** - In the word $w$ = `ab`: - `ab*` matches $w$ - `ab*?` matches $w[0 .. 1)$: `a` - In the word $w$ = `abbb`: - `ab{1,3}` matches $w$ - `ab{1,3}?` matches $w[0 .. 2)$: `ab` Boundary matchers # Some special characters match empty segments (i.e. segments with word $\\varepsilon$).\nIn particular:\n- `^` (outside of a [character class](#characterClass) definition) matches the beginning of a string, - `$` matches the end of a string. **_Examples._** Consider the string $w$ = `a123b` - the regex `\\d+` matches $w[1 .. 3)$: `123` - the regex `^\\d+` has no match in $w$ - the regex `\\d+$` has no match in $w$ **_Hint._** These two special characters are widely used, in particular for string validation: an input word $w$ belongs to the language described by a regex $e$ iff there is a match for the regex `^`$e$`$` in $w$. Besides, if this is the case, then the best first match is also the longest possible match. **_Example._** In the string $w$ = `ab`: - the best first match for `a|ab` is $w[a .. 1)$: `a` - the best first match for `^(a|ab)$` is $w[a .. 2)$: `ab` The special character `\\b` matches any \"natural language word\" boundary (i.e. beginning or end). **_Example._** Consider the string $w$ = `User Alice797 is 55 years old` - The best first match for `\\d+` in $w$ is $w[10 .. 13)$: `797` - The best first match for `\\d+\\b` in $w$ is $w[10 .. 13)$: `797` - The only match for `\\b\\d+` in $w$ is $w[17 .. 19)$: `55` - The only match for `\\b\\d+\\b` in $w$ is $w[17 .. 19)$: `55` Group # A **group** in a regex is the content of a pair of parentheses. Groups allow capturing subsegments of a matched segment.\n**_Example._** Consider the regex: $e$ = `a(b|c)d` and the word $w = $`abd` There is only one match for $e$ in $w$ (namely $w$ itself). _Within this match_, the subsegment captured by the group `(a|b)` is $w[1 .. 2)$: `b`. Groups in a regex are (totally) ordered based on the position of their opening parenthesis.\n**_Example._** In the regex `a(([\\d]*)(a|b))` - Group number 1 is `(([\\d]*)(a|b))` - Group number 2 is `([\\d]*)` - Group number 3 is `(a|b)` Exercise Use the regex validation tool [regex101](https://regex101.com) to write a regex with a group that matches what is inside a pair of opening and a closing HTML tags. For instance, in the word $\\qquad\\qquad$`My Title Hello` the group should match `My Title` and `Hello` Possible solution `\u003e([^\u003c]*)\u003c/` Backreference # A group can be referenced _within_ a regex, with `\\`$n$, where $n$ is the group number. If the reference appears _after_ the group, this is called a **backreference**. **_Example._** - In the regex `a(b|c)d\\1q`, the backreference `\\1` refers to the group `(b|c)` - In the regex `(a(b|m))d\\2m`, the backreference `\\2` refers to the group `(b|m)` **_Evaluation._** Let $e$ be a regex with backreferences. Consider the expression $e'$ identical to $e$, but where each backreference is replaced with the group that it references. Then a match for $e$ is a match for $e'$ where each group and its copy capture segments with identical words. **_Example._** The regex `(a|b)\\1` is equivalent to `aa|bb` Exercise Which words does the following regex match? $\\qquad\\qquad$`((\\d)_\\2)@\\1` Solution . - `1_1@1_1`, - `2_2@2_2`, - `3_3@3_3`, - etc. **_Note._** Regexes with backreferences go beyond the expressivity of traditional regular expressions, meaning that they can describe languages that are _not_ [regular](http://localhost:41071/docs/background/sections/regular/#language). "},{"id":30,"href":"/docs/interfaces/sections/java_interfaces/","title":"Java interfaces","section":"Interfaces","content":" Java interfaces # A Java interface is a programming interface with additional (object-oriented) features.\nSyntactically, a Java interface is similar to a class. But (in its simplest form), it contains no code. Instead, it specifies the behavior of some methods (which are implemented in some classes).\nExamples # The implementation of our game contains an interface called Snapshot, which describes what a game snapshot is. This interface specifies (among others) a method called getSizeOfReinforcement, as follows:\npublic interface Snapshot { ... /** * Returns the number of units that will enter the board if reinforcement * is called for the input player. */ int getSizeOfReinforcement(Player player); ... } Note that this description contains no code.\nA Java interface acts not only as documentation, but also as a contract : any (non-abstract) class that implements this interface must implement all methods declared in the interface (otherwise the program will not compile).\nA Java interface can be used to specify how two components of a system communicate (before the interface is even implemented!). For instance, the Snapshot interface specifies which information must be provided by our backend to the component in charge of displaying the game on screen.\nThe name of an interface can be used as a reference type (similarly to the name of a class). For instance, the Snapshot interface also specifies a method\nBoard getBoard(); which must return an object of type Board. And Board is itself an interface, which specifies the information needed to draw the game board (units, position, etc).\nHere is for instance a fragment of the Board interface:\n/** * Board for an ongoing game. * This is a two-dimensional grid. * * Tile coordinates are natural numbers and start at 0. * The top left tile has coordinates (0,0). */ public interface Board { ... /** * Returns true if the input coordinates are within the board\u0026#39;s boundaries */ boolean areValidCoordinates(int rowIndex, int columnIndex); /** * Removes the unit standing at the input coordinates, and does nothing * if there is none. */ void removeUnit(int rowIndex, int columnIndex) throws CoordinatesOutOfBoardException; ... } Finally, the interface DisplayManager specifies a method that can be called (e.g. from the backend) to draw a Snapshot on screen (together with a message):\npublic interface DisplayManager { ... /** * Displays the input snapshot on screen, as well as the input message. */ void drawSnapshot(Snapshot snapshot, String message); ... } Observe that these interfaces only specify what classes should implement, not how. In other words, these interfaces specify how components can communicate without exposing unnecessary implementation details.\nWhen to use a Java interface? # Technically, Java interfaces are not needed in a project. But they can make collaboration within a team of developers significantly easier. In particular:\nAn interface is a convenient way to expose what is needed to interact with your code, while hiding the details of your implementation. For instance, the method drawSnapshot (mentioned above) can be called to draw a snapshot on screen, without knowing how this method is implemented.\nAs a contract, an interface allows two programmers to work independently, ensuring interoperability between the methods and/or components that they are respectively developing.\nInheritance # An interface in Java can extend another interface, like a class can extend another class, with the same keyword extends.\nHowever, Java interfaces support multiple inheritance (whereas java classes do not). This means that an interface A can extend two interfaces B and C even if B and C do not extend each other.\nImplementing an interface # In Java, the keyword implements is used to indicate that a class implements an interface. For instance:\npublic class SnapshotImpl implements Snapshot { ... } **_Note._** It is good practice to avoid a class and an interface with the same name (even if they describe the same objects). To differentiate them, you may for instance use the suffix `Impl`, as illustrated above. Consider a class _C_ that implements an interface _I_ : - if _C_ is abstract, then it **_can_** implement some of the methods declared in _I_ - if _C_ is not abstract, then each method declared in _I_ **_must_** be implemented in _C_ (or some superclass of _C_ ), otherwise the program will not compile. Exercise The program represented by the following diagram does not compile. Can you see why? ![](/img/diagrams/plantuml/abstract_inherit.svg) Solution The class `Butterfly` does not implement the method `sleep`. \u003e **_Note._** \u003e In this example, the class `Butterfly` inherits an implementation of `boost` (from `AbstractUnit`), and [overrides](http://localhost:41071/docs/objects/sections/methods/#overriding) it. \u003e This is _not_ an error. Since Java interfaces support multiple inheritance, a Java class can implement several interface that do not extend each other.\nFor instance, the class Unicorn could implement an interface Animal and another interface ImaginaryCreature, even though none of these two interfaces extends the other (not all animals are imaginary, and not all imaginary creatures are animals). This would be declared as follows:\npublic class Unicorn extends MobileUnit implements Animal, ImaginaryCreature { ... } Exercise The program represented by the following diagram does not compile. Can you see why? ![](/img/diagrams/plantuml/multiple_inherit.svg) Solution The class `Unicorn` does not implement the method `hide`. Interfaces vs abstract classes # In theory, Java\u0026rsquo;s interfaces and abstract classes serve different purposes:\nabstract classes are meant to factorize code (i.e. avoid redundant code), whereas interfaces are meant to document code and act as a contract. However, in practice, they have partially overlapping features, which may be confusing.\nIn particular:\nan abstract class can have abstract methods, which behave similarly to interface methods (with the additional constraint that an abstract method must be implemented by at least one subclass). Since Java 8 (2014), interfaces can carry code, in so-called default methods. This feature was introduced for backward compatibility reasons, but arguably contradicts the meaning of the term \u0026ldquo;interface\u0026rdquo;. A benefit of default methods (i.e. methods implemented in interfaces) is that they allow multiple inheritance of implemented methods (since interfaces allow multiple inheritance), which is not possible with classes. For this reason, some authors (like Joshua Bloch) recommend using default methods instead of abstract methods. However, a program where interfaces play the role of abstract classes may be confusing for less experienced Java developers.\nFor this course, we chose to present Java interfaces from a more traditional (pre-Java 8) perspective, because this perspective is arguably easier to understand, and because this is still the dominant usage of Java interfaces. However, for your project, feel free to deviate from this model if you think that this is appropriate (in particular if you need multiple inheritance).\n"},{"id":31,"href":"/docs/build/sections/layout/","title":"Layout","section":"Build automation","content":" Layout # The standard directory layout # By default, a Maven project is expected to comply with the so-called \u0026ldquo;standard directly layout\u0026rdquo;.\n**_Warning._** We restrict here the layout to files and folders that you are likely to use in your project. A comprehensive description can be found [here](https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html). ```bash âââ pom.xml âââ README.md âââ src â âââ main â â âââ java â â â âââ ... â â âââ resources â â âââ ... â âââ test â âââ java â â âââ ... â âââ resources â âââ ... ... ``` Here is the intended purpose of these files and directories (all paths are from the root of the project):\nfile or directory content pom.xml Maven configuration for the project README or README.md (human readable) description of the project src/main/java source code of the project src/main/resources resources for the project (e.g. configuration files, images, etc.) src/test/java source code for unit tests src/test/resources resources for unit tests (e.g. data) **_Note._** By default, the content of the `src/main/resources` directory is automatically included in a [jar](http://localhost:41071/docs/build/sections/packaging/#jar) generated with Maven. **_Hint._** Your IDE can generate this folder structure (together with a minimal `pom.xml` file). For instance, with IntelliJ, click on `File/New/Project`, and then select \"Maven\" as the \"Build system\": ![](/img/build/maven_project.png) **_Hint._** In some cases, a folder structure and `pom.xml` file that are tailored to a certain framework (like JavaFX or JSP) can be generated. This is called a **_maven archetype_**. The target directory # When building a Maven project, some files and directories are generated.\nBy default, the directory called target (at the root of the project) contains the output of the build, in particular:\nthe bytecode (i.e. .class files), the generated .jar file(s), if any. **_Hint._** Since it is automatically generated, the `target` directory can be safely deleted. Maven and Git # The pom.xml file should usually be committed.\nHowever, the following should not be committed (i.e. should be ignored via .gitignore):\nthe target directory, any other content generated during the build (e.g. generated source code, etc.). "},{"id":32,"href":"/docs/recursion/sections/nary/","title":"N-ary recursion","section":"Recursion","content":" N-ary recursion # **_Definition._** A recursive method that is _not_ linear recursive uses **n-ary recursion**. Specific cases include:\nbinary recursion if a method performs up to two recursive calls each time it is executed, ternary recursion if it performs up to three recursive calls each time it is executed, etc. **_Examples._** The algorithm seen [earlier](#printFiles) to print all files in a folder uses n-ary recursion. All the binary tree algorithms seen [earlier](#binaryTrees) use binary recursion. Divide and conquer # The **divide-and-conquer** paradigm is a variation of the methodology seen [earlier](#methodology) to solve a problem recursively. In the divide-and-conquer approach, the smaller inputs $I_1$, .., $I_k$ usually have (nearly) the _same size_. Divide-and-conquer has been instrumental in discovering efficient solutions to pervasive computational problems. Well-known examples include:\nthe Karatsuba algorithm for multiplying two numbers, the Strassen algorithm for matrix product, Mergesort for (stable) sorting. Example: Mergesort # Mergesort is one of (many) algorithms commonly used to sort an array, i.e. to solve the following problem:\nInput: an array $A$\nOutput: a sorted array with the same elements as $A$\nObservation. As we saw already, the array can be of any type (int, String, City, Unit, etc.), and the sorting criterion can be any total preorder over this type.\nThe Mergesort algorithm may be summarized as follows: - **_(Base case)._** If $A$ has size $1$, then return it ($A$ is already sorted). - **_(Inductive case)_**. Otherwise: - _(divide):_ partition $A$ into its left half $A_1$ and its right half $A_2$, - _(solve):_ sort $A_1$ and sort $A_2$ (recursively), - _(combine):_ merge (the sorted versions of) $A_1$ and $A_2$. Here is a naive implementation, in pseudocode:\n// Returns a sorted array that contains the same elements as A. Type[] mergesort(Type[] A) { // Base case: the input array has size 1, it is already sorted. if(A.length == 1){ return A } // Inductive case (the input array has size \u0026gt; 1) // Compute the middle index (rounded down) int middleIndex = (A.length - 1) / 2 // Copy the left half of A into a new array Type[] leftHalf = copy(A[0 .. middleIndex]) // Sort it leftHalf = mergesort(leftHalf) // Copy the right half of A into a new array Type[] rightHalf = copy(A[middleIndex + 1 .. A.length - 1]) // Sort it rightHalf = mergesort(rightHalf) // merge the two sorted halves return merge(leftHalf, rightHalf) } **_Warning._** This implementation is suboptimal (some arrays can be reused). We only used it to keep the explanation simple. Exercise To complete this algorithm, implement (in pseudocode) the auxiliary method ```java Type[] merge(Type[] A, Type[] B) ``` that takes as input two sorted arrays `A` and `B`, and returns a sorted array that contains their values. Try also to write it in such a way that the overall Mergesort algorithm is [stable](http://localhost:41071/docs/abstractdatatypes/sections/sorting/#stable). Possible solution Iterate over `A` and `B` in parallel: - if `A[0]` (resp. `B[0]`) is smaller than `B[0]` (resp. `A[0]`), then: - add `A[0]` (resp. `B[0]`) to the output array, and - repeat with `A[1]` and `B[0]` (resp. `A[0]` and `B[1]`), - etc. - when reaching the end of `A` (resp. `B`), add the remaining elements of `B` (resp. `A`) to the output array. More precisely: ```java Type[] merge(Type[] A, Type[] B){ // Output array Type[] C = new Type[A.length + B.length] // Index to iterate over A int a = 0 // Index to iterate over B int b = 0 // Index to iteratate over C int c = 0 // while we have not reached the end of A or B while (a \u003c A.length \u0026\u0026 b \u003c B.length) { if(A[a] \u003c= B[b]) { C[c] = A[a] a++ } else { C[c] = B[b] b++ } // If we reached the end of A, if(a == A.length){ // append all remaining elements of B to the output array. append(B, b, C, c) } else // Otherwise we reached the end of B. // So append all remaining elements of A to the output array. append(A, a, C, c) } } append (Type[] D, int d, Type[] C, int c) { while (d \u003c D.length){ C[c] = D[d] d++ } } ``` **_Merge sort in action._** You can find visual illustrations of the execution of merge sort online. For instance [this animation](https://imgur.com/gallery/HU2tfzo), or [this (more accurate) one](https://willrosenbaum.com/blog/2022/merge-sort/). **_Observation._** Merge sort is a [stable](http://localhost:41071/docs/abstractdatatypes/sections/sorting/#stable) sorting algorithm. Tree and graph traversal # Earlier in this chapter, we used different algorithms to traverse a binary tree, where nodes were instances of the following class:\nOne of these algorithms was the so-called \u0026ldquo;pre-order traversal\u0026rdquo;:\ntraverse(Node root){ // inductive case only (do nothing in the base case) if (root != null){ print(root.label) traverse(root.leftChild) traverse(root.rightChild) } } This algorithm naturally generalizes to trees where nodes may have more than two children. Nodes in such a tree can be represented as instances of the following class:\nAnd the algorithm becomes:\ntraverse(Node root){ if (root != null){ print(root.label) foreach child in root.children { traverse(child) } } } This algorithm can in turn be adapted to traverse a graph. More precisely, to explore all nodes reachable (directly or transitively) from a given source node in the graph.\n**_Warning._** When applied to a graph, the algorithm above: - may not terminate (if the graph contains a loop), - may process some nodes multiple times (even if the graph is acyclic). In order to avoid this, a common technique consists in labelling nodes in a graph with an additional boolean attribute visited, which indicates whether a node has already been visited during a traversal:\nAnd the algorithm becomes:\ntraverse(Node root){ if (root != null \u0026amp;\u0026amp; !root.visited){ root.visited = true print(root.label) foreach child in root.children { traverse(child) } } } **_Terminology._** This approach is often called **depth-first** exploration of a graph. Exercise Consider the following graph. ![](/img/graphs/graph_labeled.svg) What does the above algorithm print for input node A, assuming that the children of each node are sorted in label's alphabetical order? Solution A B D F C E Minimax/Maximin # Minimax is a recursive algorithm with applications in games, robotics, decision making, etc.\nMinimax may be easier to explain in the context of a turn-based zero-sum game, i.e. a game (like chess or tic tac toe) where players compete with each other (as opposed for instance to a collaborative game).\nZero-sum two player games can be used to model decisions that minimize risk, assuming that the worst will happen if it can. In other words, one the two players represents the decision maker, and the other player represents \u0026ldquo;bad luck\u0026rdquo;.\nNumerous extensions and heuristics have been devise for Minimax. Here we only focus on the algorithm in its basic form.\nWinning strategy # Let Alice and Bob be our two players.\nExercise Consider the following state of a game of tic-tac-toe, where Alice plays with crosses, and is the next person to play. ![](/img/tictactoe/state/tictactoe.svg) Assuming that Alice plays optimally, she already has won the game. Can you see why? Solution ![](/img/tictactoe/state/tictactoe.svg) If Alice plays top right or bottom right, then _regardless_ of Bob's action, she can complete a line or a diagonal as her next move. Let us generalize this observation.\nIn a turn-based two player game, a sequence of moves can be viewed as a **list** of board states, whose head is the initial board state. The **tree** that consists of all these lists represents all possible sequences of moves from the initial board state. **_Example._** In the following tree, the root is a board state (of an imaginary game), and each branch represents a possible sequence of moves. Alice's possible moves are the green edges, and Bob's possible moves are the red edges. The numbers on the leaves represent the payoff for Alice: - 9 if this is a winning state for Alice, and - 0 if this is a winning sate for Bob. ![](/img/graphs/minimax.svg) **_Warning._** In such a tree, several nodes may represent the _same_ board state (e.g. in a chess game, where different sequences of moves may lead to the same board state). Exercise In the tree above, determine whether Alice has already won the game (assuming that she plays optimally). Solution The answer is yes, if Alice selects the right child of the tree's root. **_Observation._** In both exercises above, we were able to determine that Alice had already won the game, _regardless_ of Bob's actions. Intuitively, this holds iff: - _there is_ a move for Alice such that, - for _every_ possible move of Bob, - _there is_ a move for Alice such that, - for _every_ possible move of Bob, - ... - either: - _there is_ a move for Alice that produces a winning state for Alice, or - _every_ possible move of Bob produces a winning state for Alice. This observation leads to a natural recursive definition.\n**_Terminology._** In our tree, let us assuming that the root has depth $0$. We call a node **existential** if its depth is even, and **universal** if its depth is odd. Existential (resp. universal) nodes are the ones selected by Alice (resp. Bob).\n**_Definition._** A node $n$ is a **winning node** (for Alice) if: - it represents a winning state for Alice, or - $n$ is existential and _some_ child of $n$ is a winning node, or - $n$ is universal and _all_ children of $n$ are a winning nodes. Naive algorithm # Let us start with a naive algorithm for games where:\nthe height of the tree is finite (as opposed to chess for instance, where there can be infinite sequences of moves). each leaf is a winning state for either Alice or Bob (as opposed to tic-tac-toe for instance, where there can be a draw). In such a game, every node of the tree must be a winning node for Alice or for Bob. In order to determine this, we can intuitively propagate labels up the tree:\nLet us assume that nodes in our tree are instance of the following class Node.\n**_Notation._** If `nodes` is an array of nodes and `f` a function that takes a node as argument, we will use: $\\qquad$ `[ f(n) | n in nodes ]` for the array obtained by applying `f` to each element of `nodes`. **_Observation._** Let `n` be a non-leaf node whose children have label `0` or `9`. Then: - _there exists_ a child of `n` with label `9` iff `max [ c.label | c in n.children ] = 9` - _every child_ of $n$ is labeled with `9` iff `min [ c.label | c in n.children ] = 9` Using this observation and our definition of a winning node (above), we can write the following recursive algorithm (in pseudocode):\n// existential node int maxiMin(Node n){ // base case (leaf node) if(n.children.length == 0){ return n.label } // inductive case: return the largest label computed for a child return max [ miniMax(c) | c in n.children ] } // universal node int miniMax(Node n){ // base case (leaf node) if(n.children.length == 0){ return n.label } // inductive case: return the least label computed for a child return min [ maxiMin(c) | c in n.children ] } In this algorithm, the method maxiMin (resp. miniMax) takes an existential (resp. universal) node as input, and returns:\n9 if this node is a winning node for Alice, or 0 if this node is a winning node for Bob. **_Note._** The code can be (slightly) factorized by writing a unique recursive method, with an additional boolean argument that indicates whether the input node is existential or universal. This is usually how the algorithm is presented. We used two methods instead for didactic reasons. Application # In practice, in order to apply this algorithm to a game, the class Node is unnecessary. Instead, we can use:\nan auxiliary procedure that compute the \u0026ldquo;children of a node\u0026rdquo;, i.e. takes as argument a board state, and enumerates all board states that can be reached from it in one move. an auxiliary procedure score that determines whether a \u0026ldquo;node\u0026rdquo; is a leaf, and its \u0026ldquo;label\u0026rdquo; if it is a leaf. This procedure takes a state as input, and determines whether this state is a winning state for Alice or Bob. Then Alice can decide her next move by calling miniMax(s) for each successor state s of the current state, and select any of the states with the highest score.\nGeneralization # Arbitrary weights # The Minimax algorithm can be generalized to scenarios where a leaf node may not represent a winning state for Alice or Bob. For instance, in order to model tic-tac-toe, we may label some leaves with the value 4 for a draw.\nMore generally, any function score that assigns a score to a node can be used, as long as it assigns a maximal value to a winning state for Alice, and a minimal value to a winning state for Bob.\nThe algorithm is unchanged.\nLarge or infinite trees # **_Warning_** Minimax can be _prohibitive_ for games with an important tree height (since the number of board states to explore may grow exponentially with the height of the tree). Besides, Minimax does _not_ terminate if the tree has infinite branches (for instance in a chess game). This is why the tree of game states is usually explored up to a certain depth.\n**_Example._** [Deep Blue]() (the first program that defeated a chess world champion) was only looking 12 moves ahead. The algorithm becomes:\n// existential node int maxiMin(Node n, int depth){ // base case if(n.children.length == 0 | depth == 0){ return score(n) } // inductive case: return the largest label computed for a child return max [ miniMax(c, depth - 1) | c in n.children ] } // universal node int miniMax(Node n, int depth){ // base case if(n.children.length == 0 | depth == 0){ return score(n) } // inductive case: return the least label computed for a child return min [ maxiMin(c, depth - 1) | c in n.children ] } Optimization # A variety of optimization techniques have been proposed for Minimax (e.g. alpha-beta pruning). They are beyond the scope of this course.\n"},{"id":33,"href":"/docs/project/sections/board_game/","title":"Option 2: board game","section":"Project","content":" Option 2: board game # The second project option available to you consists in developing a video game with mechanics analogous to the ones of Might \u0026amp; Magic: Clash of Heroes or Legend of Solgard.\nStudents who choose this option you will be provided:\na basic graphical user interface (GUI) that they can reuse and/or customize, examples during lectures that they may adapt to their project. Requirements # The minimal requirement to submit this project is a player vs player game playable on a single machine.\nBut of course, you are free to go further and add your own features. Among other possibilities, you could for instance:\nimplement new mechanics (e.g. a rock-paper-scissor logic for unit encounters, events that may affect the board, etc.), make the game deterministic (i.e. eliminate randomness), create units with specific behaviors, implements scripted encounters (\u0026ldquo;boss fights\u0026rdquo;), implement a story, character progression, etc., develop a player vs bot mode, etc, **_Note._** If you choose the last options in the list above (player vs bot), then you may benefit from an algorithm seen in the chapter on [recursion](http://localhost:41071/docs/recursion/sections/nary/#minimax). Besides, if several groups choose this option, we may organize a competition between bots (provided that they play by the same rules). Guidelines # GUI # The source code for the GUI can be cloned from GitHub. The project is designed so that:\nyou can develop a fully functional game (player vs player or player vs bot) by focusing exclusively on the backend (i.e. the mechanics of the game), without modifying the GUI. backend and frontend are decoupled. Communication between frontend and backend is specified via Java interfaces. It revolves around the notion of a game snapshot, which contains all the information needed to describe a state of the game (equivalently, you can think of a snapshot as a save state). In particular, snapshots are independent of a specific GUI.\nFor instance, a method is available that allows you to pass a snapshot to the GUI component. When you call this method, the snapshot will be drawn on screen, replacing the previous one (if any).\nAs input, your code receives the next action of the active player (for instance, delete the unit present on a specific tile). These are again specified by an interface. Your code should react accordingly: modify the current snapshot, and then send it the GUI component for display.\nThe README.md file (at the root of the project) contains a description of the different components and interfaces, as well as building instructions, and explains where your code could fit. Read it carefully before you start working on your project!\n**_Note._** You are of course free to modify the interfaces that come with the project. But this may require modifying the implementation of the GUI. **_Disclaimer._** By design, the project compromises _performance_ for _simplicity_ and _modularity_. This is _not_ how a resource intensive game would be implemented. More generally, this exercise is not meant to teach game development, but general-purpose programming and problem solving. "},{"id":34,"href":"/docs/multithreading/sections/thread/","title":"Process vs thread","section":"Multithreading","content":" Thread # Process # A **process** is (usually) an instance of a computer program. Processes can interact in several ways. In particular:\na process may spawn another process, a process may wait for another process to terminate or release a lock on some resource. Thread # A process consists of one or several **threads**. Conceptually, a thread is similar to a process. In particular, threads can interact analogously to processes.\nHowever, threads are designed to allow heavier concurrency, thanks a shared address space and fast context switches.\nin Java # A Java program is normally executed by a single process.\nThis process consists of several threads. Among these, the main thread is the one that executes the main method of the application (e.g. the method public static void main of the main class).\nProgramming with threads # Many high-level programming languages (like Java) allow creating threads and assigning tasks to these threads. However, by default, a program does not specify whether two threads are executed on the same core (i.e. concurrently) or not (i.e. in a parallel fashion). The decision is usually left to the operating system, and depends on the resources available at runtime.\nIn particular, if a program allows two threads to be executed concurrently (on the same core), then it also allows them to be executed in parallel (on different cores).\n"},{"id":35,"href":"/docs/input/sections/read/","title":"Reading from and writing to a file in Java","section":"I/O and serialization","content":" Reading from and writing to a file in Java # There are numerous ways to read from or write to a file in Java, using either native of external libraries.\nWe highlight here some of the simplest ones (syntactically), even though they may not be the most efficient.\nWe also restrict our scope to:\nreading and writing text (but Java also offers multiple ways to read or write sequences of bytes), reading sequentially and writing by appending (but some classes like RandomAccessFile allow accessing any position in a file). Reading # Reading a text file line by line # Here is one way to process the content of a text file line by line:\ntry (BufferedReader reader = Files.newBufferedReader(Path.of(\u0026#34;path/to/file.txt\u0026#34;))){ String line = reader.readLine(); while (line != null){ System.out.println(line); line = reader.readLine(); } } catch (IOException e) { throw new RuntimeException(e); } Reading an entire text file # Alternatively, if the file is small, its whole content can be stored as a list of strings (one per line), as follows:\nList\u0026lt;String\u0026gt; lines = null; try (Stream\u0026lt;String\u0026gt; stream = Files.lines(Path.of(\u0026#34;path/to/file.txt\u0026#34;))){ lines = stream.toList(); } catch (IOException e) { throw new RuntimeException(e); } Or even as a single string:\nString text; try { text = Files.readString(Path.of(\u0026#34;path/to/file.txt\u0026#34;)); } catch (IOException e) { throw new RuntimeException(e); } Splitting # The method String.split can be used to decompose a string into an array of substring, based on some delimiter. For instance, in a csv file, each line can be decomposed using a comma (,), as follows:\nString line = \u0026#34;Alice,Bob,Carol\u0026#34;; // Contains [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Carol\u0026#34;] String[] names = line.split(\u0026#34;,\u0026#34;); We will see in the chapter dedicated to regular expressions that more expressive delimiters can be used.\nReading with a scanner # The class Scanner is a versatile tool that allows reading from the standard input, but also from a file.\nWe refer to last year\u0026rsquo;s course for an overview.\nWriting # **_Warning._** In Java, methods that write an (underspecified) line separator produce a (sequence of) character(s) that depends on the operating system running the program: `\\r\\n` on Windows, and `\\n` on most other modern operating systems. This is the case in all three examples below, with the methods BufferedWriter.newLine, PrintWriter.println and Files.write.\nWriting incrementally # A common way to write to a file consists in using a BufferredWriter. For instance:\ntry(BufferedWriter writer = new BufferedWriter(new FileWriter(\u0026#34;path/to/file.txt\u0026#34;))){ writer.write(\u0026#34;Hi\u0026#34;); writer.newLine(); } catch (IOException e) { e.printStackTrace(); } A PrintWriter offers additional methods to easily format the output, such as print, println or printf, analogous to the methods of the standard output stream System.out. It is often used as a wrapper around another writer, for instance a BufferedWriter:\ntry(PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(\u0026#34;path/to/file.txt\u0026#34;)))){ writer.println(\u0026#34;Hi\u0026#34;); } catch (IOException e) { e.printStackTrace(); } Writing an entire list # The method Files.write can be used to write all elements of a list to a file (one per line):\nList\u0026lt;String\u0026gt; strings = List.of(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;); try { Files.write( Path.of(\u0026#34;path/to/file.txt\u0026#34;), strings ); } catch (IOException e) { throw new RuntimeException(e); } Writing a single string # The method Files.writeString can be used to write a single string to a file\ntry { Files.writeString( Path.of(\u0026#34;path/to/file.txt\u0026#34;), \u0026#34;foo\u0026#34; ); } catch (IOException e) { throw new RuntimeException(e); } Note that this will overwrite the content of the file.\nInstead, in order to append a string to a file, a third argument can be added to the method Files.writeString:\ntry { Files.writeString( Path.of(\u0026#34;path/to/file.txt\u0026#34;), \u0026#34;foo\u0026#34;, StandardOpenOption.APPEND ); } catch (IOException e) { throw new RuntimeException(e); } "},{"id":36,"href":"/docs/abstractdatatypes/sections/set/","title":"Set","section":"Abstract data types","content":" Set # The abstract data type **set** simulates a (usually finite) mathematical [set](http://localhost:41071/docs/background/sections/set_tuple_map/#set). A set may expose the following methods:\nadd: adds an element to the set if it was not present already (and returns true iff this was the case), contains: checks whether an element belongs to the set, size: returns the cardinality of the set, etc. **_Warning._** A set provides no guarantee on the _order_ of its elements! in Java # Java provides an interface Set with 8 native implementations (i.e. different classes that implement this interface). The most commonly used are HashSet and TreeSet.\nThe interface Set extends the interface Collection.\nSyntax # Here are code snippets for a few simple operations specified in the interface Set.\nCreate a Set and populate it: City milan = new City(\u0026#34;Milan\u0026#34;, 20100); City florence = new City(\u0026#34;Florence\u0026#34;, 50100); // Creates an empty set of cities Set\u0026lt;City\u0026gt; mySet = new HashSet\u0026lt;\u0026gt;(); // Adds Milan to the set mySet.add(milan); // Adds Florence to the set mySet.add(florence); // Tries to add Milan again; this has no effect. mySet.add(milan); // Creates a set identical to the previous one, // but which cannot be modified Set\u0026lt;City\u0026gt; myOtherSet = Set.of(milan, florence); Remove an element from a set: mySet.remove(milan); Check whether a set contains an certain element: // Outputs false System.out.println(mySet.contains(milan)); // Outputs true System.out.println(mySet.contains(florence)); Retrieve the cardinality of a set: // Outputs 1 System.out.println(mySet.size()); Compute the intersection of two sets: mySet.add(new City(\u0026#34;Bologna\u0026#34;, 40100)); mySet.retainAll(myOtherSet); // Outputs 1 System.out.println(mySet.size()); Add a collection to a set: mySet.addAll(myOtherSet); // Outputs 2 System.out.println(mySet.size()); For more operations, consult the Javadoc of the interface Set.\nDuplicates # By definition, a set cannot contain identical elements. But what does \u0026ldquo;identical\u0026rdquo; mean for two objects?\nIn Java, the method equals is (implicitly) used to determine whether two elements added to a Set should be considered identical.\n**_Warning._** [Recall](http://localhost:41071/docs/objects/sections/comparing/#hashCode) that the method `equals` should be overridden _together with_ the method `hashCode` (more on this later). This is essential for a `HashSet` to behave as expected (more on this [later](http://localhost:41071/docs/datastructures/sections/hash/#hashCode)). For instance, consider a naive implementation of the class City, which does not override equals (or hashCode):\npublic class City { String name; int zipcode; public City(String name, int zipCode){ this.name = name; this.zipCode =zipCode; } } Recall that every class inherits a default implementation of equals (and hashCode), from the class Object. According to this default implementation, equals behaves like ==.\nCity trento = new City(\u0026#34;Trento\u0026#34;, 38100); City trentoAgain = new City(\u0026#34;Trento\u0026#34;, 38100); Set\u0026lt;City\u0026gt; cities = Set.of(trento, trentoAgain); // Outputs 2 System.out.println(cities.size()); Now consider a class SmartCity identical to City, but that overrides equals (andhashCode) in the standard way:\npublic class SmartCity { String name; int zipCode; public SmartCity(String name, int zipCode) { this.name = name; this.zipCode = zipCode; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; SmartCity smartCity = (SmartCity) o; return zipCode == smartCity.zipCode \u0026amp;\u0026amp; name.equals(smartCity.name); } @Override public int hashCode() { return Objects.hash(name, zipCode); } } A Java Set cannot contain two instances of SmartCity that have the same name and zip code:\nSmartCity smartTrento = new SmartCity(\u0026#34;Trento\u0026#34;, 38100); SmartCity smartTrentoAgain = new SmartCity(\u0026#34;Trento\u0026#34;, 38100); Set\u0026lt;SmartCity\u0026gt; smartCities = new HashSet\u0026lt;\u0026gt;(); smartCities.add(smartTrento); smartCities.add(smartTrentoAgain); // Outputs 1 System.out.println(smartCities.size()); // Outputs false System.out.println(smartCities.add(smartTrentoAgain)); **_Note._** Recall that many native Java classes already override `equals` (and `hashCode`). Among others: `String`, boxed types (like `Integer`), but also most implementations of the `Collection` interface (including `HashSet`). **_Note._** Some implementations of `List` also provide methods that perform \"set-like\" comparisons. E.g. `containsAll`, `removeAll`, `retainAll`, etc. Again, we refer to the [Javadoc](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/List.html) for an exhaustive documentation. Usage # Implementations of the ADT set can be useful in a variety of contexts. For instance, remove duplicates from an array (assuming that the order of elements in the array is irrelevant):\nInteger[] myArray = new Integer[]{1,2,3,1,2}; List\u0026lt;Integer\u0026gt; tuple = List.of(myArray); Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(tuple); // Outputs 3 System.out.println(set.size()); Or check whether two lists contain the same (distinct) elements:\nSmartCity mantova = new SmartCity(\u0026#34;Mantua\u0026#34;, 46100); SmartCity bergamo = new SmartCity(\u0026#34;Bergamo\u0026#34;, 24100); List\u0026lt;SmartCity\u0026gt; list1 = List.of(mantova, bergamo); List\u0026lt;SmartCity\u0026gt; list2 = List.of(bergamo, mantova); Set\u0026lt;SmartCity\u0026gt; set1 = new HashSet\u0026lt;\u0026gt;(list1); Set\u0026lt;SmartCity\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(list2); // Outputs true System.out.println(set1.equals(set2)); Exercise In our game, a same unit may sit on two (or more) adjacent tiles. Consider an implementation where: - a board consists of a two-dimensional array with type `Unit[][]`, and - if a same unit sits on several tiles, then these tiles contain (a reference to) the same (instance of) `Unit`, and - `Unit` does _not_ override `equals` (neither do its sub or superclasses). Write a Java method `int countUnits(Unit[][] board)` that takes such an array as input, and returns the number of different units on the board. For instance, with the board below as input, the method should return 5. ![](/img/adt/miniboard.png) Possible solution ```java int countUnits(Unit[][] board) { Set units = new HashSet\u003c\u003e(); for (Unit[] row : board) { for (Unit unit : row) { if (unit != null) { units.add(unit); } } } return units.size(); } ``` Exercise What dose the following program output? ```java Set aSet = new HashSet\u003c\u003e(); Set anotherSet = new HashSet\u003c\u003e(); aSet.add(1); aSet.add(2); anotherSet.add(1); Set"},{"id":37,"href":"/docs/background/sections/set_tuple_map/","title":"Set, tuple, function","section":"Background","content":" Set, tuple, function # Set # A **set** can be informally viewed as a collection of elements with _no duplicate_ and in _no specific order_. **_Definition._** The **power set** $\\mathcal{P}(S)$ of a set $S$ is the set of all subsets of $S$. For instance, if \\(S = \\{a,b\\}\\) , then\n\\( \\qquad \\qquad \\qquad \\mathcal{P}(S) = \\Big\\{ \\{\\}, \\{a\\}, \\{b\\}, S \\Big\\} \\) **_Note._** An alternative notation for the power set of $S$ is $2^S$. If $S$ is finite with size $n$, then $\\mathcal{P}(S)$ has size $2^n$.\n**_Definition._** The **product** $S_1 \\times S_2$ of two sets $S_1$ and $S_2$ is the set of all pairs $(s_1, s_2)$ such that $s_1 \\in S_1$ and $s_2 \\in S_2$. For instance, if \\( S_1 = \\{a,b\\} \\) and \\(S_2 = \\{1,2,3\\} \\) , then\n\\(\\qquad \\qquad S_1 \\times S_2 = \\{ \\ (a,1), (a,2), (a,3), (b,1), (b,2), (b,3)\\ \\} \\) **_Notation._** Similarly to $S_1 \\times S_2$: - $S_1 \\times S_2 \\times S_3$ denotes the set of all triples $(s_1, s_2, s_3)$ such that $s_1 \\in S_1, s_2 \\in S_2$ and $s_3 \\in S_3$. - $S_1 \\times .. \\times S_k$ denotes the set of all tuples $(s_1, .., s_k)$ such that $s_1 \\in S_1, .., s_k \\in S_k$. **_Notation._** - $S^2$ is sometimes used for $S \\times S$, - $S^3$ is sometimes used for $S \\times S \\times S$, - etc. Tuple # **_Definition._** A **tuple** (or **list**) over a set $S$ is a finite sequence of (possibly repeated) element of $S$. For instance:\n- \\(()\\) is the 0-tuple or empty tuple,\n- \\((a)\\) is a 1-tuple,\n- \\((b,a)\\) is a 2-tuple or pair,\n- \\((a,b,a)\\) is a 3-tuple or triple, etc.\nFunction # A **function** (or **map**) $f\\colon X \\to Y$ maps each element $x$ of its **domain** $X$ to an element $f(x)$ of its **codomain** $Y$. A function \\(f\\colon X \\to Y\\) can equivalently be viewed as a set of \u0026ldquo;key-value\u0026rdquo; pairs, namely the set of all pairs \\((x, f(x))\\) such that \\(x \\in X\\) .\n**_Definition._** A function $f\\colon X \\to Y$ is: - **injective** is no two elements in its domain have the same image, i.e. if for all $ x_1, x_2 \\in X$, $\\qquad \\qquad x_1 \\neq x_2$ implies $f(x_1) \\neq f(x_2)$ - **surjective** if every element in its codomain has a preimage, i.e. if $\\qquad \\qquad$ for each $y \\in Y$, there is a $x \\in X$ such that $y = f(x)$. - **bijective** if it is injective and surjective. A function \\(f\\) with finite domain can be represented extensionally, as a set of pairs of the form\n\\(\\qquad \\qquad x \\mapsto f(x)\\) For instance, the function \\(f\\colon \\{a,b,c\\} \\to \\mathbb{N}\\) defined by\n\\(\\qquad f(a) = 1,\\ f(b) = 1\\) and \\(f(c) = 2\\) can be represented as the set:\n\\( \\qquad \\{\\ a \\mapsto 1,\\ b \\mapsto 1,\\ c \\mapsto 2\\ \\} \\) Multiset # A **multiset** (or **bag**) is a finite collection of elements in no specific order, _possibly with duplicates_. Square bracket are sometimes uses to distinguish a multiset from a set or a tuple. For instance:\n\\( [b,b,c] \\) and \\( [a,b] \\) are multisets (the latter is also a set).\n\\( [a,b,a] \\) and \\( [b,a,a] \\) denote the same multiset.\nExercise A multiset can equivalently be viewed as one of the mathematical objects seen above. Can you identify which one? Solution A multiset can be viewed as a function that maps each element to its number of occurrences. For instance, the multiset [a, b, a] can be viewed as the function { a â¦ 2, b â¦ 1 } "},{"id":38,"href":"/docs/stream/sections/init/","title":"Source","section":"Streams in Java","content":" Source # Collection # A stream can be created out of a Java Collection with the instance method stream.\n**_Example._** ```java List units = getUnits(); units.stream(); ``` If the collection has a predictable order of iteration (e.g. if the collection is a List), then the elements will appear in this order in the stream.\nTo create a stream out of the entries of a map, we can use the instance method Map.entrySet (which returns a set).\n**_Example._** ```java Map map = getMap(); map.entrySet().stream(); ``` Array # A stream can be created out of a Java array with the static method Arrays.stream.\n**_Example._** ```java Unit[] units = getUnits(); Arrays.stream(units); ``` Generate a stream with indices # An IntStream is a stream of int (see the dedicated section on streams with primitive numeric types). An IntStream can for instance be created with the static method IntStream.range, as follows:\n**_Example._** ```java // Contains [0, 2] List evenIntegers = IntStream.range(0, 4) // produce the stream (0, 1, 2, 3) .filter(i -\u003e i % 2 == 0) // retain even numbers .toList(); ``` This can be used to iterate over a list or array while keeping track of the elements\u0026rsquo; positions.\n**_Example._** ```java Unit[] units = getUnits(); List evenUnits = IntStream.range(0, units.length) .filter(i -\u003e i % 2 == 0) .mapToObj(i -\u003e units[i]) .toList(); ``` However, for this usage, external libraries offer more natural options. For instance, the StreamEx library can create a map from index to entry in an array, and generate a stream out of the entries of this map (analogous to the set of entries produced by Map.entrySet).\nUnit[] units = getUnits(); List\u0026lt;Unit\u0026gt; evenUnits = EntryStream.of(units) .filterKeyValue((index, unit) -\u0026gt; index % 2 == 0) .values() .toList(); } To use StreamEx in a Maven project, declare this dependency:\n\u0026lt;dependencies\u0026gt; ... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;one.util\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;streamex\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.8.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; ... \u0026lt;/dependencies\u0026gt; or in a Gradle project:\nimplementation group: \u0026#39;one.util\u0026#39;, name: \u0026#39;streamex\u0026#39;, version: \u0026#39;0.8.2\u0026#39; "},{"id":39,"href":"/docs/intro/sections/lecturers/","title":"Teaching staff","section":"This course","content":" Teaching staff # Julien Corman will teach the lectures and one lab.\nAlbulen Pano will teach the other lab.\nOffice hours # If you need additional help with the content of the course, the assignments and/or your project, you can ask for office hours with any (or both) of us.\nThese appointments must be scheduled via email (follow the links above for our email addresses).\n"},{"id":40,"href":"/docs/multithreading/sections/simple/","title":"A simplified view","section":"Multithreading","content":" A simplified view # From an abstract perspective, in order to understand the properties of a program that allows concurrency and/or parallelism, it can be convenient to assume an simplified, ideal machine that:\nhas an unlimited number of cores, and relies exclusively on parallelism. Parallel computation # In this section, we borrow the simple syntax for parallel computation used in the popular textbook Introduction to algorithms.\nThis syntax extends imperative pseudocode with three keywords:\nspawn sync parallel These keywords correspond to primitives that are available (in one form or another) in many programming languages (like Java) or libraries (like OpenMP) that support multithreading.\nspawn and sync # the keyword spawn allows the current thread to create a child thread and execute an instruction (possibly a method call) in this child thread, as follows: $\\qquad$ spawn \u0026lt;myInstruction\u0026gt;\nthe keyword sync forces the current thread to pause its execution, until all the threads that it has spawned have terminated. **_Example._** The following method: - takes as arguments two vectors with integer values, - computes the sum of the values of each vector, and returns the sum of the two results. ```java int aggregate (int[] v1, int[] v2){ int s1 = spawn sumElts(v1) int s2 = sumElts(v2) print(\"waiting\") sync return s1 + s2 } int sumElts(int[] v){ int sum = 0 for(int i = 0; i \u003c v.length; i++){ sum += v[i] } print(\"done\") return sum } ``` In this method: - the statement `spawn sumElts(v1)` creates a child thread and executes the auxiliary method `sumElts` (with argument `v1`) in this child thread. - the statement `sync` forces the main thread to wait for termination of the child thread. There is _no guarantee_ on which of the two threads will first finish executing the method `sumElts`. As a result, depending on the runtime environment, the program may output either ``` done done waiting ``` or ``` done waiting done ``` parallel # The keyword parallel is associated to a loop. Intuitively, it allows the environment to execute iterations of this loop in different threads (for instance, the library OpenMP provides such a keyword).\nThe (abstract) syntax is the following:\nfor parallel (\u0026lt;myIterationCondition\u0026gt;){ \u0026lt;myLoopBody\u0026gt; } **_Example._** We can parallelize the auxiliary method `sumElts` in our previous example by adding the keyword `parallel` to the loop: ```java int sumElts(int[] v){ int sum = 0 for parallel (int i = 0; i \u003c v.length; i++){ sum += v[i] } return sum } ``` The keyword parallel can be replaced with combinations of spawn and (if needed) sync.\n**_Example._** The example that immediately precedes can be rewritten as follows: ```java int sumElts(int[] v){ sumRec(v, 0, v.length - 1) } int sumRec(int[] v, int i, int max){ // base case if(i = max){ return v[i] } // inductive case. // compute the middle index int mid = (i + max) / 2 // recursive call on the left half, in a separate thread int leftSum = spawn sumRec(v, i, mid) // recursive call on the right half (in the current thread) int rightSum = sumRec(v, mid + 1, max) sync return leftSum + rightSum } ``` **_Definition._** The **span** of a program's execution is the maximal number of instructions that it has to perform _sequentially_. Exercise Let $f(n)$ measure the span of the program above, where $n$ is the size of the input vector. Assuming a number of cores $\\ge n$, which asymptotic class of cost functions does $f$ belong to? Solution $f$ is in $\\Theta(\\log n)$ **_Note._** In this example, it may be tempting to spawn the threads sequentially, rather than recursively. However, the benefit of parallelization is lost: ```perl int sumElts(int[] v){ int sum = 0 for (int i = 0; i \u003c v.length; i++){ spawn sum += v[i] sync } return sum } ``` in Java # Creating a thread # A thread in Java is an instance of the class java.lang.Thread.\nThere are many alternative syntaxes to create an instance of this class. We cover here two of the most common ones.\nInstantiate Runnable # The constructor Thread(Runnable runnable) takes as input an instance of the interface Runnable.\nRunnable is a functional interface, whose method is called run and has type\n$\\qquad$ void $\\to$ void\nTherefore it can be instantiated with a callback method (that takes no argument and returns no value).\n**_Example._** ```java Thread myThread = new Thread( () -\u003e { System.out.println(\"Hello World\"); } ); ``` Alternatively, in order to pass an argument to the thread, we can create a class that implements Runnable, and pass the argument to the constructor if this class.\n**_Example._** ```java public class MyRunnable implements Runnable { String arg; public MyRunnable(String arg){ this.arg = arg; } @Override public void run() { System.out.println(arg); } } ``` $\\qquad$ ```java Thread myThread = new Thread(new MyRunnable(\"Hello\")); ``` Create a subclass of Thread # Instead of instantiating Runnable, we can create a subclass of Thread ans instantiate it.\npublic class MyThread extends Thread { String arg; public MyThread(String arg){ this.arg = arg; } @Override public void run() { System.out.println(arg); } } $\\qquad$\nThread myThread = new MyThread(\u0026#34;Hello\u0026#34;); An advantage of this approach (compared to the previous one) is that we do not need to create an instance of Runnable. A drawback is that the class MyThread cannot extend another class (since Java does not support multiple inheritance). Spawning a thread # The instance method Thread.start spawns a thread.\n**_Example._** ```java Thread myThread = new Thread( () -\u003e { System.out.println(\"Hello\"); } ); myThread.start(); ``` Waiting for a thread to terminate # Java provides a functionality analogous to the sync keyword seen above, but with a more fine-grained control.\nCalling the instance method Thread.join for a thread $t$ causes the current thread to pause its execution until termination of $t$.\nThread myThread = new Thread( () -\u0026gt; { myExpensiveMethod(); } ); myThread.start(); try { // wait for the spawned thread to terminate myThread.join() } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(\u0026#34;Job done, resuming execution\u0026#34;); Loop # In Java, an operation analogous to the parallel keyword is the instance method Stream.parallel that we saw in the dedicated section\n**_Example._** ```java List vector = getVector(); vector.stream() .parallel() .filter() .map() .forEach(); ``` In this case, the whole stream pipeline is executed in a concurrent fashion (possibly parallel if some cores are available).\nBy default, a pool of threads of size $k - 1$ is used, where $k$ is the number of cores of the CPU (but a larger pool can be manually configured).\nPause # The static method Thread.sleep can be used to pause the current thread for a certain amount of time.\n**_Example._** ```java System.out.ptinln(\"Going to sleep...\"); // sleep for 4 seconds Thread.sleep(4000); System.out.ptinln(\"Waking up\"); ``` **_Warning._** The method `Thread.sleep` does not guarantee that the input sleeping duration is precisely enforced. Therefore sleeping times should _not_ be used to synchronize the activity of two threads. "},{"id":41,"href":"/docs/abstractdatatypes/sections/map/","title":"Associative array","section":"Abstract data types","content":" Associative array # An **associative array** (or **dictionary** or **map**) simulates a [function](http://localhost:41071/docs/background/sections/set_tuple_map/#function) with _finite_ domain. A associative array exposes at least the following methods:\nlookup (or get) takes a key as input, and returns the value for this key (if any). insert (or put ) inserts a pair (key, value). If an entry for this key was already present, then overwrites its value. remove (or delete) deletes the entry for a given key (if any). **_Note._** Associative arrays are pervasive in programming. Many data structures have been designed over the years whose main purpose is to implement associative arrays efficiently (notably hash maps and a variety of search trees). in Java # Java provides an interface Map with 19 native implementations (i.e. 19 different classes that implement this interface). The most commonly used is HashMap.\n**_Note._** The interface `Map` does _not_ extend the interface `Collection`. Map is a generic type with two parameters: one for the type of its keys, and one for the type of its values. For instance, a map from integers to strings has type Map\u0026lt;Integer, String\u0026gt;.\nSyntax # Here are code snippets for a few operations specified in the interface Map.\nCreate a Map and populate it: City milan = new City(\u0026#34;Milan\u0026#34;, 20100); City florence = new City(\u0026#34;Florence\u0026#34;, 50100); // Create an empty map whose keys are zipCodes, // and whose values are cities Map\u0026lt;Integer, City\u0026gt; zipCodeToCity = new HashMap\u0026lt;\u0026gt;(); // Adds { 20100 â¦ milan } to the map zipCodeToCity.put(milan.zipCode, milan); // Adds { 50100 â¦ florence } to the map zipCodeToCity.put(florence.zipCode, florence); // Creates a map identical to the previous one, // but which cannot be modified Map\u0026lt;Integer, City\u0026gt; anotherMap = Map.of( milan.zipCode, milan, florence.zipCode, florence ); Retrieve the value associated to a given key: // Contains (a reference to) Milan City aCity = zipCodeToCity.get(20100); // Has value null City anotherCity = zipCodeToCity.get(88888); Check whether a map contains an entry for a given key: // Outputs true System.out.println(zipCodeToCity.containsKey(20100)); // Outputs false System.out.println(zipCodeToCity.containsKey(88888)); Retrieve the number of entries in a map: // Outputs 2 System.out.println(zipCodeToCity.size()); Overwrite an entry in a map: City bologna = new City(\u0026#34;Bologna\u0026#34;, 40100); // Replaces { 20100 â¦ milan } with { 20100 â¦ bologna } zipCodeToCity.put(20100, bologna); // Outputs 2 System.out.println(zipCodeToCity.size()); // Adds { 40100 â¦ bologna } to the map zipCodeToCity.put(bologna.zipCode, bologna); // Outputs 3 System.out.println(zipCodeToCity.size()); // Replaces { 20100 â¦ bologna } with { 20100 â¦ milan } zipCodeToCity.put(milan.zipCode, milan); Retrieve the set of keys of a map (note that this is an instance of Set\u0026lt;E\u0026gt;, where E is the type of the keys) Set\u0026lt;Integer\u0026gt; keys = zipCodeToCity.keySet(); // Outputs true System.out.println(keys.contains(20100)); Retrieve a collection with all values in the map, in no specific order (may contain duplicates): Collection\u0026lt;City\u0026gt; values = zipCodeToCity.values(); // Outputs true System.out.println(values.contains(milan)); // Outputs 3 System.out.println(values.size()); // Adds { 99999 â¦ milan } to the map zipCodeToCity.put(99999, milan); // Outputs 4 System.out.println(zipCodeToCity.values().size()); Wrap the map into a set of entries (a.k.a. \u0026ldquo;key-value\u0026rdquo; pairs): // Creates a \u0026#34;wrapper\u0026#34; Set around the map. // No data is duplicated. // Each element of this set has type Entry\u0026lt;Integer,City\u0026gt; Set\u0026lt;Entry\u0026lt;Integer,City\u0026gt;\u0026gt; entries = zipCodeToCity.entrySet(); // Iterates over entries for (Entry\u0026lt;Integer, City\u0026gt; entry : entries){ // Holds the entry\u0026#39;s key Integer zipCode = entry.getKey(); // Holds the entry\u0026#39;s value City city = entry.getValue(); } Again, we refer to the Javadoc for an exhaustive documentation.\nComparing keys # The identity of two keys in Java is determined by the method equals, analogously to what we saw already for the identity of two elements in a set.\nFor instance, consider once again the classes City and SmartCity that we used in the section on sets, where SmartCity overrides equals (and hashCode), whereas City does not:\nCity trento = new City(\u0026#34;Trento\u0026#34;, 38100); City trentoAgain = new City(\u0026#34;Trento\u0026#34;, 38100); Country italy = new Country(\u0026#34;Italy\u0026#34;); Map\u0026lt;City, Country\u0026gt; cityToCountry = new HashMap(); cityToCountry.put(trento, italy); cityToCountry.put(trentoAgain, italy); // Outputs 2 System.out.println(cityToCountry.size()); SmartCity smartTrento = new SmartCity(\u0026#34;Trento\u0026#34;, 38100); SmartCity smartTrentoAgain = new SmartCity(\u0026#34;Trento\u0026#34;, 38100); Map\u0026lt;SmartCity, Country\u0026gt; smartCityToCountry = new HashMap(); smartCityToCountry.put(smartTrento, italy); smartCityToCountry.put(smartTrentoAgain, italy); // Outputs 1 System.out.println(smartCityToCountry.size()); Usage # Exercise Write a Java method `int countRepeatedChars(char[] chars)` that takes as input an array of characters, and returns the number of characters that appear multiple times in this array. For instance, for the input array `[a,e,b,c,b,a,d,b]`, the method should return `2`. Possible solution ```java int countRepeatedChars(char[] chars) { // key: character // value: number of occurrences of this character Map charToOcc = computeCharToOccMap(chars); // return value int repeatedChars = 0; // count the number of entries in the map with a value \u003e 1 for (Integer occ : charToOcc.values()){ if(occ \u003e 1){ repeatedChars++; } } return repeatedChars; } /** * Auxiliary method. * * Returns a map that associates each character to its number of occurrences */ private Map computeCharToOccMap(char[] chars) { // create an empty map Map charToOcc = new HashMap\u003c\u003e(); // for each character in the input array for (char character : chars) { // retrieve the number of occurrences seen so far for this character Integer occ = charToOcc.get(character); // increment this number by 1 occ = (occ == null) ? 1 : occ + 1; // update the map for this character charToOcc.put(character, occ); } return charToOcc; } ``` Exercise Consider the implementation of our game that we used previously in our exercise with sets. Assume in addition that the class `Unit` has an attribute `color` of type `String`. Write a (Java) method `void printNumberOfUnitsByColor(Unit[][] board)` that takes a board as input, and prints the number of unit of each color, in any order. For instance, for the board below: ![](/img/adt/miniboard.png) The method could print: ``` blue: 1 yellow: 2 red: 2 ``` Possible solution ```java void printNumberOfUnitsByColor(Unit[][] board) { // key: a color // value: the set of all units with this color Map"},{"id":42,"href":"/docs/env/sections/backup/","title":"Backup","section":"Development environment","content":" Backup # Make sure that your work does not depend on your laptop. You should be able to resume your work easily on another computer if your laptop gets lost, damaged, etc.\nYou should also be able to recover your data if you accidentally delete it from your hard drive.\nWhich information to back up # As a priority, make sure that there exist copies (outside of your hard drive) of:\nyour passwords (and possibly identifiers), and your own work (code, reports, slides, notes, CV, etc.). These copies may be stored on the cloud, an external disk, another computer, etc.\nOptionally, you may also back up:\nconfiguration files present in your home folder. For development purposes, you generally do not need to back up:\ngenerated content (back up the code that generates it instead), large datasets (these should not be present on your laptop to start with), programs (they can be reinstalled). How to back up # Password managers # For passwords, your password manager may provide an online backup option. Other password managers (like pass) may let you synchronize your passwords via git.\nGit # For your own work and/or configuration files, git can be an option.\nA git repository is (roughly speaking) a directory that can be synchronized across different machines (see the dedicated chapter of this course for an introduction to git). For instance, you may create a (private) git repository for each course that you follow and/or each project that you start. Several providers (GitHub, Gitlab, Bitbucket, etc.) can host copies of your (public or private) repositories on the cloud for free.\nThe benefits are:\nthe possibility to recover any previous state of your work (a git repository stores the whole history of modifications made to it), fine-grained control over your backup: for instance, you can use a \u0026quot;.gitignore\u0026quot; file to exclude files or subfolder that do not need to be backed up. **_Note._** If a git repository is a subfolder of another git repository, then the inner repository is not included in the history of the outer one. **_Limitation._** Git is _not suited_ to large volumes of data (more than 1 GB in the same repository). This is usually not an issue for your own work (code, notes, reports, etc.) as a student in computer science. However, git should _not_ be used to back up large collections of images, audio files, videos, etc. Other solutions # Numerous programs allow you to back up (part of) the content of your hard drive. One of them may be pre-installed on your operating system.\nYou can back up content on a device that you own (e.g. on an external hard drive), or on the cloud. In the latter case, some fee may apply (depending on the volume of data).\nRestore points # Programs such as System restore (Windows), macOS Recovery (macOS) or Timeshift (Linux) allow you to create snapshots of your system (typically for what lives outside of your home folder), and revert your system\u0026rsquo;s state to one of these snapshots.\nThis can be useful in case of a corrupted system. However, it may be difficult to determine at which point in time the system was \u0026ldquo;healthy\u0026rdquo;. Note also that in such scenarios, a fresh re-install may be a simpler to restart on a sane basis.\n"},{"id":43,"href":"/docs/datastructures/sections/tree/","title":"Binary search tree","section":"Data structures","content":" Binary search tree # A Binary Search Tree (BST) is another data structure used to store an associative array (e.g. a Java Map).\n**_Definition._** A BST is a binary tree such that each node's label is: - larger than its left child's label (if any), and - smaller than its right child's label (if any). Equivalently, a BST is a binary tree whose nodes are sorted w.r.t. in-order traversal.\nAssociative array as a binary search tree # Recall that an associative array is a finite set of key-value pairs. Again, let us assume keys have type $K$, and that values have type $V$.\nWhen a BST implements an associative array:\neach node of the tree stores a key-value pair, nodes are sorted by key, using their natural order or any other total order over $K$. Lookup # Recall that the lookup operation for an associative array:\ntakes as input a key $k$, and returns the value $v$ associated to this key (if any). Over a BST, this operation is similar to performing a binary search in a sorted array:\nIf the tree is empty, then it (trivially) does not contain an entry with key $k$.\nOtherwise, compare $k$ with the label $l$ of the tree\u0026rsquo;s root:\nif $k = l$, then return the value stored in the root, if $k \u0026lt; l$, then repeat over the left subtree, if $k \u0026gt; l$, then repeat over the teft subtree. Or in pseudocode:\nV lookup(Node root, K key){ // base case: empty tree if(root == null){ return null; } // inductive case if(root.key == key){ return root.value; } if(root.key \u0026gt; key){ return lookup(root.leftChild); } return lookup(root.right); } Exercise If $h$ is the height of the tree, what is the asymptotic worst case running time of this algorithm, expressed as a function of $h$? Solution $\\Theta(h)$ Insert and delete # Insertion and deletion can also be performed in linear time in the height $h$ of the tree.\nBenefits # Recall that a hash table does not preserve the order of an associative array\u0026rsquo;s keys (at best, we saw that Java\u0026rsquo;s LinkedHashMap preserves the order of insertion).\nInstead, keys in a BST remain sorted, after any number of insertion or deletion operations. Besides, any total order can be used for this purpose (e.g. alphabetical order if the keys are strings).\nSelf balancing trees # A **self balancing tree** is a specific type of BSTm which guarantees that the tree remains balanced after an insertion or deletion, meaning that its height remains _logarithmic_ in the number of nodes. Two widely used types of self balancing trees are red-black trees and AVL trees.\nin Java # The class java.util.TreeMap implements the interface java.util.Map as a red-black-tree.\nThe class java.util.TreeSet implements the interface java.util.Set as a red-black-tree.\nBy default, keys are sorted according to their natural order. But both classes provide an alternative constructor that accept an arbitrary Comparator over $K$.\n"},{"id":44,"href":"/docs/simplify/sections/boolean/","title":"Boolean conditions","section":"Simplifying code","content":" Boolean conditions # A complex boolean sub-expression in the scope of a negation can be difficult to read and/or debug.\n**_Example._** The two following expressions are equivalent (but the latter is arguably easier to read): $$ \\neg(\\neg(a \\lor b) \\land \\neg (\\neg c \\lor d)) $$ $$ a \\lor b \\lor \\neg c \\lor d $$ Simplification # In a Boolean expression, negations can always be \"pushed\" inside parentheses, as follows: - base case: - $\\neg (x = y)$ becomes $x \\neq y$ - $\\neg (x \\le y)$ becomes $x \u003e y$ - $\\neg (x \u003e y)$ becomes $x \\le y$ - etc. - inductive case: - $\\neg (\\phi \\land \\psi)$ becomes $\\neg \\phi \\lor \\neg \\psi$ - $\\neg (\\phi \\lor \\psi)$ becomes $\\neg \\phi \\land \\neg \\psi$ Exercise Simplify the following Java condition: ```java !(x != y \u0026\u0026 ( !x.hasNext() || !y.hasNext() || x.next() != y.next())) ``` Solution The expression is of the form ```java !(x != y \u0026\u0026 ) ``` So we can transform it into ```java x == y || ! ``` Next observe that ```java ! ``` is ```java !( !x.hasNext() || !y.hasNext() || x.next() != y.next()) ``` which can be transformed into ```java x.hasNext() \u0026\u0026 y.hasNext() \u0026\u0026 x.next() == y.next() ``` So the whole expression becomes ```java x == y || ( x.hasNext() \u0026\u0026 y.hasNext() \u0026\u0026 x.next() == y.next() ) ``` "},{"id":45,"href":"/docs/git/sections/config/","title":"Configuration","section":"git","content":" Configuration # Text editor # In some situations (commit without message, merge commit, etc.), git automatically opens a text editor to let you type a message.\nBy default, on most operating systems, git open vi for this purpose. I you have never used vi, we recommend selecting another text editor.\nYou can do this by running:\ngit config --global core.editor \u0026lt;myEditor\u0026gt; where \u0026lt;myEditor\u0026gt; is the command that launches your text editor (for instance notepad for Notepad, open -e -W -n for TextEdit , gedit for gedit, sublime for Sublime Text, etc.)\nProtocol # Git hosting services (such as GitHub) usually support two alternative protocols for sharing content with a remote: https and ssh.\nssh is generally recommended.\nSSH key # To share content via ssh, you need a cryptographic key, often called an \u0026ldquo;ssh key\u0026rdquo; (in practice, this is an RSA key).\nYou may already have an ssh key on your machine. By default, ssh keys are located in the dot folder \u0026lt;homeFolder\u0026gt;/.ssh (or \u0026lt;homeFolder\u0026gt;\\.ssh on Windows).\nIf this folder exists, then it should contain (at least) one file with extension .pub. Such a file contains a public RSA key. You can share this key with a git host for authentication.\nIf you do not have an SSH key on your machine, then you can generate one by running\nssh-keygen in a terminal (Linux and macOS) or in the Windows Power Shell (Windows). If you accept the default location, this command will generate the .ssh folder and a key.\nIn order to add a public key to your GitHub account, log in to GitHub, select \u0026ldquo;Settings\u0026rdquo;, then \u0026ldquo;SSH and GPG keys\u0026rdquo;. Click on the \u0026ldquo;New SSH key\u0026rdquo; button, give a name to your key, and paste your public key (i.e.the content of the file with extension .pub) in the field \u0026ldquo;Key\u0026rdquo;.\nFor more details, you can for instance consult this page.\nHTTPS credentials # If you prefer, you can interact with (most) git hosting services via HTTPS. By default, this requires entering your credentials for each interaction with a remote.\nTo avoid this, you may consider caching your GitHub credentials in Git.\n"},{"id":46,"href":"/docs/build/sections/pom/","title":"Configuration file","section":"Build automation","content":" Configuration file # The Project Object Model (POM) # The root folder of a Maven project normally contains a configuration file called pom.xml. This file provides the information needed to identify and build the project.\n**_Hint._** Your IDE can generate the backbone of a `pom.xml` file (for instance, when creating a Maven project). For a basic Java project, the pom.xml file usually has the following structure:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- Artifact coordinates for the project --\u0026gt; \u0026lt;groupId\u0026gt; XXX \u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt; XXX \u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt; XXX \u0026lt;/version\u0026gt; \u0026lt;!-- Properties of the project --\u0026gt; \u0026lt;properties\u0026gt; ... \u0026lt;/properties\u0026gt; \u0026lt;!-- Dependencies of the project --\u0026gt; \u0026lt;dependencies\u0026gt; ... \u0026lt;/dependencies\u0026gt; \u0026lt;!-- Project build specification --\u0026gt; \u0026lt;build\u0026gt; ... \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; For instance, here is the skeleton of a minimal pom.xml file for a Java 17 project:\n\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- Artifact coordinates for the project --\u0026gt; \u0026lt;groupId\u0026gt;it.unibz.pp-23-24\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;myProject\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- Version of Java and character encoding --\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!-- No dependency --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- No build specification --\u0026gt; \u0026lt;build\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; Parent POM, super POM, effective POM # A POM can inherit properties from a parent POM, via so-called project inheritance. In addition, every POM implicitly inherits from the so-called super POM.\nIn case of conflict, the values specified in the child POM have precedence over those specified in the parent POM (analogously to inheritance of attributes in Java).\nThe **effective POM** of a project is the one induced by the project's POM and the properties that it inherits from other POMs. To display the effective POM of a project, from the root of this project, run:\nmvn help:effective-pom **_Note._** Inheritance of configuration (where a project-specific or user-specific configuration may partially overwrite a parent configuration) is not specific to Maven, but used by many programs. "},{"id":47,"href":"/docs/recursion/sections/correctness/","title":"Correctness","section":"Recursion","content":" Correctness # To check whether a recursive method is correct, it is (usually) sufficient to check that the two following two properties hold: 1. **_(Base case(s))._** The method is correct for the smallest possible inputs. 2. **_(Inductive case)._** For an arbitrary $n$: $\\qquad\\qquad$ _if_ the method is correct for all inputs of size $\\leq n$, _then_ it is correct for all inputs of size $n+1$. **_Example._** Consider the algorithm seen [earlier](#binaryTrees) to compute the sum of all nodes in a binary tree, if nodes are instance of the following class: ![](/img/diagrams/plantuml/nodeWithIntLabel.svg) ```java {linenos=true} int sum(Node root){ // base case if (root == null){ return 0 } // inductive case return root.value + sum(root.leftChild) + sum(root.rightChild) } ``` For the size $n$ of the input, we can use in this example the height of the tree (i.e. the length of its longest branch). Let use verify that our two properties hold: 1. **_(Base case)._** The sum of all labels in an empty tree is 0, so the method is trivially correct. 2. **_(Inductive case)._** Consider any natural number $n$, and any tree of height $n+1$, with root $r$. And let us assume that the method `sum` is correct for all trees of height $\\le n$. We need to show that under this assumption, the method is correct for the tree rooted in $r$. - Observe that the subtrees rooted in `r.left` and `r.right` have height $\\le n$. - So from our assumption, the two recursive calls (Line 6) to the method `sum` are correct, meaning that they return the sum of all values in each of the two subtrees. - Next, observe that the sum of all labels in our tree must be equal to the sum of all values in these two subtrees, plus the label of $r$. Which is precisely what the method returns. These two properties (1 and 2 above) provide an immediate proof by induction that the method is correct for all inputs.\n**_Proof._** Partition the set of all possible inputs by size, i.e. (assuming that inputs in our base case have size 0): - the set $S_0$ of all inputs of size $0$, - the set $S_1$ of all inputs of size $1$, - the set $S_2$ of all inputs of size $2$, - etc. In order to show that the method is correct, it is sufficient to show that it is correct for each $S_i$ (where $i \\in \\mathbb{N}$). Now let us assume that properties 1 and 2 hold, i.e.: 1. **_(Base case)._** **The method is correct for** $S_0$. 2. **_(Inductive case)._** For any $n$, $\\qquad\\qquad$ _if_ the method is correct for $S_0 \\cup S_1 \\cup ... \\cup S_n$, then it is correct for $S_{n+1}$. - We know that Property 2 holds for an arbitrary $n$. In particular, it holds for $n= 0$. In other words (replacing $n$ with $0$): 3. If the method is correct for $S_0$, then it is correct for $S_1$. So from Properties 1 and 3, we can infer: 4. **The method is correct for** $S_1$. $\\qquad$ - Next, consider the case where $n = 1$. From Property 2 still, we know (replacing $n$ with $1$) that: 5. If the method is correct for $S_0 \\cup S_1$, then it is correct for $S_2$. So from Properties 1 and 4 and 5, we can infer: 6. **The method is correct for** $S_2$. $\\qquad$ - etc. "},{"id":48,"href":"/docs/intro/sections/evaluation/","title":"Evaluation","section":"This course","content":" Evaluation # Evaluation for this course is based on:\nassignments: up to 30 points, a group project: up to 60 points, and an oral exam: up to 10 points. Your final grade is the sum of the above, multiplied by 0.3.\nAssignments # There will be 8 or 9 assignments for this course. These are standard programming exercises, related to notions seen during the lectures. The labs are (mostly) dedicated to these assignments.\nThe release of each assignment is announced via Teams. You will also find a link to the released assignments on the home page of this site.\nAssignments are submitted via GitHub classroom. You can submit an assignment multiple times (but only before its deadline).\n**_Note._** In order to submit your assignments (and your project), you will need a [GitHub](https://github.com/) account. If you do not have one already, please create one and communicate it to the lecturer, preferably via [Teams](https://teams.microsoft.com/l/team/19%3a5nIIq-TkfyJLi3capYBYZG42U0vNmUBTv31Ac7Gqf641%40thread.tacv2/conversations?groupId=b394eaa9-e55c-42ed-be0f-5be013ff2f03\u0026tenantId=92513267-03e3-401a-80d4-c58ed6674e3b). Make sure that you use a _single_ GitHub account for all your assignments and your project. Group project # Guidelines for the content of the project are in the dedicated chapter. We focus here on organization and evaluation.\nEach group must consist of 3 to 4 students. Groups should be decided by March 20, and communicated via mail to the lecturer.\nProjects are delivered via GitHub.\nGrades for a project are awarded individually, based on each student\u0026rsquo;s contribution. Students are expected to work on different computers. Make sure that:\neach student uses a different (and only one) GitHub account, and each student commits (via git) his/her own code. The project\u0026rsquo;s code is expected to apply techniques seen during the lectures, but only if relevant. Please do not add artificial functionalities to your project for the sole purpose of illustrating a certain technique.\nOral exam # The oral exam is individual.\nNo revision is needed.\nWe will ask you questions about your code and/or involvement in the project.\nFor instance:\nwhich design choices you made, which difficulties you encountered, the expected behavior of a certain method, how some portions of the code may be improved, etc. "},{"id":49,"href":"/docs/objects/sections/inheritance/","title":"Inheritance","section":"Objects and classes","content":" Inheritance # Subclass # In most (class-based) object-oriented languages, a class _A_ can **extend** another class _B_. In this case, _A_ is called a **subclass** of _B_. The intuitive meaning is inclusion between their respective sets of instances, i.e. every instance of A is also an instance of B (but the converse may not hold).\nThis can be paraphrased in English by \u0026ldquo;every A is a B \u0026ldquo;. For instance:\nevery banana is a fruit every square is a rectangle every rectangle is a geometric shape, etc. Transitivity # The \"extend\" relation is **transitive**, meaning that if _A_ extends _B_ and _B_ extends _C_, then _A_ extends _C_ (for any classes _A_, _B_ and _C_ ). For instance, from the above examples, one can infer that \u0026ldquo;every square is a geometric shape\u0026rdquo;.\nInheritance # Naturally, if _A_ is a subclass of _B_ then it **inherits** the properties of _B_. For instance, a rectangle has four right angles. Since every square is a rectangle, a square has four right angles as well.\nFactorizing code with a (possibly abstract) superclass # Inheritance can be used to avoid redundant code.\nDirect inheritance: illustration # Let us model the units of our game as objects.\nEach unit has:\na type (e.g. mage, unicorn, etc.), a color (at least in the original game), and a certain amount of health. The behavior and stats of a unit (e.g number of turns before attacking when combined, default health, etc.) are dictated by its type. So it makes sense to group units by type.\nFor instance, one can create a class Unicorn whose instances are all units of type unicorn. In Java:\npublic class Unicorn { String color; int health; int attackCountdown; public Unicorn(String color) { this.color = color; health = 1; attackCountdown = -1; } } **_Note._** We used the keyword `attackCountdown` in this example to indicate the number of turns before the unit attacks (and a special value of `-1` when it is not set to attack). But there are of course other ways to model this. **_Note._** In this example, we used the prefix `this.` for the attribute `color` only, because there is no ambiguity for the three other attributes. We can also create a class Butterfly on the same model\npublic class Butterfly { String color; int health; int attackCountdown; public Butterfly(String color) { this.color = color; health = 2; int attackCountdown = -1; } } Now consider a method encounter that manages an encounter between two units. Without inheritance, one would need to implement four versions of this method:\nunicorn vs unicorn, unicorn vs butterfly, butterfly vs unicorn, and butterfly vs butterfly. For instance, the first of these four methods could be implemented as follows:\nvoid encounter(Unicorn u1, Unicorn u2) { // save the initial value of the first unit\u0026#39;s health int copy = u1.health; u1.health -= u2.health; u2.health -= copy; } More generally, if the game has \\(n\\) types of units, then the code will contain \\(n^2\\) nearly identical encounter methods.\n**_Question._** Can we use inheritance in this example to avoid duplicate code (and how)? Observe that a unicorn and a butterfly (viewed as object) have identical attributes (a.k.a. \u0026ldquo;keys\u0026rdquo;), namely String color, int health, and int attackCountdown. So we can create a superclass of UnicornandButterflythat carries these attributes, and let the two subclasses inherit it. For instance, this superclass may be called Unit.\nHowever, we may also want every unit in the game to have a concrete type (like \u0026ldquo;unicorn\u0026rdquo; or \u0026ldquo;butterfly\u0026rdquo;), rather than being a generic \u0026ldquo;unit\u0026rdquo;. In Java, this can be achieved with the abstract keyword. This keyword ensures that our superclass cannot be directly instantiated (even though it can still have a constructor). For instance:\npublic abstract class Unit { String color; int health; int attackCountdown; public Unit(String color, int health) { this.color = color; this.health = health; int attackCountdown = -1; } } Because this class is abstract, the following code will not compile:\nUnit myUnit = new Unit(\u0026#34;green\u0026#34;, 2); Next, we can declare that Unicorn extends Unit, by using the Java keyword extends. We can also use the constructor of Unit within the constructor of Unicorn, with the Java keyword super.\n**_Note._** In Java (as opposed to C++ for instance), a class can only have _one_ immediate superclass, so the keyword `super` is never ambiguous. This yields:\npublic class Unicorn extends Unit { public Unicorn(String color) { super(color, 1); } } And we can proceed similarly for the class Butterfly.\nObserve that all the attributes are now carried by the superclass Unit. However, because they are inherited, these attributes can be accessed as if they were regular attributes of the subclass. For instance,\nUnicorn myUnit = new Unicorn(\u0026#34;green\u0026#34;); System.out.println(myUnit.health); outputs\n1 This allows us to write a generic encounter method, as follows:\nvoid encounter(Unit u1, Unit u2) { // save the initial value of the first unit\u0026#39;s health int copy = u1.health; u1.health -= u2.health; u2.health -= copy; } And this method can be used with unicorns and/or butterflies. For instance:\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); Butterfly myButterfly = new Butterfly(\u0026#34;yellow\u0026#34;); encounter(myUnicorn, myButterfly); } Transitive inheritance # In the example above, we assumed that all units have a color and can attack. What if we also want to create a type of unit called Wall that has no color and cannot attack? An instance of this class does not need the attributes color and attackCountdown.\nA quick solution here consists is setting attackCountdown to -1, and color to null. However, unnecessary attributes make code harder to understand, and such a design may not scale well if the game is extended with more units types.\nExercise Modify our model to accommodate for the class `Wall`, so that an instance of `Wall` only has the `health` attribute. Possible solution One solution (among others) is the following: 1. modify the class `Unit` so that it only carries the attribute `health`, 2. `Wall` extends `Unit`, 3. create an (abstract) subclass of `Unit` (for instance `MobileUnit`) that carries the other two attributes, 4. `Butterfly` and `Unicorn` extend `MobileUnit` (therefore they also extend `Unit`, by transitivity). ![](/img/diagrams/plantuml/abstract_inherit_complex.svg) Or in Java: ```java public abstract class Unit { int health; public Unit(int health) { this.heath = health; } } ``` ```java public class Wall extends Unit { public Wall() { super(5); } } ``` ```java public abstract class MobileUnit extends Unit { String color; int attackCountdown; public MobileUnit(String color, int health) { super(health); this.color = color; this.attackCountdown = -1; } } ``` ```java public class Unicorn extends MobileUnit { public Unicorn(String color) { super(color, 1); } } ``` and similarly for `Butterfy`. "},{"id":50,"href":"/docs/stream/sections/intermediate/","title":"Intermediate operations","section":"Streams in Java","content":" Intermediate operations # In a stream pipeline, an intermediate operation takes a stream as input, and produces another stream.\nStateless operations # A **stateless** intermediate operation processes each element of the input stream independently, and without the need to memorize information about previous elements in the stream. Stream.filter and Stream.map # These two instance methods allow specifying a stateless operation, via a callback method. We have already explained their behavior in detail in our initial pipeline example.\nStream.flatMap # This is another very useful instance method, which can produce several objects out a single object in the stream.\n**_Example._** Consider the following classes `City` and `Region`. ![](/img/diagrams/plantuml/two_classes.svg) Given as input a collection `regions` of regions, we can use the function `flatMap` to create a stream that consists of all cities in these regions, as follows: ```java regions.stream() .flatMap(r -\u003e r.cities.stream()) ``` For instance, the following method takes as argument a list of regions, and returns the zip codes of all cities in these regions, with the exceptions of the zip code of Bologna: ```java List allZipCodesButBologna(List regions) { return regions.stream() .flatMap(r -\u003e r.cities.stream()) .filter(c -\u003e !c.name.equals(\"Bologna\")) .map(c -\u003e c.zipCode) .toList(); } ``` Let us assume that the stream has type Stream\u0026lt;$\\mathit{T}$\u0026gt; (for instance, in our example, $\\mathit{T}$ is Region).\nThe method flatMap takes as argument a callback function of type\n$\\qquad T \\to$ Stream\u0026lt;$T\u0026rsquo;$\u0026gt;\nwhere $T\u0026rsquo;$ can be any type.\nIn this example, the callback function is\nr -\u0026gt; r.cities.stream() which has type\n$\\qquad$ Region $\\to$ Stream\u0026lt;City\u0026gt;\nLet us name this callback function $f$.\nThe method flatMap returns a Stream\u0026lt;$\\mathit{T\u0026rsquo;}$\u0026gt; (e.g. in this example a Stream\u0026lt;City\u0026gt;). This stream is the concatenation of all streams $f(a)$ such that $a$ belongs to the original stream.\nStateful operations # **Stateful** intermediate operations are the ones that are not stateless. We list here some of the most useful ones.\nStream.distinct # This instance method produces an identical stream, but without duplicates.\n**_Example._** ```java Listlist = List.of(2, 1, 1, 3, 1, 2); // Contains [2, 1, 3] List ouputList = list.stream() .distinct() .toList(); ``` For a stream of objects, duplicates are identified based on Java\u0026rsquo;s object equality (i.e. as specified by the method Object.equals).\n**_Reminder._** If a class overrides the method `Object.equals`, then it should also override `Object.hashCode` (and these two implementations should be consistent with each other). Stream.sorted # This instance method outputs a sorted stream. It can be called with or without a Comparator.\nIts behavior (with and without a comparator) is analogous to the methods Arrays.sort and Collection.sort.\n**_Example._** ```java Listlist = List.of(2, 1, 3, 1, 2); // Contains [1, 1, 2, 2, 3] List ouputList = list.stream() .sorted() .toList(); ``` **_Hint._** Recall that `Comparator\u003c`$T$`\u003e` is a [functional interface](http://localhost:41071/docs/lambda/sections/type/#comparator), whose (only) method is `compare(`$T$ `e1`, $T$ `e2)`. As a result, it can be implemented with an anonymous method. For instance, the following method removes duplicates in a list of cities, and returns it sorted: ```java List sortDistinctCitiesByName(List cities){ return cities.stream() .distinct() .sorted((c1, c2) -\u003e c1.name.compareTo(c2.name)) .toList(); } ``` Stream.limit # This instance method takes as argument an integer $n$, and outputs the $n$ first elements of the stream.\n**_Example._** ```java Listlist = List.of(2, 1, 3, 1, 2); // Contains [2, 1, 3, 1] List ouputList = list.stream() .limit(4) .toList(); ``` Stream.skip # This instance method takes as argument an integer $n$, and outputs the stream without its $n$ first elements.\n**_Example._** ```java Listlist = List.of(2, 1, 3, 1, 2); // Contains [3, 1, 2] List ouputList = list.stream() .skip(2) .toList(); ``` "},{"id":51,"href":"/docs/lambda/sections/lambda/","title":"Lambda expression","section":"Callback methods and lambda expressions","content":" Lambda expression # In certain programming languages like Java, C#, C++ or JavaScript, the term lambda expression (sometimes called closure expression) is used to denote an anonymous method with a certain syntax.\nThe term is a (loose) reference to lambda calculus, a model of computation exclusively based on function composition and application.\nSyntax in Java # A Java method\n\u0026lt;ReturnType\u0026gt; myMethod (\u0026lt;Type 1\u0026gt; \u0026lt;argument 1\u0026gt;, .., \u0026lt;Type n\u0026gt; \u0026lt;argument n\u0026gt;){ \u0026lt;Body\u0026gt; } can be written anonymously as the lambda expression:\n(\u0026lt;Type 1\u0026gt; \u0026lt;argument 1\u0026gt;, .., \u0026lt;Type n\u0026gt; \u0026lt;argument n\u0026gt;) -\u0026gt; { \u0026lt;Body\u0026gt; } For instance, the method:\nint division (int x, int y){ return x / y; } is equivalent to the lambda expression\n(int x, int y) -\u0026gt; { return x / y ; } However, a more concise syntax can often be used:\nArguments # If the types of the arguments can be inferred by the compiler (which is most often the case), then they can be omitted.\n**_Example._** ```java (int x, int y) -\u003e { ... } ``` can often be written ```java (x, y) -\u003e { ... } ``` If the method has exactly one argument and its type is omitted, then parentheses can also be omitted.\n**_Example._** ```java (x) -\u003e { ... } ``` can always be written ```java x -\u003e { ... } ``` If the method takes no argument, then parentheses are mandatory.\n**_Example._** ```java () -\u003e { ... } ``` Body # If:\nthe body of a lambda expression consists of a single statement, and the return type of this lambda expression (or void if there is none) can be inferred by the compiler (which is most often the case), then the semicolon (;), curly braces ({ and }) and return keyword (if any) can be omitted.\n**_Example._** ```java (x, y) -\u003e { return x / y ; } ``` can often be written ```java (x, y) -\u003e x / y ``` "},{"id":52,"href":"/docs/objects/","title":"Objects and classes","section":"Docs","content":" Objects and classes # This chapter introduces some basic notions of (class-based) object-oriented programming.\n"},{"id":53,"href":"/docs/generics/sections/subtype/","title":"Subtype","section":"Generic programming","content":" Subtype # As we saw in the previous sections, the purpose of generic programming is to write abstract code while enforcing type constraints. As a result, when we write a program that uses a generic type (e.g. a native Java Collection), we need to make sure that our code complies with these type constraints.\nIn some situations, this requires reasoning about types and their hierarchy (notably for programs that use callback methods).\nIn this section, we briefly illustrate how the notion of a subtype extends to functions (and more generally, methods). This will allow us to understand (in the dedicated section) some type constraints expressed via generics in languages like Java or C#.\nThe subtype relation # Intuitively, $A$ is a **subtype** of $B$ if \"every $A$ is a $B$\". **_Examples._** - `Integer` is a subtype of `Number`, - `String` is a subtype of `Object`. In object-oriented programming, subtyping generalizes hierarchical relations between classes, interfaces, etc.\n**_Example._** In Java, $A$ is a subtype of $B$ if: - $A$ and $B$ are classes and $A$ `extends` $B$ (directly or transitively), or - $A$ and $B$ are interfaces and $A$ `extends` $B$ (directly or transitively), or - $A$ is a class, $B$ is an interface and $A$ `implements` $B$ (directly or transitively), or - etc. **_Observation._** \"Subtype\" is a [binary relation](http://localhost:41071/docs/background/sections/order/#binaryRelation). This relation is both: - [reflexive](http://localhost:41071/docs/background/sections/order/#reflexiveTransitiveAntisymmetric): every type $A$ is a subtype of itself, - [transitive](http://localhost:41071/docs/background/sections/order/#reflexiveTransitiveAntisymmetric): if $A$ is a subtype of $B$ and $B$ is a subtype of $C$, then $A$ is a subtype of $C$. **_Observation._** If an object $o$ has type $A$ and $A$ is a subtype of $B$, then $o$ also has type $B$. **_Examples._** In Java: - if an object has type `Integer`, then it also has type `Number`, - if an object has type `String`, then it also has type `Object`. Question. How do these observations generalize to functions (or methods) and the type of their arguments and return value?\nFunction type # **_Definition._** A function has type $\\qquad X \\to Y$ if it maps _every_ element of $X$ to _some_ element of $Y$. Examples # **_Glossary (reminder)._** - $\\mathbb{R}$ : real numbers - $\\mathbb{Z}$ : integers - $\\mathbb{N}$ : natural numbers (a.k.a. positive integers, including `0`) **_Example._** Consider a function `getLength` that: - takes as argument a string, and - returns the length of this string. This function has type $\\qquad$ `String` $\\to \\mathbb{N}$ because it maps every string to a natural number. It also has type $\\qquad$ `String` $\\to \\mathbb{Z}$ because it maps every string to an integer (since natural numbers are integers). For the same reason, it also has type $\\qquad$ `String` $\\to \\mathbb{R}$ However, it does _not_ have type $\\qquad$ `Object` $\\to \\mathbb{N}$ because it does not map _every_ object to an integer (only strings). Exercise Consider the function $f(x) = x^2$. Which of the following types are valid for $f$ ? 1. $\\qquad \\mathbb{R} \\to \\mathbb{R}$ 2. $\\qquad \\mathbb{R} \\to \\mathbb{Z}$ 3. $\\qquad \\mathbb{R} \\to \\mathbb{N}$ 4. $\\qquad \\mathbb{Z} \\to \\mathbb{R}$ 5. $\\qquad \\mathbb{Z} \\to \\mathbb{Z}$ 6. $\\qquad \\mathbb{Z} \\to \\mathbb{N}$ 7. $\\qquad \\mathbb{N} \\to \\mathbb{R}$ 8. $\\qquad \\mathbb{N} \\to \\mathbb{Z}$ 9. $\\qquad \\mathbb{N} \\to \\mathbb{N}$ Solution 1, 4, 5, 6, 7, 8, 9 Function subtyping # Exercise (continued) Which of the 8 proposals below are correct? If a function has type $\\qquad \\mathbb{Z} \\to \\mathbb{Z}$ then it also has type: 1. $\\qquad \\mathbb{N} \\to \\mathbb{N}$ 1. $\\qquad \\mathbb{N} \\to \\mathbb{Z}$ 1. $\\qquad \\mathbb{N} \\to \\mathbb{R}$ 1. $\\qquad \\mathbb{Z} \\to \\mathbb{N}$ 1. $\\qquad \\mathbb{Z} \\to \\mathbb{R}$ 1. $\\qquad \\mathbb{R} \\to \\mathbb{N}$ 1. $\\qquad \\mathbb{R} \\to \\mathbb{Z}$ 1. $\\qquad \\mathbb{R} \\to \\mathbb{R}$ Solution 2, 3, 5 We can now generalize these observations:\n**_Property._** If $X_1$ is a subtype of $X_2$ and $Y_1$ is a subtype of $Y_2$, then $\\qquad X_2 \\to Y_1$ is a subtype of $\\qquad X_1 \\to Y_2$ **_Example._** A function from `Unit` to `Integer` is also a function: - from `Butterfly` to `Integer`, - from `Unit` to `Number`, and - from `Butterfly` to `Number`. "},{"id":54,"href":"/docs/regex/sections/java/","title":"Using Java regexes","section":"Regular expressions","content":" Using Java regexes # Escaping \\ # A regex in Java is a string.\nRecall that within a Java string, a \\ character must be escaped (i.e. written \\\\) to be read as a normal character. So in a Java string that represents a regex, every \\ should be written \\\\.\n**_Example._** The string `\"[A-Z]\\\\d+\"` represents the regex `[A-Z]\\d+` **_Hint._** This is another good reason for using a regex validation tool (e.g. [regex101](https://regex101.com/)) to test and debug a regex, before incorporating it into a program. **_Warning._** We saw earlier that when `\\` is treated as a normal character in a regex, it must be escaped (`\\\\`). Therefore in this specific case, the Java string should contain `\\\\\\\\`. **_Example._** The string `\"\\\\d+\\\\\\\\[A-Z]\"` represents the regex `\\d+\\\\[A-Z]` Regexes and String instance methods # Some instance methods of the class String take a regex as input. Among these:\nboolean matches(String regex) returns true iff the whole string belongs to the language described by the regex. Or equivalently if there is a match for the regex ^regex$. String input = \u0026#34;ab\u0026#34;; // Outputs false System.out.println(input.matches(\u0026#34;a\u0026#34;)); // Outputs true System.out.println(input.matches(\u0026#34;ab|a\u0026#34;)); // Outputs true System.out.println(input.matches(\u0026#34;a|ab\u0026#34;)); String replaceFirst(String regex, String replacement) replaces the best first match with the input replacement string: String input = \u0026#34;aba\u0026#34;; // Outputs \u0026#34;ba\u0026#34; System.out.println(input.replaceFirst(\u0026#34;ab|a\u0026#34;, \u0026#34;b\u0026#34;)); // Outputs \u0026#34;bba\u0026#34; System.out.println(input.replaceFirst(\u0026#34;a|ab\u0026#34;, \u0026#34;b\u0026#34;)); String replaceAll(String regex, String replacement) replaces all (successive) best first matches with the input replacement string: String input = \u0026#34;aba\u0026#34;; // Outputs \u0026#34;bb\u0026#34; System.out.println(input.replaceAll(\u0026#34;ab|a\u0026#34;, \u0026#34;b\u0026#34;)); // Outputs \u0026#34;bbb\u0026#34; System.out.println(input.replaceAll(\u0026#34;a|ab\u0026#34;, \u0026#34;b\u0026#34;)); For both `replaceFirst` and `replaceAll`, the replacement string can use a [reference](http://localhost:41071/docs/regex/sections/practice/#backreference) to a group, written `$`$n$, where $n$ is the [group number](http://localhost:41071/docs/regex/sections/practice/#group): ```java String input = \"The windows are open. The apples are green.\"; String output = input.replaceAll(\"(\\\\w+)s\\\\s+are\", \"$1 is\"); // Outputs \"The window is open. The apple is green.\" System.out.println(output); ``` **_Reminder._** Strings in Java are [immutable](http://localhost:41071/docs/objects/sections/quasi-objects/#string). So when the methods `replaceFirst` and `replaceAll` successfully \"modify\" the string, they return a different object. String[] split() splits the input string around the (successive) best first matches: String input = \u0026#34;This is weird.\\n\u0026#34;+ \u0026#34;Or not.\u0026#34; // Contains [ \u0026#34;This\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;weird.\u0026#34;, \u0026#34;Or\u0026#34;, \u0026#34;not.\u0026#34; ] String[] output = input.split(\u0026#34;\\\\s+\u0026#34;); java.util.regex # The native package java.util.regex contains among other the following classes:\nPattern # A Pattern is a regex.\nA Pattern can be created with the static method Pattern Pattern.compile(Sring regex).\nMatcher # A Matcher is a \u0026ldquo;regex engine\u0026rdquo; for a specific regex and a specific string.\nA Matcher can be created out of a Pattern, with the instance method Matcher matcher(String inputString) of the class Pattern.\nPattern pattern = Pattern.compile(\u0026#34;\\\\d+[a-z]*\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;Alice787@unibz\u0026#34;); Among others, the class Matcher provides the following instance methods:\nboolean matches(), String replaceFirst() and String replaceAll() behave analogously to their counterpart for the class String, described above.\nboolean find() tries to match the next best first match. If this method succeeds, then information can be retrieved about the matched segment (see below). The next call to find() will find the following best first match (if any).\nPattern pattern = Pattern.compile(\u0026#34;[A-Z][a-z]*\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;Alice and Bob are exhausted.\u0026#34;); // Outputs true and matches the segment with word \u0026#34;Alice\u0026#34; System.out.println(matcher.find()); // Outputs true and matches the segment with word \u0026#34;Bob\u0026#34; System.out.println(matcher.find()); // Outputs false System.out.println(matcher.find()); String group(int i) returns the substring captured by Group $i$ in the latest match. Group 0 stands for the whole regex.\nString group() is equivalent to group(0).\nint start() returns the start index (included) of the latest matched segment.\nint end() returns the end index (excluded) of the latest matched segment.\nPattern pattern = Pattern.compile(\u0026#34;([A-Z])[a-z]*\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;Alice and Bob are exhausted.\u0026#34;); //Find the best first match matcher.find(); // Outputs \u0026#34;Alice\u0026#34; System.out.println(matcher.group()); // Outputs \u0026#34;A\u0026#34; System.out.println(matcher.group(1)); // Outputs 0 System.out.println(matcher.start()); // Outputs 5 System.out.println(matcher.end()); //Find the next best first match matcher.find(); // Outputs \u0026#34;Bob\u0026#34; System.out.println(matcher.group()); // Outputs \u0026#34;B\u0026#34; System.out.println(matcher.group(1)); public Sream\u0026lt;MatchResult\u0026gt; results() returns all (successive) best first matches. Pattern pattern = Pattern.compile(\u0026#34;[A-Z][a-z]*\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;Alice and Bob are exhausted.\u0026#34;); // Contains two match results: // - one for the segment with word \u0026#34;Alice\u0026#34;, // - one for the segment with word \u0026#34;Bob\u0026#34; List\u0026lt;MatchResult\u0026gt; matches = matcher.results().toList(); MatchResult # A MatchResult is a matched segment.\nThe class MatchResult provides (among others) the instance methods String group(int i), String group(), int start() and int end(), which behave analogously to their counterparts in the class Matcher.\nPattern pattern = Pattern.compile(\u0026#34;[A-Z][a-z]*\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;Alice and Bob are exhausted.\u0026#34;); // Get all best first matches List\u0026lt;MatchResult\u0026gt; matches = matcher.results().toList(); // Outputs \u0026#34;Alice\u0026#34; System.out.println(matches.get(0).group()); // Outputs \u0026#34;Bob\u0026#34; System.out.println(matches.get(1).group()); "},{"id":55,"href":"/docs/build/sections/artifact/","title":"Artifact","section":"Build automation","content":" Artifact # A Maven **artifact** is the output of a build process. It can for instance be a [jar](http://localhost:41071/docs/build/sections/packaging/#jar). Coordinates # A Maven artifact is identified by so-called **coordinates**: - **groupId:** identifier of the organization that created the project (this is usually the organization's reversed domain name), - **artifactId:** identifier of the project within the group, - **version:** version of the artifact. **_Examples._** ```xml com.google.guava guava 33.1.0-jre ``` ```xml com.github.haifengl smile-core 3.1.0 ``` These coordinates are notably used to declare dependencies.\nVersions # SemVer # Maven artifact versions often follow (or loosely follow) the so-called semantic versioning scheme.\nMajorVersion.MinorVersion or\nMajorVersion.MinorVersion.Patch **_Example._** According to the SemVer scheme, Version `3.4.1` means: - major version: `3` - minor version: `4` - patch: `1` By convention: - a new **major version** often signals the absence of backward compatibility, - a new **minor version** often signals (backward compatible) new features, - a **patch** often signals bug (or security-related) fixes. **_Note._** Java has only one major version. For instance \"Java 17\" actually refers to Java `1.17`. SNAPSHOT # The `SNAPSHOT` qualifier (e.g. in Version `3.4.1-SNAPSHOT`) indicates an _upcoming_ release, still _under development_. The SNAPSHOT qualifier is typically used to describe the (current state of) the source code of (a git branch of) a project (e.g. available as a public git repository). For instance, if the latest release of the project was 3.5.2, and if the developers are working on bug fixes, then the latest source code may have Version 3.5.3-SNAPSHOT.\n**_Warning._** A program whose version number has the `SNAPSHOT` qualifier may be modified by it authors, _while keeping the same version number_. In other words, `Version 3.4.1-SNAPSHOT` downloaded today may differ from `Version 3.4.1-SNAPSHOT` downloaded tomorrow. So when releasing a project, it is recommended to avoid dependencies on `SNAPSHOT` versions. "},{"id":56,"href":"/docs/errors/sections/checked/","title":"Checked vs unchecked","section":"Errors","content":" Checked vs unchecked # Unchecked exceptions # The simplest type of exception in Java is called an unchecked exception. An unchecked exception is an instances of the native class RuntimeException.\nThe class RuntimeException has several native subclasses. You may be familiar wit some of them: NullPointerException, ArrayIndexOutOfBoundsException, IllegalArgumentException, etc.\nAn unchecked exception that is not caught is _automatically rethrown_. Checked exceptions # In Java, an Exception that is not a RuntimeException is a checked exception.\nFor instance, an IOException is a checked exception.\nA checked exception is _not_ rethrown by default. Instead, it must be _explicitly_ rethrown (or caught), otherwise the program does not _compile_. For instance, the following code does not compile, because the method of Files.readAllLines may throw an IOException.\nvoid someMethod(Path path) { Files.readAllLines(path); } Rethrow explicitly # This can be fixed by either catching the exception, or explicitly rethrowing it, as follows:\nvoid someMethod(Path path) throws IOException { Files.readAllLines(path); } Then a method that calls myMethod will in turn have to catch the exception, or rethrow it explicitly, etc.\n**_Warning._** Checked exceptions add boilerplate code to method signatures (e.g. `throws IOException` in the above example). For this reason, it is often recommended to use unchecked exceptions (i.e. instances of `RuntimeException`) _by default_. In [Effective java](http://localhost:41071/docs/intro/sections/bibliography/#effectiveJava) (Item 71), Joshua Bloch suggests checked exceptions only if some calling method is likely to _catch_ the exception and take a _meaningful action_ when this happens. "},{"id":57,"href":"/docs/input/sections/property/","title":"Configuration files","section":"I/O and serialization","content":" Configuration files # It is common practice for an application to store parameters (e.g. user-specific settings) in configuration files.\nA configuration file may be edited manually and/or via a graphical interface.\nConfiguration files may use different serialization formats. Some popular formats are INI, JSON, TOML, YAML or XML.\nin Java # Java provides native support for at least two configuration file serialization formats: XML and the so-called \u0026ldquo;property file\u0026rdquo; format.\nWe introduce here the latter.\nA **property file** usually: - has extension `.properties`, - may have commented line (starting with `#` or `!`), - contains one `key=value` pair per (non-commented) line. **_Example._** In our game, the file `config.properties` has two `key=value` pairs: ``` animationDuration=1 resolution=1920x1080 ``` More details about the syntax of property files (escaped characters, spaces, etc.) can be found here.\nReading a property file # The content of a property file can be loaded in memory and modified as an associative array , instance of the class Properties (which extends Map).\nFor instance, the content of a property file can be loaded as follows:\nProperties properties = new Properties(); try { properties.load(new FileInputStream(\u0026#34;path/to/config.properties\u0026#34;)); } catch (IOException e) { throw new RuntimeException(e); } Then a value can be read with the method getProperty (among other possibilities), as follows:\nString resolution = properties.getProperty(\u0026#34;resolution\u0026#34;); float duration = Float.parseFloat(properties.getProperty(\u0026#34;animationDuration\u0026#34;)); Writing to a property file # The content of a property file can be modified with the methods setProperty and store (among other possibilities), as follows:\nString path = \u0026#34;path/to/config.properties\u0026#34;; Properties properties = new Properties(); try { // load the file as an associative array properties.load(new FileInputStream(path)); // modify the associative array properties.setProperty(\u0026#34;animationDuration\u0026#34;, Float.toString(0.5f)); // replace the content of the property file with the // content of the associative array properties.store(new FileOutputStream(path)); } catch (IOException e) { throw new RuntimeException(e); } "},{"id":58,"href":"/docs/intro/sections/content/","title":"Content","section":"This course","content":" Content of the course # This is a beginner\u0026rsquo;s course on imperative and (class-based) object oriented programming, with an emphasis on practice and collaboration.\nThe course relies on Java as main programming language. However, many concepts seen in this course are relevant to other (imperative and/or object-oriented) programming languages: C/C++, C#, Javascript, Go, Kotlin, Lua, Perl, PHP, Python, Rust, Ruby, Typescript, Visual Basic, etc.\nPrerequisites # Students are expected to have completed the Computer Programming course (INF/01 76258).\nTherefore the following topics are not covered in this course:\nvariables, assignments, variable scope, basic data types, conditional statements (\u0026ldquo;if/then/else\u0026rdquo;) and loops, expression evaluation, methods/functions, arrays, etc. Students are also expected to have played the board game used as a running example throughout the lectures.\nOutcomes # After completing this course, students should be able to:\ndevelop a prototype application in Java, write structured, documented and easily maintainable code, collaborate with other developers. Focus # Foundations # Most lectures put an emphasis on problem solving rather than syntax. For conciseness, pseudocode may be used in some sections rather than Java code.\nSome lectures also focus on more abstract (albeit simple) notions. These includes elementary mathematical objects or structures (set, tuple, map, relation, preorder, graph, tree, etc.), regular languages, etc.\nThe purpose is twofold:\nfacilitate the application of techniques seen in this course to programming languages other than Java, provide a widely accepted vocabulary to document/explain your code. Collaboration # The course introduces basic coding practices to ease development within a team. In particular:\nstructuring a project (components, interfaces, encapsulation, etc.), factorizing code (inheritance, reuse of methods, etc.), test-driven development, collaboration via git. **_Note._** What is considered _good communication_ in computer science may differ from other disciplines. Emphasis is put on _clarity_, _precision_ and _conciseness_. Exercise Here is a (caricature of) a poorly documented method. Can you improve the method's description and/or signature? ```java /** The algorithm looks at the first collection, and is only guaranteed to * work if no number is present twice in this collection, in which case it * loops over the numbers contained in this collection (in no specific order) * and checks for each number whether it is also present in the second * collection (which is also expected to have distinct numbers). The code * written in this loop adds the current number (from the first collection) * to the output collection if this number is also present in the second * collection, and does nothing otherwise. */ Collection filterNumbersThatAreShared(Collection c1, Collection c2); ``` Solution A simpler signature and description could be: ```java /** * Returns the intersection of sets s1 and s2. */ Set intersection(Set s1, Set s2); ``` However, the following topics are beyond the scope of this course:\ncontinuous integration, project management (agile methodology, bug tracking, etc.), advanced git workflows, advanced design patterns, dependency injection, etc. Quizzes # Some lectures will include quizzes. These are anonymous, and therefore are not part of your evaluation. The purpose is to:\nmake lectures more interactive and adapt the pace of the lectures based on students\u0026rsquo; answers. It is in your own interest to answer them without external resources (web, chatbots, IDE, etc.).\nHere is a link to the first quiz: https://forms.gle/7Y2MpzE7v5xzUJFy7.\nTopics covered # Due to limited time, many notions (such as asymptotic cost, regular languages, hash tables or multi-threading) are only briefly introduced in this course. However, some of them will be further discussed in other courses of the bachelor.\nProgramming concepts and techniques # An important part of the lectures is dedicated to the following core topics:\nobjects, classes and interfaces (inheritance, encapsulation, value vs reference, comparing objects, cloning objects, etc.), abstract data types (set, list, associative array, queue, etc.) and data structures (array, linked list, hash table, etc.), recursion. In addition, the following will be (briefly) introduced:\nregular expressions, generics, mutability, pure functions, lambda expressions and streams, multi-threading. **_Note._** Some of these topics pertain to [functional programming](https://en.wikipedia.org/wiki/Functional_programming), but have been incorporated (in some form) to several imperative languages over the years. Software engineering # unit tests, exceptions, code factorization. Java # compilation/interpretation, bytecode, JVM and JDK, input/output, object serialization, JSON/XML serialization. Tools and tutorials # git, build automation (Maven and Gradle), using an IDE, using a terminal efficiently (introduction), etc. "},{"id":59,"href":"/docs/git/sections/create/","title":"Create or clone a repository","section":"git","content":" Create or clone a repository # From a remote server # The most common way to create a repository is to create the remote copy first, using the web interface of your host (Github, Gitlab, Bitbucket, etc.).\nYou will be asked to give the repository a name. Then you will be provided an address that allows use to clone the repository on your own machine (via ssh or https).\nTo do so, navigate on your machine to the folder where you want to clone the repository, and run\ngit clone \u0026lt;address\u0026gt; **_Note._** After cloning a repository, you can verify that it contains a (hidden) subfolder called `.git`. Recall that this is what distinguishes a git repository from a regular folder. **_Note._** You can safely move a cloned repository to another location on your machine (as long as it contains the `.git` subfolder). With the same command, you can clone any public repository that you find online (e.g. hosted on GitHub).\nTo clone a specific branch, run\ngit clone -b \u0026lt;branchName\u0026gt; \u0026lt;address\u0026gt; Locally # Alternatively, you can create a git repository on your machine with the git init command. This may be convenient if you want to create a git repository from an existing (nonempty) folder.\nIf you create a git repository locally, then you will need to declare your remote(s) manually (with git remote).\n"},{"id":60,"href":"/docs/objects/sections/methods/","title":"Instance methods","section":"Objects and classes","content":" Instance methods # In most object-oriented languages (like Java), methods are implemented within class declarations.\nAn instance method can only be called using an instance of the class where it is declared.\nFor instance, in Java, an instance method declared in MyClass can be called by appending . to a variable of type MyClass. The object referenced by the variable is accessible in the method, as well as its attributes.\nThis intuitively allows us to write methods with one less argument. For instance, consider the following method, which is not and instance method. It verifies whether two instance of MobileUnit have the same color:\npublic boolean sameColor(MobileUnit u1, MobileUnit u2){ return u1.color.equals(u2.color); } This method may be called as follows:\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); Butterfly myButterfly = new Butterfly(\u0026#34;green\u0026#34;); boolean sameColor = sameColor(myUnicorn, myButterfly); Instead, one may write an equivalent method, as an instance method of our class MobileUnit, with one less argument:\npublic abstract class MobileUnit extends Unit { String color; ... public boolean sameColorAs(MobileUnit otherUnit){ return color.equals(otherUnit.color); } } and we can call this method as follows:\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); Butterfly myButterfly = new Butterfly(\u0026#34;green\u0026#34;); boolean sameColor = myUnicorn.sameColorAs(myButterfly); } Overriding # A same instance method can be declared in a class C and a subclass S or C. In this case, we say that S overrides the method.\nWhen such a method is called, the most specific applicable version is executed.\nFor instance, let us extend our example from the previous section with a method regen, declared in both Unit and MobileUnit, as follows:\npublic abstract class Unit { int health; ... public void regen(){ if(health \u0026lt; 10){ health += 1; } } } public abstract class MobileUnit extends Unit { ... public void regen(){ if(health \u0026lt; 10){ health += 1; } health += 1; } } Now consider this program.\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); myUnicorn.regen(); This program increases the health of (the object referenced by) myUnicorn by 2, because Unicorn is a subclass of MobileUnit. However, the following program increases the health of (the object referenced by) myWall by 1, because Wall is a subclass of Unit, but not a subclass of MobileUnit.\nWall myWall = new Wall(); myWall.regen(); **_Hint._** In Java, you can use the annotation `@Override` to indicate that a method overrides another, as follows: ```Java public abstract class MobileUnit extends Unit { ... @Override public void regen(){ if(health \u003c 10){ health += 1; } health += 1; } } ``` This is not necessary. The benefit is that the program will not compile if the overridden and overriding methods have different signatures. More generally, _syntactic_ mistakes (a.k.a. compile time errors) are easier to fix than _bugs_ (a.k.a. runtime errors). So when possible, it is good practice to use features of a language that prevent compilation if incorrect programs. This is why debugging in an untyped language (like Python, Javascript, Lua, etc.) can be more difficult than in a _typed_ one (such as Java, C#, Typescript, etc.). Dynamic dispatch (a.k.a. runtime polymorphism) # **Dynamic dispatch** consists in determining which version of a method must be called when a program is executed (a.k.a. \"at run time\"), when this cannot be determined by analyzing the program alone. This is a feature of most (class-based) object-oriented languages. For instance, in our example, assume a method generateRandomUnits that generates a random array of units (butterflies, unicorns or walls). And let us call the method regen for each unit in this array:\nUnit[] ramdomUnits = generateRandomUnits(); for (Unit unit: randomUnits){ unit.regen(); } The most specific applicable version of the method regen will be executed for each unit, based on its type, even though this type cannot be determined at compile time. For instance, if there is an instance of Unicorn in this array, then the method MobileUnit.regen() will be executed for this instance (rather than the method Unit.regen()).\nCode factorization # An overriding method often extends the functionality of the overridden one. This is a possible source of duplicate code. For instance, in the example above, both implementations of regen() contain:\nif(health \u0026lt; 10){ health += 1; } A common way to factorize this consists in calling the overridden method inside the overriding one. In Java, the keyword super allows us to distinguish the two methods (since they have the same name). For instance, in the above example, the overriding method may be better written as follows:\npublic abstract class MobileUnit extends Unit { ... public void regen() { super.regen(); health += 1; } } Exercise In this example, what would be the effect of replacing `super.regen()` with `regen()`? Solution The method would not terminate. Exercise Consider the method `encounter` of the previous section. Add it as an instance method to our example, so that: - the method now distinguishes the attacker from the defender, - a wall cannot attack, - a unicorn gets a regen if it defends. Possible solution The trick here consists in viewing an encounter from the point of view of the defender: ![](/img/diagrams/plantuml/method_inherit_complex.svg) ```Java public abstract class Unit { int health; ... public void defend(MobileUnit attacker) { // save the initial value of the first unit's health int copy = health; health -= attacker.health; attacker.health -= copy; } } ``` ```Java public class Unicorn extends Unit { ... public void defend(MobileUnit attacker) { regen(); super.defend(attacker); } } ``` "},{"id":61,"href":"/docs/multithreading/sections/race/","title":"Race condition","section":"Multithreading","content":" Race condition # **_Definition._** A **race condition** occurs when the outcome of a program may vary depending on the order in which two threads access a resource. Illustrations # **_Example._** The following program (in pseudocode) apparently increments variable `i` twice. However, it may output either `1` or `2`, depending on the execution environment: ```perl int i = 0 spawn i++ i++ sync print(i) ``` The reason is that a core does not increment the value of a variable as an [atomic operation](http://localhost:41071/docs/multithreading/sections/abstractions/#atomic). Instead, an increment is a sequence of three instructions: 1. read the value of `i` and fetch it to one of the core's registers 2. increment the value of this register 3. write the register's value back to memory If a [context switch](http://localhost:41071/docs/multithreading/sections/concurrency/#switch) occurs during the execution of these three operations, or if the two threads are executed in parallel (i.e. on different cores), then the outcome _may_ be unexpected. Among other possibilities, the following may happen: - the current thread executes step 1, copying the value `0` from memory to a register, - then the child thread executes step 1 as well, copying the value `0` to another register, - then the current thread executes steps 2 and 3, writing the value `1` back to memory, - then the child thread executes step 2 and 3, writing the value `1` back again to memory. However, the following sequence of actions would (for instance) produce the expected result: - the current thread executes steps 1, 2 and 3, - then the child thread executes steps 1, 2 and 3. **_Note._** A race condition can only occur if: - two threads access a same resource, and - at least one of them modifies it. **_Example._** The following algorithm performs a matrix by vector multiplication with a \"parallel\" loop, and is free of race conditions: ```perl product(int[][] M, int[] v){ int[] w = new int[M.length] for parallel (int i = 0; i \u003c M.length; i++){ for (int j = 0; j \u003c v.length; j++){ w[i] += M[i][j] * v[j] } } return w } ``` However, adding the keyword `parallel` to the inner loop may yield an incorrect output. ```perl product(int[][] M, int[] v){ int[] w = new int[M.length] for parallel (int i = 0; i \u003c M.length; i++){ for parallel (int j = 0; j \u003c v.length; j++){ w[i] += M[i][j] * v[j] } } return w } ``` The reason is that two threads may now modify the value of `w[i]` concurrently, for the same `i` (but different values of `j`). Non determinism # **_Warning._** In general, a bug caused by a race condition cannot be consistently reproduced, _even on the same hardware_. This is why race conditions are notoriously difficult to identify and/or debug, even for programs that has been extensively tested (a famous example of a race condition with a dramatic impact is the Northeastern United States blackout of 2003).\nCaution # Multithreading is a good example (together for instance with caching the results of a computation) of an error-prone optimization technique, which may impact on code readability and correctness.\nA common mistake made by less experienced developers is to use multithreading \u0026ldquo;because we can\u0026rdquo;.\nInstead, it is often recommended to use multithreading cautiously, and only if some bottleneck has been identified in an application (e.g. with a profiler): unacceptable processing time, non-responsive GUI, etc.\nWe reproduce here three (loosely) related citations made in Effective Java (Item 67, \u0026ldquo;Optimize judiciously\u0026rdquo;):\nMore computing sins are committed in the name of efficiency (without necessarily achieving it) than for any other single reasonâincluding blind stupidity.\nWilliam A. Wulf, 1972\nWe should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.\nDonald Knuth, 1974\nWe follow two rules in the matter of optimization: Rule 1. Donât do it. Rule 2 (for experts only). Donât do it yet â that is, not until you have a perfectly clear and unoptimized solution.\nM. A. Jackson, 1975\n"},{"id":62,"href":"/docs/background/sections/order/","title":"Relation, preorder","section":"Background","content":" Relation, preorder # Relation # **_Definition._** A **relation** over a set $S$ is a set of [tuples](http://localhost:41071/docs/background/sections/set_tuple_map/#tuple) over $S$ with the same arity. In particular: - a **binary relation** over $S$ is a set of [pairs](http://localhost:41071/docs/background/sections/set_tuple_map/#tuple), or equivalently a subset of $S \\times S$, - a **ternary relation** over $S$ is a set of [triples](http://localhost:41071/docs/background/sections/set_tuple_map/#tuple), or equivalently a subset of $S \\times S \\times S$, - etc. For instance, if \\(S = \\{a,b,c,d\\}\\) , then\n\\(\\Big\\{ (a,a),\\ (a,b),\\ (b,a),\\ (b,c) \\Big\\}\\) is a binary relation over \\(S\\) ,\n\\(\\Big\\{ (a,b,a),\\ (c,c,c) \\Big\\}\\) is a ternary relation over \\(S\\) .\nExercise If $S$ is finite with size $n$, then how many $k$-ary relations are there over $S$? Solution A $k$-ary relation over $S$ is a subset of $S^k$. So there are $2^{|S^k|} = 2^{n^k}$ $k$-ary relations over $S$. Binary relation # A binary relation can be represented in multiple ways.\nIn particular, it can be represented as a (directed) graph (and conversely).\nFor instance, the relation \\(\\Big\\{ (a,a),\\ (a,b),\\ (b,a),\\ (b,c) \\Big\\}\\) over \\(\\{a,b,c,d\\}\\) can be viewed as the graph:\nA binary relation can also be represented with an infix symbol.\nFor instance, the same relation \\(\\Big\\{ (a,a),\\ (a,b),\\ (b,a),\\ (b,c) \\Big\\}\\) can be represented as\n\\(a \\preceq a\\) ,\n\\(a \\preceq b\\) ,\n\\(b \\preceq a\\) ,\n\\(b \\preceq c\\) .\nReflexivity, transitivity, antisymmetry # **_Definition._** A binary relation $\\preceq$ over a set $S$ is - **reflexive** if $x \\preceq x$ for all $x \\in S$ - **transitive** if for all $x, y, z \\in S$ $\\qquad \\qquad \\qquad x \\preceq y$ and $y \\preceq z$ imply $x \\preceq z$ - **antisymmetric** if for all $x, y \\in S$ $\\qquad \\qquad \\qquad x \\preceq y$ and $y \\preceq x$ imply $x = y$ Exercise Which of these three properties does the relation below satisfy? ![](/img/order/graph_prop.svg) Solution Only reflexivity. Preorder, order # **_Definition._** A binary relation is a **preorder** if it is reflexive and transitive. It is an **order** if it is also antisymmetric. Total vs partial # **_Definition._** A preorder $\\preceq$ over $S$ is **total** if every two elements of $S$ are comparable, i.e. if $ \\qquad \\qquad x \\preceq y$ or $y \\preceq x$ for all $x, y \\in S$. A preoder that is not total is called **partial**. **_Example._** The natural order $\\le$ over $\\mathbb{R}$ is a total order (i.e. total, reflexive, transitive and antisymmetric). **_Example._** If $S$ is a set, then the set inclusion relation $\\subseteq$ over the [power set](http://localhost:41071/docs/background/sections/set_tuple_map/#set) of $S$ is a partial order (i.e. reflexive, transitive and antisymmetric). **_Warning._** The term \"order\" is often used to refer to a _total_ order. Sorting # If \\(S\\) is a set, then a total preorder over \\(S\\) is intuitively any relation that allows sorting \\(S\\) .\n**_Example._** Let $P$ be the set of people, and let $\\preceq_{\\text{age}}$ be the relation defined over $P$ by $\\qquad \\qquad p_1 \\preceq_{\\text{age}} p_2$ iff $p_1$ is younger than (or as old as) $p_2$. Then $\\preceq_{\\text{age}}$ is a total preorder (i.e. total, reflexive and transitive), but it is not an order (i.e. not antisymmetric), because two persons can have the same age. Lexicographic product # **_Notation._** If $\\preceq_o$ is a preorder, let us use: - $x \\prec_o y$ as a shortcut for ($ x \\preceq_o y$ and $ y \\not\\preceq_o x$ ), - $x =_o y$ as a shortcut for ($x \\preceq_o y$ and $y \\preceq_o x$ ). **_Definition._** The **lexicographic product** $\\preceq_{1,2}$ of a preorder $\\preceq_1$ by a preorder $\\preceq_2$ is defined by $\\qquad \\qquad x \\preceq\\_{1,2} y$ iff $x \\prec_1 y$ or ( $x =_1 y$ and $x \\preceq_2 y$ ) **_Example._** Let $P$ be the set of people, and let $\\preceq_{\\text{age}}$ and $\\preceq_{\\text{size}}$ be the total preorders defined over $S$ by $\\qquad \\qquad p_1 \\preceq_{\\text{age}} p_2$ iff $p_1$ is younger than (or as old as) $p_2$, and $\\qquad \\qquad p_1 \\preceq_{\\text{size}} p_2$ iff $p_1$ is smaller than (or as tall as) $p_2$. Then the lexicographic product $\\preceq_{\\text{age, size}}$ of $\\preceq_{\\text{age}}$ by $\\preceq_{\\text{size}}$ is defined by $\\qquad p_1 \\preceq_{\\text{age, size}} p_2$ iff $\\qquad \\qquad p_1$ is strictly younger than $p_2$, or $\\qquad \\qquad$ they have the same age and $p_1$ is smaller than (or as tall as) $p_2$. **_Warning._** The lexicographic product of $\\preceq_1$ by $\\preceq_2$ may differ from the lexicographic product of $\\preceq_2$ by $\\preceq_1$. **_Hint._** The lexicographic product of a total preorder by a total preorder (resp. a total order) is itself a total preorder (resp. a total order). "},{"id":63,"href":"/docs/env/sections/install/","title":"Software management","section":"Development environment","content":" Software management # Dependencies # As a developer, you frequently need to download, install and/or update:\nlibraries used in your projects (called dependencies), core programming utilities, such as a compiler or interpreter for a given programming language, a package manager, etc. tools for software development: editor, debugger, visualization tool, etc. These programs have their own dependencies, that have their own dependencies, etc. And two programs may depend on different versions of a same third program.\nDependency management is a frequent source of complications during software development. Dependency patterns that may occur include:\nco-dependencies:\nFor instance, consider the following configuration:\nProject \\(P\\) depends on a certain version of Library \\(L_1\\) , \\(P\\) also depends on Library \\(L_2\\) , which depends on an older version of \\(L_1\\) (and the two versions are not compatible), The build of project \\(P\\) may fail because it can contain only one version of \\(L_1\\) .\ncyclic dependencies:\nLibrary \\(L_1\\) depends on a specific version of Library \\(L_2\\) , and\n\\(L_2\\) depends on a specific version of \\(L_1\\) .\nUpgrading one of these two libraries independently may prevent the other one to run. But it may be possible to upgrade both at the same time.\netc.\nNote that in these two examples, dependencies may be direct or transitive. As a result, it can be very difficult to diagnose such problems.\nThe term dependency hell is sometimes used to refer to such situations.\nTwo (non-exclusive) broad approaches are commonly adopted to avoid such issues:\nautomated dependency management, and self-containment: avoid shared libraries, each program having a copy (some of) its own dependencies. Automated dependency management # Definitions # A **package** is a program together with some metadata. These metadata include the program's name, version, release date, authors, licence and _dependencies_ (together with their _versions_). A **software repository** is a collection of packages that comply to the same format of metadata. A software repository (precisely, multiple copies of it) is generally hosted on the cloud. A **package manager** automates the installation (as well as configuration, update and removal) of packages from a software repository (or several) to a user's machine. Examples # Many programming languages have dedicated package managers. For instance:\nMaven for Java, npm for Node.js (Javascript) pip for Python, NuGet for .NET (C#, F#, and Visual Basic) RubyGems for Ruby, CPAN for Perl CRAN for R, etc. Some applications also have dedicated software repositories for plugins (and plugin managers to handle these plugins). For instance.\nThe VSCode market place, CTAN for LateX, MELPA for Emacs, etc. Other applications (such as zsh, vim or neovim) only have plugin managers, without a centralized software repository. These managers install plugins directly from hosts (e.g. a GitHub repository) specified by the plugins\u0026rsquo; authors.\nLast (but not least), an operating system (OS) may use a package manager and software repositories. Notably, this is the preferred way of installing software on most Linux distributions. Widely used OS package managers include:\napt for Debian and derivatives, dnf for Fedora and derivatives, pacman for Arch and derivatives, homebrew for macOS, chocolatey (since 2011) and winget (since May 2021) for Windows. Usage # Installing, updating and removing software via a package manager is highly recommended in most scenarios. In particular:\ndependencies of a package are also installed (or it some cases updated or removed) transitively, some package managers can install and manage several versions of the same package (when needed), the installation process often uses a default configuration and directory layout (environment variables, etc.) that facilitates interaction with other programs. The installation (or update or removal) procedure is also significantly simpler, thus leaving less room for manual errors. As an illustration, here is the full procedure to install Maven with the apt package manager (on Debian and derivatives):\napt install maven and similarly with homebrew (on macOS):\nbrew install maven or with Chocolatey (on Windows):\nchoco install maven In comparison, the procedure to install Maven manually on Windows is more involved, thus more likely to introduce errors (trough inadvertence, or by following outdated instructions).\nHowever, in some (rare) scenarios, a manual installation may be preferred. In particular when the latest version of a program is needed, but not available yet on the software repository.\nSelf-containment # A variety of strategies can be adopted to build a program so that it runs in partial isolation from the rest of the system that it is deployed on (i.e. in its own environment, and with its own dependencies, that cannot be used by other programs).\nFor instance, a Node.js project often includes a copy of all the Javascript libraries that it depends on (transitively). Further self-containment strategies may involve different levels of virtualization (e.g. via Docker).\nThis is one way of avoiding shared dependencies. Other benefits are increased portability, and ease of installation by end-users. Drawbacks include and increased workload on the developer\u0026rsquo;s side (e.g. for maintenance), and limited opportunities for integration with other programs.\nSelf-containment in Java # In Java, self-containment is usually less pronounced during development. Java libraries are typically managed via Maven:\non a per-user basis (which can be viewed as a compromise between per-project and system-wise): each user has a hidden folder \u0026lt;homeDir\u0026gt;/.m2/ that contains all Java libraries used in his/her projects, and allowing multiple versions of the same library to coexist. However, a Java application that targets non-developers can be released together with its Java dependencies, as a so-called Ã¼ber jar (a.k.a. fat jar).\n"},{"id":64,"href":"/docs/abstractdatatypes/sections/queue/","title":"Stack, queue, priority queue","section":"Abstract data types","content":" Stack, queue, priority queue # Some abstract data types impose strong limitations on the set of operations allowed on a collection. These limitations provide opportunities for specialized implementations (i.e. specialized data structures), which can be very efficient in some contexts.\nStack # A **stack** (or **Last In First Out queue** or **LIFO queue**) simulates a collection organized as a physical stack (for instance a stack of plates). A stack exposes three main methods:\npush adds an element to the collection, pop removes and returns the most recently added element, isEmpty is self-explanatory. Queue # A **queue** (or **First In First Out queue** or **FIFO queue**) simulates a collection organized as physical queue (for instance a waiting line). A queue exposes three main methods:\nenqueue (or add) adds an element to the end of the queue, dequeue (or poll) removes and returns the earliest enqueued element, isEmpty is self-explanatory. Priority queue # A **priority queue** simulates a collection equipped with a [total preorder](http://localhost:41071/docs/background/sections/order/#preorder), so that only (one of) the element(s) with highest priority can be retrieved. A priority queue exposes three main methods:\ninsert adds an element to the collection, getMaximumElement removes and returns an element with highest priority, isEmpty is self-explanatory. **_Note._** A regular queue can be viewed as a specific case of priority queue, where each inserted element has (strictly) lower priority than the previous one. "},{"id":65,"href":"/docs/multithreading/sections/synchronization/","title":"Synchronization","section":"Multithreading","content":" Synchronization # The behavior of a program that runs multiple threads can be hard to predict. In particular, two threads may compete to access a same resource (e.g. the value of some object\u0026rsquo;s attribute), without guarantee on the order in which they access it. This may lead (among other things) to a race condition\nProgramming languages that support multithreading also allow expressing constraints on the order of execution of some instructions. For instance, we saw earlier that a thread can be forced to wait for a child thread to terminate before resuming its execution.\nIn this section, we review two additional mechanisms (mutual exclusion and condition variables) that allow synchronizing the behaviors of threads.\nFor a more exhaustive overview of the possibilities offered by Java in that regard, we refer to the Javadoc of the package java.util.concurrent, which summarizes the situations where a Java statement must be executed before another (in Java\u0026rsquo;s terminology, this binary relation over statements is called the \u0026ldquo;happens before\u0026rdquo; relation).\nMutual exclusion # **Mutual exclusion** prevents two threads to access a same resource concurrently. This is generally achieved via some kind of **lock** (sometimes called a **mutex** or **semaphore**). Most programming languages that support concurrency provide mechanisms for mutual exclusion. These languages include C/C++, C#, Go, Java, PHP, Python, or Rust.\nin Java # Java associates to each object a so-called **intrinsic lock** (also called **monitor lock** or simply **monitor**). If a thread $t_1$ **acquires** the intrinsic lock of an object, then a different thread $t_2$ cannot acquire this lock until $t_1$ has **released** it (however, a thread can reacquire a lock that it already owns). The Java keyword synchronized enforces mutual exclusion via an intrinsic lock. In can be used in two ways:\nSynchronized statement # A **synchronized statement** associates an object $o$ to a _block_ of code (called a **synchronized block**). A thread that enters this block acquires the intrinsic lock of $o$, and releases it when exits the block. The syntax is the following:\nsynchronized(\u0026lt;object\u0026gt;){ \u0026lt;code block\u0026gt; } **_Example._** Consider the two following classes: ```java public class Counter { int value; public Counter(int value){ this.value = value; } } public class Lock { } ``` The method `increment` below uses an instance of `Lock` to ensure that a counter is only incremented by one thread at a time: ```java void increment(Counter counter, Lock lock){ synchronized(lock){ counter.value++; } } ``` As a result, the following program is free of race condition: ```java Counter counter = new Counter(0); Lock lock = new Lock(); Thread t1 = new Thread( () -\u003e { increment(counter, lock); } ); Thread t2 = new Thread( () -\u003e { increment(counter, lock); } ); t1.start(); t2.start(); ``` Observe that in the example above, any object could be used as a lock. In particular, the object counter itself. So the program below is equivalent:\nvoid increment(Counter counter){ synchronized(counter){ counter.value++; } } $\\qquad$\nCounter counter = new Counter(0); Thread t1 = new Thread( () -\u0026gt; { increment(counter); } ); Thread t2 = new Thread( () -\u0026gt; { increment(counter); } ); t1.start(); t2.start(); Synchronized method # A **synchronized instance method** uses the intrinsic lock of the object for which this method is called. The syntax is the following:\npublic synchronized int myMethod() { ... } In other words, the two following classes are equivalent: ```java public class MyClass { synchronized void myMethod(){ } } ``` ```java public class MyClass { void myMethod(){ synchronized(this){ } } } ``` **_Warning._** A constructor _cannot_ be synchronized (the program will not compile). **_Observation._** Let $m$ be a synchronized instance method, let $o$ be an object, let $t_1$ and $t_2$ be two different threads, and let us assume that $t_1$ executes $o.m$ (i.e. $t_1$ executes the method $m$ for the object $o$). Then $t_2$ cannot execute _any_ synchronized method for $o$ before the termination of $o.m$ **_Observation._** For the same object, a synchronized method can call another, as long as they are executed by the same thread. Exercise What are the possible outputs of the following program? ```java public class Counter { int value; public Counter(int value){ this.value = value; } synchronized void inc(int delta){ value += delta; } synchronized void doubleDec(int delta){ value -= delta; value -= delta; } int getValue(){ return value; } } ``` ```java Counter counter = new Counter(0); Thread t1 = new Thread( () -\u003e { counter.inc(5); } ); t1.start(); Thread t2 = new Thread( () -\u003e { counter.doubleDec(2); } ); t2.start(); System.out.println(counter.getValue()); try { t1.join(); t2.join(); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(counter.getValue()); ``` Solution Because the two methods `inc` and `doubleDec` are synchronized (and are called on the same object), their executions cannot interleave. This guarantees that the _second_ print statement must output `1`. As for the first print statement, observe that: - there is no guarantee on the order of execution of `counter.inc(5)`, `counter.doubleDec(2)` and the first call to `counter.getvalue()`. - the method `getValue()` is not synchronized, so the first call to `counter.getvalue()` this method may be executed during the execution of `counter.inc(5)` or `counter.doubleDec(2)`. So the possible output values here are `0`, `5`, `3`, `1`, `-2` and `-4`. A **synchronized static method** uses the intrinsic lock of the object that represents the class itself (this object is an instance of `Class`). In other words, the two following classes are equivalent: ```java public class MyClass { static synchronized void myMethod(){ } } ``` ```java public class MyClass { static void myMethod(){ synchronized(Class.forName(\"my.project.name.MyClass\")){ } } } ``` Condition variables # We saw earlier that a thread $t_1$ can wait for another thread $t_2$ to terminate (e.g. with the pseudocode keyword sync, or with the Java instance method Thread.join).\nIn this case, when it terminates, $t_2$ wakes up $t_1$, which can resume its execution.\nA similar but more flexible mechanism is the notion of condition variable. Intuitively, it allows putting a thread to sleep, and waking it up when a certain condition is verified.\nA variety of programming languages support condition variables. These include C++, C#, Go, Java, Python or Rust.\nThe producer/consumer pattern # A prototypical application of condition variables is the so-called producer/consumer pattern. In this scenario, two pools of threads (usually with fixed sizes) communicate via a queue.\nA pool of producer threads, which create elements and add (a.k.a. enqueue) them to the queue, A pool of consumer threads, which receive (a.k.a dequeue) these elements and process them. Two situations may occur where threads should be put to sleep:\nthe queue is empty (e.g. because the process just started, or because elements have been consumed faster than they were produced): consumers should be put to sleep until a new element is produced. the queue is full (e.g. because elements have been produced faster than they were consumed): producers should be put to sleep until an element is consumed. in Java # **_Reminder._** As discussed above, a thread can acquire the intrinsic lock of an object by: - entering a [synchronized block](#syncStatement) that has this object as lock, or - executing a [synchronized method](#syncMethod) for this object. A condition variable in Java can be simulated thanks to he method Object.wait, together with the method Object.notify (or Object.notifyAll).\nwait # The instance method Object.wait can only be called by a thread that acquired the intrinsic lock of the object. It has the effect of releasing this lock, and putting the current thread to sleep, until another thread executes the method notify (or notifyAll) for this same object.\nnotify # Similarly to Object.wait, the instance method Object.notify can only be called by a thread that acquired the intrinsic lock of the object. It has the effect of attempting to wake up one thread (if any) that is waiting for the lock of this object. The awakened thread will only proceed (i.e. actually wake up) after the notifying thread releases the lock of the object.\nnotifyAll # The instance method Object.notifyAll is identical to Object.notify, but attempts to wake up all threads that are waiting for the lock of this object.\n**_Example._** For simplicity, we will use a queue with a capacity of 1. The example is borrowed from the [Oracle tutorials](https://docs.oracle.com/javase%2Ftutorial%2F/essential/concurrency/guardmeth.html). ```java pulic class MyQueue { T item; boolean isEmpty = true; synchronized void enqueue(T item){ while(!isEmpty){ try { wait(); } catch (InterruptedException e) {} } isEmpty = false; this.item = item; notifyAll(); } } ``` When a producer thread $p$ executes the method `enqueue`, it acquires the intrinsic lock of the queue (because the method is synchronized). If the queue is full, it releases the lock and waits for a consumer thread to wake it up. If this happens, thread $p$: - adds the produced item to the queue, - indicates that the queue should now be considered full, - wakes up a consumer thread (if any) waiting for the queue to be empty, - releases the intrinsic lock on the queue (by exiting the synchronized method). The method dequeue is symmetric: ```java public class MyQueue { ... synchronized T dequeue(){ while(isEmpty){ try { wait(); } catch (InterruptedException e) {} } isEmpty = true; notifyAll(); return item; } } ``` Producer threads could be implemented as follows: ```java public class Producer implements Runnable { private MyQueue queue; public Producer(MyQueue queue){ this.queue = queue; } @Override public void run() { while(true){ queue.enqueue(produceItem()); } } Item produceItem(){ ... } } ``` And consumer threads could be implemented as follows: ```java public class Consumer implements Runnable { private MyQueue queue; public Consumer(MyQueue queue){ this.queue = queue; } @Override public void run() { while(true){ consumeItem(queue.dequeue()); } } void consumeItem(Item item){ ... } } ``` Finally, the main thread may for instance spawn one producer and two consumers: ```java MyQueue queue = new MyQueue\u003c\u003e(); Thread p1 = new Thread(new Producer(queue)); Thread c1 = new Thread(new Consumer(queue)); Thread c2 = new Thread(new Consumer(queue)); p1.start(); c1.start(); c2.start(); ``` Spurious wakeup # In the example above, the loop while(!isEmpty) (in the method enqueue) seems unnecessary, in the sense that it could be replaced with the conditional statements if(!isEmpty). And similarly for the loop in the method dequeue.\nThe purpose of this loop is to handle the abnormal case where a consumer (resp. producer) is awaken while the condition variable isEmpty has value false (resp. true). Such a situation is called a spurious wakeup, and may have a variety of causes (including a race condition).\nThis is the reason why it is customary to write:\nwhile(\u0026lt;conditionVariable\u0026gt;){ wait(); } rather than:\nif(\u0026lt;conditionVariable\u0026gt;){ wait(); } "},{"id":66,"href":"/docs/stream/sections/terminal/","title":"Terminal operation","section":"Streams in Java","content":" Terminal operation # A stream pipeline contains one terminal operation.\nThis operation may for instance:\nexecute a method for each element of the stream (e.g. print the value of each of them), or collect these elements (e.g. into a list), or inspect these elements (check whether all of them satisfy a certain condition), or aggregate these elements (e.g. sum the values of a stream of integers). Stream.forEach # This instance method is similar to Stream.map, in the sense that it also applies a callback method to each element of the stream. However, in this case, the callback method is not a function (i.e. it has no return value).\nIn other words, if the stream has type Stream\u0026lt;$\\mathit{T}$\u0026gt;, then foreach takes as argument a callback method of type\n$\\qquad \\mathit{T} \\to$ void\n(equivalently, in Java\u0026rsquo;s terminology, the callback method must implement the native functional interface Consumer\u0026lt;$\\mathit{T}$\u0026gt;, seen earlier).\n**_Example._** ```java Listlist = List.of(4, 1, 3, 2, 4); // outputs `4, `2` and `4` list.stream() .filter(x -\u003e x % 2 == 0) .forEach(System.out::println); ``` **_Hint._** In the absence of intermediate operation, the instance method `Collection.forEach` can be used instead, with the same effect: ```java Listlist = List.of(4, 1, 3, 2, 4); // ouputs `4`, `1`, `3`, `2`, and `4` list.forEach(System.out::println); ``` Collecting a stream # Stream.toList # This instance method outputs a final list with the elements of the stream.\n**_Example._** We already used this method in several of our examples. For instance ```java Listlist = List.of(2, 1, 3, 1, 2); // Contains [1, 1, 2, 2, 3] List ouputList = list.stream() .sorted() .toList(); ``` Stream.collect # This instance method takes as argument a so-called Collector, which is in charge of collecting the elements of the stream into a Collection (e.g. List or Set, or a Map, or a String, etc.\nThe utility class Collectors provides a variety of static methods that return a collector.\nCollectors.joining # This static method returns a collector that concatenates a stream of strings. joining (optionally) take a string as argument, which is used to separate the concatenated elements in the output string.\n**_Example_** ```java City ancona = new City(\"Ancona\", 60100); City bologna = new City(\"Bologna\", 40100); City matera = new City(\"Matera\", 75100); List cities = List.of(ancona, bologna, matera); // Contains the string `Ancona:Bologna:Matera` String concat = cities.stream() .map(c -\u003e c.name) .collect(Collectors.joining(\":\")); ``` Exercise The method `Files.list(path)` takes as argument a path to a directory, and returns an instance of `Stream`, whose elements are the entries in the directory. What does the method `mysteriousMethod` below return? ```java String mysteriousMethod(Path path) throws IOException { if(!Files.isDirectory(path)) { return \"\"; } return Files.list(path) .filter(p -\u003e path.toString().endsWith(\".txt\")) .flatMap(p -\u003e readLines(p)) .filter(l -\u003e l.contains(\"foo\")) .collect(Collectors.joining(System.lineSeparator())); } Stream readLines(Path path){ try { return Files.lines(path); } catch (IOException e) { throw new RuntimeException(e); } } ``` Solution A string that consists of all lines that contain the string `foo` in any `.txt` file of the directory. Collectors.toCollection # This static method takes as argument the constructor of a Java collection (e.g. HashSet::new, TreeSet::new, ArrayList::new, etc.), and returns a collector for this type of collection.\nList\u0026lt;Integer\u0026gt;list = List.of(2, 1, 3, 1, 2); // This is the TreeSet {1, 2, 3} Set\u0026lt;Integer\u0026gt; ouputSet = list.stream() .collect(Collectors.toCollection(TreeSet::new)); Collectors.toSet # As we saw in our initial pipeline example, this static method takes no argument, and returns a collector that produces a Java Set.\nThe Java specification does not require a specific implementation. So this set could for instance be a HashSetor a TreeSet, depending on the Java Virtual Machine that executes the program.\nList\u0026lt;Integer\u0026gt;list = List.of(2, 1, 3, 1, 2); // Contains {1, 2, 3} Set\u0026lt;Integer\u0026gt; ouputSet = list.stream() .collect(Collectors.toSet()); Collectors.toList # This static method is analogous to Collectors.toSet, but the collector that it returns produces a Java List. Again, there is no requirement on the specific implementation of this list.\nCollectors.toMap # This static method is analogous to Collectors.toSet and Collectors.toList, but the collector that it returns produces a Java Map.\nIf the stream has type Stream\u0026lt;$\\mathit{T}$\u0026gt;, then toMap takes as argument two callback functions, of type\n$\\qquad \\mathit{T} \\to K$\nand\n$\\qquad \\mathit{T} \\to V$\nrespectively, where $K$ and $V$ are arbitrary types.\nThe first callback method defines the keys of the map, and the second defines the values.\n**_Example._** The following method takes a list of cities, and returns a map from city name to city. ```java Map buildMap(List cities){ return cities.stream() .collect(Collectors.toMap( c -\u003e c.name, c -\u003e c )); } ``` **_Warning._** This method may throw an exception at runtime, in case of conflicting keys (in other words, if the first callback function is not [injective](http://localhost:41071/docs/background/sections/set_tuple_map/#function)). To make it robust, it is possible to pass it a [third callback method](https://www.baeldung.com/java-collectors-tomap#solving_key_conflicts), in charge of solving conflicts. Collectors.groupingBy # This static method returns a collector that groups the elements of the stream, based on some input grouping criterion. The grouping criterion is specified as a callback function.\n**_Example._** The following method take a list of units as argument, and returns a map from a color to a list of units that share this color: ```java Map"},{"id":67,"href":"/docs/generics/sections/variance/","title":"Variance","section":"Generic programming","content":" Variance # Subtype # **_Notation._** If $A$ and $B$ are types, we will use $A \\sqsubseteq B$ to denote the fact that $A$ is a [subtype](http://localhost:41071/docs/generics/sections/subtype/#subtype) of $B$. Subtype and substitution # The [Liskov substitution principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle) intuitively states that If $A \\sqsubseteq B$, then it should be possible to replace $B$ by $A$ in a program, without affecting the correctness of type checks. **_Examples._** - If `Integer` $\\sqsubseteq$ `Number`, then a method that takes a `Number` as input should also accept an `Integer`. - If `Butterfly` $\\sqsubseteq$ `Unit`, then a method that takes a `Unit` as input should also accept a `Butterfly`. Type parameters and subtyping # A natural question is whether subtyping between parameterized types should be determined by subtyping between their parameters.\nCovariance # **_Example._** Consider the generic type `Set` (where `T` is a type variable). - Should `Set` be treated as a subtype of `Set`? - Should `Set` be treated as a subtype of `Set`? More generally, if `A` $\\sqsubseteq$ `B`, then should `Set` be considered a subtype of `Set`? In this example, the intuitively answer to this question seems to be positive.\nWhen this holds, the generic type (i.e. Set\u0026lt;T\u0026gt; in this example) is said to be covariant.\n**_Definition._** Let `Gen` be a generic type (where `T` is a type variable). `Gen` is **covariant** if for any types `A` and `B`, $\\qquad$ `A` $\\sqsubseteq$ `B` implies `Gen` $\\sqsubseteq$ `Gen` Contravariance # What intuitively holds above for sets does not seem to hold for all generic types.\n**_Example._** Consider the Java functional interface `Predicate` (where `T` is a type variable), which stands for all functions that return a Boolean value, i.e. all functions with type $\\qquad$ `T` $\\to$ `Boolean` As we saw in the [dedicated section](http://localhost:41071/docs/generics/sections/subtype/#functionSubtype), if `A` $\\sqsubseteq$ `B`, then $\\qquad$ `B` $\\to$ `Boolean` should intuitively be considered a subtype of $\\qquad$ `A` $\\to$ `Boolean` Therefore in this case, we would like to treat `Predicate` as a subtype of `Predicate`. **_Definition._** Let `Gen` be a generic type, where `T` is a type variable. `Gen` is **contravariant** if for any types `A` and `B`, $\\qquad$ `A` $\\sqsubseteq$ `B` implies `Gen` $\\sqsubseteq$ `Gen` Invariance # **_Definition._** A generic type is **invariant** if it is neither covariant nor contravariant. Variance in several type variables # If a generic type has several type variables, then it can be independently covariant, contravariant or invariant in each of them.\n**_Example._** Consider the Java functional interface `Function` (where `T` and `R` are type variables), which stands for all functions with type $\\qquad$ `T` $\\to$ `R` As we saw in the [dedicated section](http://localhost:41071/docs/generics/sections/subtype/#functionSubtype), if `X1` $\\sqsubseteq$ `X2` and `Y1` $\\sqsubseteq$ `Y2`, then $\\qquad$ `X2` $\\to$ `Y1` should intuitively be considered a subtype of $\\qquad$ `X1` $\\to$ `Y2` Therefore in this case, we would like to treat `Function` as: - contravariant in `T`, and - covariant in `R`. Implementation # As we just saw with the previous examples, some generic types are naturally covariant and/or contravariant in (some of) their type variables.\nSome languages (like C#) provide a syntax to declare that a generic type should always be treated by the compiler as covariant, contravariant, invariant or a combination of them. However, Java does not offer this possibility.\nin Java # Arrays # Java arrays predate (by almost 10 years) the introduction of generics. Technically, in Java, \u0026ldquo;array\u0026rdquo; is not a generic type. But conceptually, it can be thought of as a \u0026ldquo;generic-like\u0026rdquo; type.\n**_Warning._** Java arrays are _covariant_. **_Example._** The following Java program compiles: ```java Number[] anArray; Integer[] anotherArray = new Integer[]{}; anArray = anotherArray; ``` Generic types # **_Warning._** Java generic types are _invariant_. **_Example._** The following Java program does _not_ compile: ```java List aList; List anotherList = new ArrayList\u003c\u003e(); aList = anotherList; ``` So a Java generic type cannot be declared as covariant or contravariant. However, each time we use a generic type, we can specify that it should be interpreted by the compiler as covariant or contravariant.\nCovariance # We saw earlier that the keyword extends specifies an upper bound on the value of a type variable. We can also use it with a ? to allow covariance.\n**_Example._** The following Java program does compiles: ```java List\u003c? extends Number\u003e aList; List anotherList = new ArrayList\u003c\u003e(); aList = anotherList; ``` Contravariance # The keyword super is symmetric to the keyword extends. It can be used to specify a lower bound on the value of a type variable, or to allow contravariance (in combination with ?).\n**_Example._** The instance method `Stream.filter` takes as argument a callback function with type `Predicate`, where `T` is the type of the elements of the stream. As we saw above, `Predicate` should intuitively be interpreted as contravariant. Accordingly, the signature of the method `filter` is ```java Stream filter(Predicate\u003c? super T\u003e predicate) ``` It accepts as argument any `Predicate` such that `T` $\\sqsubseteq$ `V`. So the following program compiles: ```java List integers = getIntegers(); integers.stream() .filter(MyClass::myPredicate); public class MyClass { static boolean myPredicate(Number number) { ... } } ``` Combinations # **_Example._** The instance method `Stream.map` takes as argument a callback function with type `Function`, where `T` is the type of the elements of the stream. As we saw above, the generic type `Function` should intuitively be interpreted as contravariant in `T` and covariant in `R`. Accordingly, the signature of the method `map` is: ```java Stream map(Function\u003c? super T,? extends R\u003e mapper) ``` When to use covariance or contravariance in Java? # Let us assume a generic type Gen with a type variable T . As a rule of thumb:\nif we use an instance method of Gen that does not take a T as argument, then we may allow Gen to be covariant in T, if we use a method of Gen that does not return a T, then we may allow Gen to be contravariant in T. **_Example._** ```java public class Box { T boxedValue; public Box(T boxedValue){ this.boxedValue = boxedValue; } T getValue(){ return boxedValue; } void setValue(T newValue){ boxedValue = value; } } ``` $\\qquad$ ```java // Covariance can be used, because the method Box.getValue() does not take a T as argument. Number unbox(Box\u003c? extends Number\u003e box){ return box.getValue(); } // Contravariance can be used, because the method Box.setValue() does not return a T. void replaceValue(Box\u003c? super Integer\u003e box, int integer){ box.setValue(integer); } ``` "},{"id":68,"href":"/docs/git/sections/commit/","title":"Add, commit, stash","section":"git","content":" Add, commit, stash # Staging files # Git lets you to choose which modifications will be part of your next commit.\nFirst, run\ngit status This will show which files have been added or modified since the last commit on the current branch (if any). In order to add (some of) these files to the next commit, you need to stage them.\nIf you want to stage all these files, from the root of the repository, run\ngit add . **_Hint._** You can create a [.gitignore](http://localhost:41071/docs/git/sections/ignore/) file to indicate files of folders that should never be staged. This allows you to use `git add .` without staging by accident compiled files, IDE-generated files, etc. Alternatively, to stage a specific file, run\ngit add \u0026lt;relative/path/to/file\u0026gt; At any moment, you can check which files have been staged with\ngit status You can also unstage all staged files with\ngit reset . And unstage a single file with\ngit reset \u0026lt;relative/path/to/file\u0026gt; Commit # Once you have staged your file, you can commit with\ngit commit -m \u0026#34;\u0026lt;commit message\u0026gt;\u0026#34; If you do not add the -m \u0026quot;\u0026lt;myMessage\u0026gt;\u0026quot; option to your command, then git will open a text editor where you can type a commit message. If this happens, then type your commit message, save and close the file.\n**_Warning._** By default, on most operating systems, git opens [vi](https://en.wikipedia.org/wiki/VI) as a text editor. I you have never used vi, we recommend [selecting another default text editor](http://localhost:41071/docs/git/sections/config/#textEditor). Stash # git stash temporarily reverts all modifications made to your repository since the last commit.\nTo apply them back, run\ngit stash pop "},{"id":69,"href":"/docs/intro/sections/board_game/","title":"Board game","section":"This course","content":" Board game # In order to follow this course, you will need to play one of the two following video games:\nMight \u0026amp; Magic: Clash of Heroes, or Legend of Solgard. These two games have very similar mechanics. So by default, we will refer to them as a unique game (e.g. when we write \u0026ldquo;this game\u0026rdquo; or \u0026ldquo;our board game\u0026rdquo;).\nWhy this game # Turn-based board games (like chess, go, checkers, etc.) are traditionally a good playground to learn the basics of algorithmic thinking.\n**_Disclaimer._** This course is _not_ about video game development, but general-purpose programming. This game will only serve as _didactic support_. Precisely, this game will serve two purposes:\nwe will use it as a running example throughout the lectures, and students can choose to implement (their own version of) this game as their group project. By default, we will focus on the two player variant, where both players play by the same rules. These two players may be humans and/or bots.\nHow long to play # Students only need to play long enough to understand the basic mechanics of the game.\n1.5 to 2 hours should be sufficient.\n**_Warning._** In both games, mechanics are introduced gradually, so it is difficult to get a full overview by playing less than an hour. Which game to choose # Might and Magic clash of heroes (MMCoH) # This game was initially released in 2009 for Nintendo DS. It has then been ported to PC and several consoles, as well as Android and iOS.\nA free demo was available on Steam until July 2023. The game has been re-released since, by another editor. As a result, the demo is not available on Steam anymore.\nThe Android and iOS versions have also been removed from the Google Play store and App store respectively.\n**_Advantages._** - The mechanics of this game may be easier to understand (in a short amount of time). - The default mode is the (symmetric) 2 player mode (player vs bot or player vs player) that we will work on. **_Drawbacks._** - The touch-screen interface on Android and iOS is arguably dated. Legend of Solgard # This game was released in 2016 for Android and iOS. It is still available on the Google Play store and the App store.\nIt is free to play, with optional microtransactions (via so-called loot boxes).\n**_Warning._** For this course, _no_ transaction is needed. **_Advantages._** - Animations can be sped up. - The touch-screen interface is more modern than the one of MMCoH for Android and iOS. **_Drawbacks._** - Progression is based on a (complex) system of virtual currencies, which may add noise to the interface. - The game can only be played (for free) a limited amount of time per day (approximately 45 min). - The default mode is _not_ the (symmetric) 2 players mode that we will work on (it requires more playtime to be unlocked). So an extra effort of imagination may be needed. "},{"id":70,"href":"/docs/errors/sections/custom/","title":"Custom exceptions","section":"Errors","content":" Custom exception # Custom exceptions can be created by extending one of Java\u0026rsquo;s native exception types. For instance:\npublic class WrongNumberOfRowsException extends IllegalArgumentException { public WrongNumberOfRowsException(int numberOfRows) { super(\u0026#34;This sudoku grid has \u0026#34;+numberOfRows+\u0026#34; rows, whereas it should have 9\u0026#34;). } } A custom exception can be thrown like a regular one:\nif(sudokuGrid.length != 9){ throw new WrongNumberOfRowsException(sudokuGrid.length); } **_Observation._** In this example, `WrongNumberOfRowsException` extends `IllegalArgumentException`, which extends `RuntimeException`. Recall that an instance of a subclass of `RuntimeException` is [unchecked](http://localhost:41071/docs/errors/sections/checked/#unchecked). Therefore an instance of `WrongNumberOfRowsException` is an unchecked exception. "},{"id":71,"href":"/docs/build/sections/dependencies/","title":"Dependencies","section":"Build automation","content":" Dependencies # Maven (like Gradle) acts both as a build automation tool and as a package manager.\nAs a package manager, Maven (like Gradle) relies by default a software repository called Maven Central. This repository contains more than 260.000 artifacts (more than 6 million when counting versions), with over a trillion downloads in 2023.\nAn artifact on Maven Central is identified by its coordinates.\nFinding a library\u0026rsquo;s coordinates # The coordinates of a library are often provided as part of its documentation. For instance, this is the case of Google\u0026rsquo;s Guava library.\nAlternatively, this website can be used to search for the coordinates of an artifact on Maven Central (as well as 1990 other repositories). For instance, here are the coordinates for the latest version of the Smile library for machine learning.\nLocal repository # By default, Maven _caches_ project dependencies (as [jars](http://localhost:41071/docs/build/sections/packaging/#jar)) in a hidden directory with path `/.m2` (or `\\.m2` on Windows). In Maven's terminology: - this directory is called the **local repository**, - an artifact is **installed** when it is added the local repository. When a project is build, Maven searches for each dependency in the local repository. If the corresponding artifact is not installed, then it is downloaded (e.g. from Maven central) and installed.\nGradle proceeds in a similar way (but the cache is under \u0026lt;homeFolder\u0026gt;/.gradle).\n**_Note._** The local repository can contain different versions of the same artifact. **_Note._** By default, when installing an artifact, Maven also installs _all its missing dependencies, transitively_. Gradle proceeds in a similar way. **_Warning._** Maven (like Gradle) does not support cyclic dependencies, i.e. an artifact cannot depend on itself (directly or transitively). Exercise Does this imply that the dependencies of an artifact form a tree? Solution No. A tree is a rooted acyclic graph, but the converse does not hold. To display the dependency graph of a project (unraveled as a tree), run:\nmvn dependency:tree If a project depends (transitively) on two versions of the same artifact, then the \u0026ldquo;closest\u0026rdquo; version (in the dependency graph) is chosen (or the first declared in case of a tie).\n**_Note._** If a project depends on a `SNAPSHOT` version, then the installed artifact is automatically updated on a regular basis (by default once per day), by both Maven and Gradle. Declaring a dependency # Maven # A dependency can be declared by adding the following to the pom.xml file, inside the \u0026lt;dependencies\u0026gt; tag:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt; XXX \u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt; XXX \u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt; XXX \u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; In addition, the attribute \u0026lt;scope\u0026gt;test\u0026lt;\\scope\u0026gt; can be added to indicate that the dependency is needed for unit tests only (other scopes can be specified).\n**_Example._** Here is how to declare dependencies on Guava, Smile and JUNIT 5, while specifying that the latter is only needed for unit tests: ```xml com.google.guava guava 33.1.0-jre com.github.haifengl smile-core 3.1.0 org.junit.jupiter junit-jupiter-api 5.10.2 test ``` Gradle # There are several alternative syntaxes to declare a dependency with Gradle (these may depend on the project\u0026rsquo;s configuration).\n**_Example._** If you chose the [board game](http://localhost:41071/docs/project/sections/board_game/) as your project, then you can declare a dependency in the file `core/build.gradle` as follows. Within: ```groovy dependencies { ... } ``` add a line: ```groovy implementation group: XXX, name: XXX, version: XXX ``` For instance: ```groovy implementation group: 'com.google.guava', name: 'guava', version: '33.1.0-jre' ``` To specify that the dependency is only needed for unit tests, replace implementation with testImplementation.\nUsing an external library # Once a dependency is declared, the classes and interfaces of the corresponding library can be used in the source code of the project, with a regular import statement.\n**_Example._** Guava provides a convenient class `ImmutableList` for lists that cannot be modified. It can be used as follows: ```java import com.google.common.collect.ImmutableList; public class MyClass { String name; ImmutableList values; public MyClass(String name, ImmutableList values){ this.name = name; this.values = values; } ... } ``` **_Hint._** Import statements like the one above can be automatically generated by your IDE. "},{"id":72,"href":"/docs/objects/sections/tostring/","title":"Displaying objects","section":"Objects and classes","content":" Displaying objects # The class Object # Java has a native class called `Object` with [11 instance methods](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html). Every Java class implicitly extends `Object`, _including user-defined classes_. Therefore any Java class _inherits_ these methods. The method toString # toString is one of the methods of the class Object. Here is (part of) its specification:\n/** Returns a string representation of the object. * In general, the toString method returns a string that * \u0026#34;textually represents\u0026#34; this object. */ public String toString(); This is the preferred way to display information about an object. For instance, the debugger of your IDE probably relies on this method to display a string that represents an object.\nThis method is also called by many (native or not) methods and operators. For instance, the following program\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); System.out.println(myUnicorn); String message = \u0026#34;Hello \u0026#34; + myUnicorn; is equivalent to\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); System.out.println(myUnicorn.toString()); String message = \u0026#34;Hello \u0026#34; + myUnicorn.toString(); Overriding toString # The default implementation of toString (in the class Object) displays very little information about the object:\npublic String toString() { return getClass().getName() + \u0026#34;@\u0026#34; + Integer.toHexString(hashCode()); } **_Warning._** The output of `hashCode()` in this example is _not_ the reference (a.k.a. \"memory address\") of the object. So a common practice consists in overriding toString. For instance, here is a possible implementation of the method toString within a class Unicorn:\npublic class Unicorn { String color; int health; @Override public String toString() { return \u0026#34;Unicorn{\u0026#34; + \u0026#34;color=\u0026#34; + color + \u0026#34;, \u0026#34; + \u0026#34;health=\u0026#34; + health + \u0026#34;}\u0026#34;; } } **_Hint._** Your IDE can generate such a method. Recursion # A naive implementation of toString (e.g. generated by an IDE) may have unexpected effects.\nExercise Consider an implementation of our game where units (on each side of the board) are grouped by column. This implementation may use a class `Column` to represent a column and the adjacent one(s), as follows: ```java public class Column { Unit[] units; // null if this is the left-most column Column leftAdjacentColumn; // null if this is the right-most column Column rightAdjacentColumn; public Column(Unit[] units){ this.units = units; } @Override public String toString() { return \"Column{\" + \"left=\" + leftAdjacentColumn +\", \" + \"right=\" + rightAdjacentColumn +\", \" + \"units=\" + units + \"}\"; } } ``` Then a board may be created as follows: ```java Unit[] a1 = new Unit[]{ new Unicorn(\"green\") }; Column c1 = new Column(a1); Unit[] a2 = new Unit[]{ new Butterfly(\"yellow\") }; Column c2 = new Column(a2); c1.rightAdjacentColumn = c2; c2.leftAdjacentColumn = c1; System.out.println(c1); ``` There is an issue with this program. Can you identify it? Solution The program does not terminate, because `toString` is (implicitly) recursive, and each of the two columns refers to the other. "},{"id":73,"href":"/docs/unittests/sections/junit/","title":"in Java","section":"Unit tests","content":" Unit tests in Java # Several frameworks are available in Java for unit tests. Popular frameworks include:\nJUnit 4 JUnit 5 TestNG Spock In this section, we focus on Junit 5.\nInstall Junit 5 with Maven # Junit 5 can be used in a Maven project by declaring the following dependency and plugin\n\u0026lt;dependencies\u0026gt; ... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.10.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; ... \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; ... \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-surefire-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.5\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; ... \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; For the latest versions, search Maven Central.\nLayout # Maven # Recall that in a Maven project, by default:\nsource code for unit tests is located in the directory src/test/java, resources for unit tests (e.g. data) are located in the directory src/test/resources. **_Note._** You can create sub-directories (in these directories) to organize your tests and resources. Gradle # Junit 5 can be used with Gradle in a similar way, but the directories for unit tests and related resources and (usually) specified manually.\n**_Hint._** If you chose the [board game](http://localhost:41071/docs/project/sections/board_game/) as your project, then you can write JUnit 5 tests under `core/src/test/java`. You will also find (dummy) unit tests in the directory `core/src/test/java/dummy`. Writing unit tests # With Maven, any (public or protected) Java class in src/test/java (or a subdirectory) can contain JUnit tests.\nA **Junit 5 test** is a (public or protected) _instance method_ : - with `void` return type, - annotated with `org.junit.jupiter.api.Test`. In addition, the method usually contains one or several calls to static methods of JUnit\u0026rsquo;s Assertions class, like assertEquals or assertThrows. The test succeeds iff all these calls return true.\nFor instance, the following class contains a single (successful) test:\nimport org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class MyTests { @Test void myTest(){ String myString = \u0026#34;foo\u0026#34;; assertEquals(true, myString.contains(\u0026#34;oo\u0026#34;)); } } **_Warning._** The method `assertEquals` takes the expected value as first argument, and the actual one as second argument. This has an incidence on logs in case of test failure (\"expected\" : XXX, \"actual: \"YYY\"); **_Hint._** A string can be passed to `assertEquals` as third argument, in order to display an additional message in case of failure. **_Hint._** Most methods of the class [Assertions](https://junit.org/junit5/docs/5.0.1/api/org/junit/jupiter/api/Assertions.html) are syntactic sugar (thus not strictly necessary). For instance ```java assertTrue() ``` is a shortcut for ```java assertEquals(true, ) ``` **_Warning._** By default, the execution of a test method is interrupted as soon as an assertion fails. So following instructions (for instance other assertions) will _not_ be executed. Checking exceptions # The assertion assertThrows allows checking whether the execution of a piece of code method throws an exception of a given type. For instance the following unit test succeeds:\n@Test void testException(){ assertThrows( ArithmeticException.class, () -\u0026gt; { int x = 2 / 0; } ); } Prior and/or subsequent code # The annotation @BeforeAll (resp. @AfterAll) can be used to indicate that a (static) method must be executed (only once) before (resp. after) all unit tests in the class, regardless of test successes or failures. This can be used for costly operations, or for opening (resp. closing) a resource, like an connection or an input (resp. output) stream. For instance\nimport org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.Test; import java.sql.Connection; public class SQLTests { Connection myConnection; @BeforeAll static void openConnection(){ ... } @Test void test1(){ ... } @Test void test2(){ ... } @AfterAll static void closeConnection(){ ... } } Similarly the annotation @BeforeEach (resp. @AfterEach) can be used to indicate that a method must be executed before (resp. after) each unit test in the class. This can be convenient to avoid copy-pasting code. For instance\nimport org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; public class BoardgameTests { Snapshot testSnapshot; @BeforeEach void createTestSnapshot(){ testSnapshot = new DummySnapshot(); } @Test void test1(){ ... } @Test void test2(){ ... } } Disabling tests # A unit test can be disabled with the annotation @Disabled. As a result, it will be ignored by Maven, Gradle, and (to some extent) your IDE. For instance:\nimport org.junit.jupiter.api.Disabled; import org.junit.jupiter.api.Test; public class MyTests { @Test @Disabled void test1(){ ... } @Test void test2(){ ... } } Running unit tests # from the command line # For a Maven project, the command\nmvn test executes all phases that precede the test phase (e.g. compile and test-compile) in Maven\u0026rsquo;s default lifecycle, and then executes all unit tests under src/test/java.\n**_Note._** The source code of unit tests (and related resources) is by default _excluded_ form the output of the `package` phase (e.g. from the jar produced by Maven). **_Note._** A unit test failure will prevent execution of Maven phases that are posterior to `test`. For instance ```bash mvn package ``` does _not_ produce the expected jar if a test fails. However, if needed, it is possible to execute a posterior Maven phase while skipping the unit tests, with the option `-DskipTests`. For instance: ```bash mvn package -DskipTests ``` within an IDE # IDEs provide several ways to run unit tests, either:\nin isolation, or all tests within a class, or all tests within a package (including subpackages). For instance, with IntelliJ:\nclick on the green arrow to run a single unit test, click on the double green arrow to run all unit tests defined in the current class, right click on a folder and select \u0026ldquo;Run Tests\u0026rdquo; to run all tests in this package. **_Note._** Within an IDE, a unit test can (and most often should) be run in _debug_ mode. For instance, with IntelliJ, right-click on the green arrow and select 'Debug'. "},{"id":74,"href":"/docs/stream/sections/numeric/","title":"Numeric stream","section":"Streams in Java","content":" Numeric stream # In addition to the interface Stream, Java 8 introduced the interface IntStream (resp. DoubleStream, LongStream) that represents a stream of (unboxed) int (resp. long, double).\nIt provides operations that are not available in Stream\u0026lt;Integer\u0026gt; (resp. Streanm\u0026lt;Double\u0026gt;, Stream\u0026lt;Long\u0026gt;).\n**_Warning._** The interface `IntStream` (resp. `DoubleStream`, `LongStream`) does _not_ extend the interface `Stream`. Conversion # A instance of Stream\u0026lt;$T$\u0026gt; can be converted to an instance of IntStream (resp. DoubleStream, LongStream) with the instance method Stream.mapToInt.\nThis method takes as argument a callback method of type\n$\\qquad T \\to$ int\nthat converts each element of the stream to an int.\n**_Example._** The following method converts a list of cities into an `IntStream` that contains their zip codes. ```java IntStream extractZipCodes(List cities){ return cities.stream() .mapToInt(c -\u003e c.zipCode); } ``` Operations # Numeric streams provide operations that are not available in standard streams, such as sum and average.\n"},{"id":75,"href":"/docs/env/sections/os/","title":"Operating system","section":"Development environment","content":" Operating system (OS) # Your computer does not bind you to one OS. You can run multiple OSs on the same computer by:\npartitioning your disk, or booting from an external drive, or using virtualisation. Depending on what you are developing, one operating system may be more convenient than another.\nWe review below some of the benefits and drawbacks of developing under Windows, macOS and Linux.\nWindows # Benefits and drawbacks # Here are some benefits of using Windows as your OS for software development:\nit comes pre-installed on most PCs, it is compatible out-of-the-box with most hardware, it provides a fully integrated development suite for the .NET framework (C#, F#, Visual Basic), and to a lesser extent C/C++. And some drawbacks:\nfor general-purpose development, Windows is not friendly to new programmers (compared to Linux or macOS), the usage of an (OS-wise) package manager is (still) not the norm, it sometimes favors backwards compatibility over compliance with modern standards. When to use Windows (and when not) # Windows is the OS of choice for developing software meant to run on Windows only, or cross-platform software written in one of the .NET languages (mostly C#). C# is notably used for game development (e.g. for Unity) and graphical interfaces (although Javascript-based graphical frameworks may have become more popular lately). Another interesting feature of C# (compared to Java) is the Language Integrated Query framework, which provides a tight integration with database engines.\nVisual studio (not VSCode!) offers a fully integrated development suite for the .NET languages, and is also commonly used for C/C++.\nFor other programming languages, using Windows may require extra efforts or precautions (compared to Linux or macOS), especially for new developers.\nIn particular, manual software installation/upgrade/removal can be complex and error-prone. Writing scripts (e.g. for two programs to interact) can also be more involved, especially given the fact that Windows has three shells (the Windows shell, the Windows Power Shell and Power Shell), or four if counting WSL.\nBesides, additional care must be taken to write platform-independent code. Here are for instance two frequent sources of errors made by students:\nPath names: Windows uses \\ as a path separator, as opposed to the / used by other OSs (or in web URIs). In Java, a path can be safely written with `/`. At run time (i.e. when the program is executed), this symbol will be interpreted based on the underlying OS (i.e. as `\\` on Windows, and as `/` on other OSs). However, a path written with `\\` will be interpreted as such (therefore the program will throw an exception on OSs other than Windows). Line breaks: many text editors for Windows encode a line break as two ascii characters (\\r\\n), against a single character (\\n) on most modern systems. This is often transparent for regular users, because many text editors (or even git) use detection and normalization procedures for line breaks. However, this may be a source of bugs for developers, for instance when generating code, or when writing a script to configure a virtual environment (e.g. a Docker image). For this course # You should be able to complete all assignments and write your project using Windows (even if your collaborators use other OSs).\nHowever, you may need to pay extra attention, for instance to path names (as explained above). Installing and configuring the necessary software may also be more complex (again, we recommend using a package manager when possible).\nIf you do not manage to set up your working environment for this course (see the requirements) in a short amount of time, then consider using a Linux distribution instead (see the dedicated section below for using Linux alongside Windows).\nmacOS # Here are some benefits of using macOS as your OS for software development:\nit comes pre-installed with an Apple computer, it is POSIX-compliant (since 2001), thus offering easier interoperability with Linux/BSD/Android/IOS the homebrew package manager is relatively mature. And some drawbacks:\nsome software may not be available, your working environment is not easily customizable. When to use macOS (and when not) # MacOS is rarely used on hardware other than Apple computers.\nIt is often a good choice for new developers. In particular, homebrew offers an easy way to install programs needed for general-purpose development (compilers, interpreters, other package managers, etc.), and its software repository is reasonably comprehensive in that regard (albeit smaller than repositories used by Linux distributions).\nA number of more experienced developers also work with macOS, notably for web development (Node.js/Javascript) or data science related projects (Python).\nA Linux distribution may be more convenient in some situations, e.g. when developing a program meant to run on a server, or when working with Docker containers.\nFor this course # If you have a Apple laptop, then you should not need an OS other than macOS for this course (even if your collaborators use other OSs).\nLinux # Here are some benefits of using Linux as your OS for software development:\nit is used by most web servers servers, it is relatively lightweight, for developers, it has an important (and high-quality) online community support, (OS) package managers are mature and easy to use, your working environment can be easily customized and/or configured. And some drawbacks:\nLinux rarely comes pre-installed on a computer, there sometimes too much choice of programs or distributions, Linux distributions are (still) not as friendly to desktop users as Windows or macOS, Hardware support (e.g. for peripherals) is (still) more limited than for Windows. When to use Linux (and when not) # Linux is often the OS of choice for developing programs meant to run on web servers. It is also a good choice for writing cross-platform software.\nLinux (together with macOS) is also a good environment to learn the basics of programming, due to native compatibility with a wide range of technologies for general-purpose development (e.g. Docker). Software installation, configuration, upgrade and removal is also made easier by mature package managers. Besides, the Linux shell is a versatile yet relatively simple tool that can ease process management or interaction between programs.\nLinux is arguably not the best choice for developing Desktop applications that target a specific OS (such as Windows or macOS), or in some specific domains such as game development.\nFor this course # You should be able to complete all assignments and write your project using a Linux distribution (even if your collaborators use other OSs).\nIn particular, if you face important issues when setting up your working environment (git, JDK, Maven, Gradle, etc. ) on Windows, we recommend using a Linux distribution instead (because it may save you time). Keep in mind however that this will not solve issues related to the configuration of your IDE.\nNot that you can use Linux (for development) and Windows (for other purposes) on the same computer.\nWhich distribution to choose # You can use any (reasonably mainstream) all-purposes Linux distribution for this course (and other courses).\nThe choice may seem overwhelming at first sight, but most distributions are forks of a few popular ones (Debian, Fedora, Arch, \u0026hellip;), and are relatively similar to each other. Besides, Linux environments are highly customizable: for instance, the choice of a distribution does not bind you to its default desktop environment. Available software is also very similar from one distribution to another: regardless of the distribution, you will have access to openJDK, git, Maven, etc. via a package manager.\nDistributions that are more desktop-oriented can be more friendly to newcomers (especially non-developers), but also come with unnecessary software. Two popular distributions in this category (for new users) are Linux Mint and Zorin OS. Both are forks of Ubuntu, which is itself a fork of Debian.\nFor a (slightly) more lightweight distribution, MX Linux is currently a popular choice. It is also based on Debian.\nHow to install a Linux distribution # Most distributions provide detailed instructions on their web page.\nRegardless of the distribution, you have are (at least) three possible options:\nVirtual machine (such as VirtualBox). This is the simplest option in terms of installation. But also the most expensive computationally, so only suited to a relatively powerful computer. Performance is also suboptimal.\nA virtual machine is often good way to test a distribution before properly installing it.\nBootable drive. You can store your Linux distribution on an external hard drive, and boot on Linux when the hard drive is connected to your computer. Compared to the third option below, this may affect the performance of disk access.\nPartition (with dual boot). You can dedicate a certain amount of space to a Linux distribution your hard drive. A minimum of 30 GB is often recommended, but this can be adjusted later on. When starting your computer, it will let you choose which OS to boot on. This is the best option in terms of performance.\n**_Note._** For the third option (dual boot), the installation procedure has become more involved on some recent computers, due to encrypted disks or so-called \"secure boot\". So make sure that the instructions that you follow are up-to-date. "},{"id":76,"href":"/docs/generics/sections/erasure/","title":"Type erasure","section":"Generic programming","content":" Type erasure in Java # Java compilers rely on an approach called **_type erasure_** to compile: - type parameters (e.g. `Box`), - type variables (e.g. `Box`), and - question marks (e.g. `Box\u003c? extends Number\u003e`). More often than not, when a Java program does not compile, we can understand why without understanding the compilation procedure. However, for generics, some basic understanding of type erasure can help.\nProcedure # Intuitively, type erasure consists in producing a program equivalent to the initial one, but free of generic or parameterized types (i.e. intuitively with no \u0026ldquo;diamond\u0026rdquo;).\nInformally, a Java compiler first performs all type checks specified in the program. If all type checks succeed, then:\neach type variable or question mark is replaced with its (upper or lower) bound (if any), or Object if there is none, explicit casts are introduced where they become necessary (as well as so-called bridge methods if needed, to ensure that overriden methods remain overriden), all type parameters, type variables and question marks are deleted. Illustrations # **_Warning._** Type erasure is traditionally illustrated with a Java program before and after erasure (for instance, in Oracle's [Java tutorials](https://docs.oracle.com/javase/tutorial/java/generics/erasure.html)). However, these illustrations should _not_ be taken literally, because compilation produces _byte code_, not source code. **_Example._** Consider the generic class `Box` that we used [earlier](http://localhost:41071/docs/generics/sections/variance/#covarContravarUsage) illustrate covariance and contravariance, together with the methods `unbox` and `replaceValue`: ```java public class Box { T boxedValue; public Box(T boxedValue){ this.boxedValue = boxedValue; } T getValue(){ return boxedValue; } void setValue(T newValue){ boxedValue = value; } } ``` $\\qquad$ ```java Number unbox(Box\u003c? extends Number\u003e box){ return box.getValue(); } void replaceValue(Box\u003c? super Integer\u003e box, Integer integer){ box.setValue(integer); } ``` The bytecode generated after type erasure may be equivalent to bytecode generated for the following program: ```java public class Box { Object boxedValue; public Box(Object boxedValue){ this.boxedValue = boxedValue; } Object getValue(){ return boxedValue; } void setValue(Object newValue){ boxedValue = value; } } ``` $\\qquad$ ```java Number unbox(Box box){ return (Number) box.getValue(); } void replaceValue(Box box, Integer integer){ box.setValue(integer); } ``` **_Example._** Generic methods are compiled in a similar way. For instance, consider once again our generic method ```java T healthiest(T[] units) { ... } ``` The bytecode generated after type erasure may be equivalent to bytecode generated for a method: ```java Unit healthiest(Unit[] units) { ... } ``` Consequences # Runtime # A first important consequence of type erasure (e.g. for debugging) is that parameterized types do not exist at runtime (as opposed C++ or C#).\nFor instance, a JVM cannot distinguish an instance of Box\u0026lt;Integer\u0026gt; from an instance of Box\u0026lt;String\u0026gt;. Both are instances of the same class Box.\nCompile-time # Type erasure may also explain in some cases why a Java program are invalid.\nWe list here two simple cases (among others).\nAmbiguity # Java (like C++ or C#) allows defining two methods with the same name in the same class, as long as they have different argument types (this is called method overloading). However, after type erasure, this may result in two methods with the same name and arguments (which is forbidden).\n**_Example._** The following program does _not_ compile: ```java public class MyClass { void myMethod(String s, T t) { ... } void myMethod(String w, V v) { ... } } ``` Constructor # A type parameter cannot be instantiated.\n**_Example._** The following program does _not_ compile: ```java public class Box { T create(){ return new T(); } } ``` "},{"id":77,"href":"/docs/lambda/sections/type/","title":"Type of a method","section":"Callback methods and lambda expressions","content":" Type of a method # **_Terminology._** The **type** (a.k.a. **signature**) of a method consists of: - the type(s) of its argument(s), and - its return type. **_Notation._** The type of a method is sometimes described analogously to the type of a mathematical [function](http://localhost:41071/docs/background/sections/set_tuple_map/#function). For instance, consider the following Java method `square`: ```java int square(int x){ return x * x; } ``` This method takes as input an `int`, and returns an `int`. In other words, this is a function with domain `int` and codomain `int`. This is written: $\\qquad$`square`$\\colon$ `int` $\\to$ `int` And the type of this function is $\\qquad$ `int` $\\to$ `int` Similarly, we may use: - `int` $\\times$ `int` $\\to$ `int` if the method takes two `int` and returns another, - `Unit` $\\times$ `int` $\\to$ `Unit` if the method takes a `Unit` and an `int` (in that order) and returns a `Unit`, - `Unit[]` $\\to$ `void` if the method takes an array of `Units[]` and returns nothing, - etc. in Java # Syntactically, Java does not provide a method typing system like the one above. Instead, Java uses (abuses?) interfaces for this purpose.\nFunctional interface # A method type in Java is described with a so-called functional interface.\n**_Syntax._** A Java **functional interface** is an [interface](http://localhost:41071/docs/interfaces/sections/java_interfaces/) with a single (standard) method. **_Note._** In this definition, \"standard\" method stands for a method that does not have the [default](http://localhost:41071/docs/interfaces/sections/java_interfaces/#interfaceVsAbstractClass) qualifier (\"standard\" interface methods are also called \"abstract\"). **_Example._** The following is a functional interface, which describes the type `Unit` $\\times$ `Integer` $\\to$ `Unit`. Any method with type `Unit` $\\times$ `Integer` $\\to$ `Unit` implements this interface. ```java interface UnitPerIntegerToUnit { Unit myMethod(Unit unit, Integer x); } ``` The name of a functional interface is irrelevant, as well as the name of its method (and the arguments of this method).\n**_Example._** The following functional interface also describes the type `Unit` $\\times$ `Integer` $\\to$ `Unit`. ```java interface Just { Unit because(Unit we, Integer can); } ``` A functional interface can be annotated with @FunctionalInterface. This will for instance cause a compilation error if the interface has more than one (non-default) method.\n**_Example._** ```java @FunctionalInterface interface UnitPerIntegerToUnit { Unit myMethod(Unit unit, Integer x); } ``` Native functional interfaces # Java provides native (parameterized) functional interfaces for some frequent method types.\nWe highlight here a few of them:\nFunction # The functional interface `Function` stands for the type `InputType` $\\to$ `OutputType`. Its method is called `apply`. **_Examples._** - a method with type `Unit` $\\to$ `Integer` implements the functional interface `Function` - a method with type `Unit` $\\to$ `Unit` implements the functional interface `Function` Consumer # The functional interface `Consumer` stands for the type `InputType` $\\to$ `void`. Its method is called `accept`. **_Examples._** - a method with type `Integer` $\\to$ `void` implements the functional interface `Consumer` - a method with type `Unit` $\\to$ `void` implements the functional interface `Consumer` Supplier # The functional interface `Supplier` stands for the type `void` $\\to$ `OutputType`. Its method is called `get`. **_Examples._** - a method with type `void` $\\to$ `Integer` implements the functional interface `Supplier` - a method with type `void` $\\to$ `Unit` implements the functional interface `Supplier` Comparator # The interface Comparator\u0026lt;T\u0026gt; (already seen in the section dedicated to sorting) is functional. Its method is called compare, and has type T $\\times$ T $\\to$ int.\n"},{"id":78,"href":"/docs/intro/sections/bibliography/","title":"Bibliography","section":"This course","content":" Bibliography # Java\u0026rsquo;s syntax # This website contains Java code snippets that illustrate how to perform certain operations. However, this documentation is far from exhaustive (on purpose).\nWhen it comes to syntax, the first two sources of complementary material for this course are:\nthe Javadoc of the libraries (standard and auxiliary) used in projects and assignments. An IDE is often the fastest way to navigate through it, the web. Books # A reading list for this course is available in the catalogue of the Unibz\u0026rsquo;s library. All books can be accessed via the library (either physically or digitally).\nAmong these books, we highlight the following two:\nMain textbook # Java: How to Program, Early Objects (11th edition)\nby Paul Deitel and Harvey Deitel\nPearson, 2018\nThis is a general introductory book to Java and object oriented programming. It covers most of the topics seen in this course.\nGood practices # Effective Java (3rd edition)\nby Joshua Bloch\nAddison-Wesley Professional, 2017\nThis is a reference book for best practices and common pitfalls when programming in Java.\n"},{"id":79,"href":"/docs/build/sections/building/","title":"Building","section":"Build automation","content":" Building # Cleaning # The command\nmvn clean attempts to delete all content generated during a previous build (in particular, .class files).\n**_Example._** Let us assume that `MyClass.java` is compiled into `MyClass.class`, and then renamed `MyNewClass.java`. In this scenario, `mvn clean` allows eliminating the file `MyClass.class` from the `target` directory. The default lifecycle # Maven's **default lifecycle** is a _sequence_ of [23 operations](https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#default-lifecycle) (called **phases**) that can be executed during a build. These include (in order):\nvalidate: checks if all the information needed for the build is present compile: compiles the source code of the project test-compile: compiles the source code of the unit tests of the project test: runs the unit tests package: packages the compiled code in its distributable format (such as a jar) install: installs the package into the local repository (for use as a dependency in other local projects) Each phase can be executed via command-line with mvn \u0026lt;phaseName\u0026gt;. For instance:\nmvn package **_Warning._** Executing any of these phases triggers the execution of _all phases that precede it_. For instance, executing the test phase triggers the execution of validate, compile and test-compile (among others).\nGoals and plugins # A build phase (like `package`) consists of so-called **goals**. A goal can be declared, configured and associated to a specific phase via a so-called **plugin**. In a POM:\na plugin is specified within the \u0026lt;plugin\u0026gt;\u0026lt;/plugin\u0026gt; tag, and plugins are declared within: \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; ... \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; For instance, here is the plugin called maven-jar-plugin, as it is inherited from the Super POM:\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; ... \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;default-jar\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;jar\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; ... \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; This plugin assigns the goal jar to the phase package. Intuitively, this specifies that the phase package must produce a jar file (as opposed to other formats like war or ear).\nIn order to make this jar executable (and specify the main class of the application), we can add information to this inherited plugin, in the pom.xml file of the project, as follows:\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; ... \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;addClasspath\u0026gt;true\u0026lt;/addClasspath\u0026gt; \u0026lt;mainClass\u0026gt;org.example.Main\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; ... \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; The effective POM in this example contains:\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; ... \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;default-jar\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;jar\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;addClasspath\u0026gt;true\u0026lt;/addClasspath\u0026gt; \u0026lt;mainClass\u0026gt;org.example.Main\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; ... \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; A plugin can contain several goals, and these may or may not be assigned to a specific phase.\nBesides, a goal can be executed independently from a phase, with the command:\nmvn myplugin:myGoal For instance, the javafx maven plugin has a goal run to start a JavaFX application. It can be executed with:\nmvn javafx:run Installing a plugin # Maven plugins are available for a variety of tasks, like code analysis, Javadoc generation, parser generation, etc.\nAn plugin is a Maven artifact. Similarly to a dependency, an external plugin can be downloaded from Maven Central and installed into the local repository , as follows:\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; ... \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt; XXX \u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt; XXX \u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt; XXX \u0026lt;/version\u0026gt; ... \u0026lt;/plugin\u0026gt; ... \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; However, as illustrated above, additional XML attributes may be needed to configure the plugin. These are often specific to a plugin.\nUseful plugins # The assembly plugin # The assembly plugin allows building a Ã¼ber jar (i.e. including dependencies), as opposed to the maven-jar-plugin, which can build a thin jar.\nThis is a simple way to distribute an end-user application (as opposed to a library).\n\u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-assembly-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.7.1\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;single\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;mainClass\u0026gt;org.example.MainClass\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;descriptorRefs\u0026gt; \u0026lt;descriptorRef\u0026gt;jar-with-dependencies\u0026lt;/descriptorRef\u0026gt; \u0026lt;descriptorRef\u0026gt;src\u0026lt;/descriptorRef\u0026gt; \u0026lt;/descriptorRefs\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; In this example, the execution of the goal (called single) is attached to the phase package, so the Ã¼ber jar can be produced like a regular jar, with:\nmvn package The source plugin # The source plugin can package source code as a jar. This allows:\ndistributing a Java library alongside its source code, and/or installing the library in the local repository together with the source (and navigate through it with an IDE). \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-source-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.1\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;attach-sources\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;verify\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;jar-no-fork\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; In this example, the execution of the goal (called jar-no-fork) is attached to the phase verify.\nThe Javadoc plugin # \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-javadoc-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.6.3\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;17\u0026lt;/source\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; This plugin has many goals, which are often executed independently (i.s. not bound to a phase).\nFor instance:\nmvn javadoc:javadoc generates Javadoc for the project in the folder target/site.\n"},{"id":80,"href":"/docs/lambda/sections/callback/","title":"Callback method","section":"Callback methods and lambda expressions","content":" Callback method # When a method takes another method as argument, the latter is a **callback method**. Anonymous methods are often used as callback methods.\nin Java # Running example # **_Example._** The two following Java methods have the same structure: both modify each unit in the input list. ```java void boostUnits(List units){ for(Unit unit: units){ unit.health++; } } void penalizeGreenUnits(List units){ for(Unit unit: units){ if(unit.color.equals(\"green\")){ unit.health--; } } } ``` In each case, let us isolate the modification that is applied to a single unit, with a dedicated method (called `boost` and `penalizeGreen` respectively). ```java void boost(Unit unit){ unit.health++; } void penalizeGreen(Unit unit){ if(unit.color.equals(\"green\")){ unit.health--; } } ``` Both methods have type `Unit` $\\to$ `void`, so they are instances of the [functional interface](http://localhost:41071/docs/lambda/sections/type/#functionalInterface) `Consumer`. This allows us to factorize our code with a method `transform` that takes as input: - an array of units, - a callback method with type `Consumer`, and applies the callback method to each unit in the input array. ```java void transform(List units, Consumer method){ for (Unit unit: units){ method.accept(unit); } } ``` Passing a callback method # A callback method in Java can be:\na method reference, or a lambda expression. Method reference as a callback method # **_Syntax._** A Java **method reference** is written: - `ClassName::methodName` for a static method, - `objectVariable::methodName` for an instance method, - `ClassName::new` for a constructor. **_Example (continued)._** Let us assume that our methods `boost` and `penalizeGreen` above are static methods of some class called `UnitTransformer`: ```java public class UnitTransformer{ static void boost(Unit unit){ unit.health++; } static void penalizeGreen(Unit unit){ if(unit.color.equals(\"green\")){ unit.health--; } } } ``` We can call our method `transform` with `boost` as callback method: ```java List units = getUnits(); transform( units, UnitTransformer::boost ); ``` And similarly with `penalizeGreen`: ```java List units = getUnits(); transform( units, UnitTransformer::penalizeGreen ); ``` Lambda expression as a callback method # Alternatively, instead of declaring a method boost, we can directly use a lambda expression:\n**_Example (continued)._** ```java List units = getUnits(); transform( units, unit -\u003e unit.health++ ); ``` And similarly, instead of declaring a method `penalizeGreen`, we can use the following lambda expression: ```java List units = getUnits(); transform( units, unit -\u003e { if(unit.color.equals(\"green\")){ unit.health-- ; } ); ``` Native support # Programming languages that support anonymous methods (like Java, Python, C#, C++, JavaScript, etc.) often provide concise syntaxes to use them as callback methods.\n**_Example(continued)._** In Java, the above method `transform` is not necessary. Instead, we can use the native method [forEach](http://localhost:41071/docs/stream/sections/terminal/#forEach), available (among others) for any Java [Collection](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Collection.html). This method takes a `Consumer` method as input, and applies this method to each element of the collection. So the following program: ```java getUnits().forEach(unit -\u003e unit.health++); ``` is equivalent to: ```java transform( getUnits(), unit -\u003e unit.health++ ); void transform(List units, Consumer method){ for (Unit unit: units){ method.accept(unit); } } ``` "},{"id":81,"href":"/docs/objects/sections/comparing/","title":"Cast and equality","section":"Objects and classes","content":" Cast and Equality # Cast # Java (as well as C# and C++) provides mechanisms to change the type associated with an object _o_, using either a _supertype_ of _o_ (this is an **upcast**), or a _subtype_ of _o_ (this is a **downcast**). Upcast # Explicit upcasts are uncommon, but may still be useful in some scenarios, e.g. to disambiguate two method calls.\nImplicit upcasts on the other hand are very frequent, when the type of an object cannot be determined at compile time.\n**_Example._** Consider the following classes: ![](/img/diagrams/plantuml/downcast_simple.svg) Now consider the following program, where the method `getUnits` produces an array of units that depends on the player's input. The type of objects in this array (`Unicorn` or `Butterfly`) cannot be determined at compile time. Thanks to the implicit upcast, they can nonetheless be treated as (underspecified) units. ```java Unit[] units = getUnits(); for (Unit unit: units){ System.out.println(unit.health); } ``` Downcast # Downcasting in Java is frequent for objects whose type cannot be determined at compile time. However, this may not be safe. For instance, in the above example, downcasting a unit from Unit to Unicorn may cause a ClassCastException (at runtime), because this unit is a instance of Butterfly. This is why downcasting is often used in combination with the instanceof operator. For instance the above example can be modifed as follows:\nUnit[] units = getUnits(); for (Unit unit: units){ if(unit instanceof Unicorn){ ((Unicorn) unit).regen(); } } Here the operation (Unicorn) unit is a downcast. The output of this operation has type Unicorn, thus allowing the call to the method regen.\nObject equality # As we saw in a previous chapter, a constructor in Java creates an object in memory and returns a (fresh) reference to that object. Since two objects have different locations in memory, their respective references must differ, even if the objects are identical.\n**_Example._** Consider (a simplified version of) the class `City` that we saw [earlier](http://localhost:41071/docs/objects/sections/classes/). ```java public class City { String name; int zipCode; public City(String name, int zipCode){ this.name = name; this.zipCode = zipcode; } } ``` The following program will output `false`: ```java City city1 = new City(\"Florence\", 50100); City city2 = new City(\"Florence\", 50100); System.out.println(city1 == city2); ``` However, in some scenarios, it may be useful to compare the objects themselves, rather than their references. Java provides a native method called equals for this purpose.\nLike the method toString that we saw earlier, the equals is an instance method of the native Java class Object, which is an (implicit) superclass of every other class. So every (user-defined of native) class inherits equals.\nHere is the source code of Object.equals:\npublic boolean equals(Object obj) { return (this == obj); } In other words, by default, this method behaves like the == operator. In order to use this method to check whether two objects are equal, it has to be overriden.\nFor instance, here is a prototypical implementation of the method equals within our class City:\n@Override public boolean equals(Object o) { if (this == o) { // same reference return true; } if (o == null || getClass() != o.getClass()) return false; // o is null or has a different type } City downcastObject = (City) o; return zipCode == downcastObject.zipCode \u0026amp;\u0026amp; name.equals(downcastObject.name); } **_Hint._** Your IDE can generate such a method. Note in this example:\nthe (safe) downcast from Object to City, and the recursive call to equals (because String is not a primitive type). Recursion # **_Warning._** Similarly to what we saw with the method [toString](http://localhost:41071/docs/objects/sections/tostring/#recursion), beware of naive (recursive) implementations of `equals` if your program can create an object that refers to itself (directly or indirectly). Built-in implementations # Several native Java classes have their own implementation of equals. We will encounter several of them during this course, notably for the class String and for the implementations of the interface Set.\nThe method hashCode # The method equals is usually overridden together with another method of the class Object, called hashCode. In particular, this is needed for the method equals of the class HashSet to behave correctly. We will explore this topic later in this course, when we introduce the notion of a hash table.\n"},{"id":82,"href":"/docs/background/sections/cost/","title":"Computational cost","section":"Background","content":" Computational cost # In this section, we briefly introduce the standard way to estimate the cost of an algorithm, as a function $f(n)$ of the size $n$ of its input.\nSize # The **size** $n$ of the input may be the size of its representation in bits. Other common measures include: - the number of entries for array, - the number of nodes for tree, - etc. Time or memory # Among others, the function $f(n)$ may estimate: - the **running time** of the algorithm, or - its **memory consumption**. Worst case, average # Among others, the function $f(n)$ may estimate: - cost in the **worst case**, i.e. for the worst possible inputs of size $n$ - **average** cost over all possible inputs of size $n$. Exercise Consider the following algorithm, which returns true iff the input array `A` contains the input value `a`. ```perl boolean contains(int[] A, int a){ foreach(v in A) { if(v == a){ return true } } return false } ``` If the input array has length $n$, how many times would the loop be executed in the worst case? Solution $n$ times (if `a` doe not appear in `A`). Exercise Consider the following algorithm (known as binary search), which solves the same problem as the previous one, but assuming that the input array is _sorted_. ```java boolean contains(int[] A, int a){ int begin = 0 int end = A.lenghth - 1 while(begin \u003c end){ mid = (begin + end) / 2 if(a \u003c= A[mid]){ end = mid } else { begin = mid + 1 } } return A[begin] == a } ``` For an input array of length $n$, how many times is the loop executed? Solution $\\log_2 n + 1$ times, rounded down. Asymptotic cost # When comparing the costs of algorithms, we are usually interested in scalability, i.e. how they behave when the input gets large.\nLet $f(n)$ measure the (worst case or average) running time of an algorithm.\nIf $n$ doubles, does $f(n)$ double as well? In other words, does $f(2 n) = 2 f(n)$?\nIf this is the case, then $f$ is a linear function.\n**_Examples._** The following are linear functions: - $f(n) = n$ - $g(n) = 5n$ - $h(n) = \\frac{1}{2} n$ Alternatively, if $f(2 n) \u0026gt; 2 f(n)$, then the cost grows more than linearly with the size of the input.\n**_Examples._** - if $f(n) = n^2$, then $f(2n) = 4 f(n)$, - if $f(n) = c n^2$ for some $c$, then $f(2n) = 4 f(n)$ as well, - if $f(n) = n^3$, then $f(2n) = 8 f(n)$, - if $f(n) = 2^n$, then $f(n+1) = 2 f(n)$ Alternatively, $f(n)$ may grow less than linearly with $n$.\n**_Examples._** - if $f(n) = \\sqrt{n}$, then $f(4n) = 2f(n)$ - if $f(n) = \\sqrt[3]{n}$, then $f(8n) = 2f(n)$ - if $f(n) = \\log_2 n$, then $f(n+1) = 2 f(n)$ Comparing cost functions # Two cost functions $f$ and $g$ are said to be asymptotically equivalent if they intuitively have the same growth.\n**_Examples._** - all linear functions are asymptotically equivalent, - (as illustrated above), the functions $f(n) = n^2$ and $g(n) = 3n^2$ are asymptotically equivalent. **_Terminology._** A function $f: X \\to Y$ is **monotone** if $x_1 \\le x_2$ implies $f(x_1) \\le f(x_2)$ for any $x_1, x_2 \\in X$. **_Definition._** Let $f$ and $g$ be two monotone functions over $\\mathbb{N}$ such that $\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)}$ is defined. And let $l$ be this limit. - if $l = 0$ then $g$ **outgrows** $f$, - if $l = \\infty$ then $f$ **outgrows** $g$, - otherwise (i.e. if $l \\in \\mathbb{R}$ and $l \\neq 0$), $f$ and $g$ are **asymptotically equivalent**. In practice # **_Hint._** $f$ outgrows $g$ iff the derivative of $f$ outgrows the derivative of $g$. **_Example._** Let $f(n) = 5n^2$ and let $g(n) = n^3$. Then $\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = \\lim_{n \\to \\infty} \\frac{5n^2}{n^3} = \\lim_{n \\to \\infty} \\frac{10n}{3n^2} = \\lim_{n \\to \\infty} \\frac{10}{6n} = 0$ So $g$ outgrows $f$. **_Example._** Let $f(n) = 5n^2$ and let $g(n) = n^2$. Then $\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = \\lim_{n \\to \\infty} \\frac{5n^2}{n^2} = \\lim_{n \\to \\infty} \\frac{10n}{2n} = 5$ So $f$ and $g$ are asymptotically equivalent. **_Hint._** If there exists a function $h$ over $\\mathbb{N}$ such that - $\\lim_{n \\to \\infty} h(n) = \\infty$ and - $f(n) = g(n)h(n)$, then $f$ outgrows $g$. **_Example._** Let $f(n) = n \\cdot \\log_2 n$ and let $g(n) = n$. Take $h(n) = \\log_2 n $. Then - $\\lim_{n \\to \\infty} h(n) = \\lim_{n \\to \\infty} \\log_2(n) = \\infty$, and - $f(n) = n \\cdot \\log_2 n = g(n) h(n)$, Therefore $f$ outgrows $g$. Equivalence classes # **_Notation._** If $f$ is a cost function, then $\\Theta(f)$ is used to denote the set of all cost functions that are asymptotically equivalent to $f$ (including $f$ itself). **_Example._** If $f(n) = n$, then the class $\\Theta(f)$ contains the functions: - $g(n) = 2n$, - $h(n) = \\frac{n}{2}$, - $j(n) = 3n + 4$, - etc. **_Note._** If $g$ is in $\\Theta(f)$, then $\\Theta(f)$ and $\\Theta(g)$ are the same class. **_Notation._** If $\\Theta(f)$ is a class of cost functions, then the name of the function (\"$f$\" here) can be omitted. Instead, the definition of $f$ is used (typically with $n$ as variable). **_Examples._** - if $f(n) = n$, then the class $\\Theta(f)$ is usually denoted with $\\Theta(n)$, - if $f(n) = n^2$, then the class $\\Theta(f)$ is usually denoted with $\\Theta(n^2)$, - etc. A simple, representative function is usually preferred to denote in each class.\n**_Example._** $\\Theta(n)$, $\\Theta(\\frac{n}{2})$ and $\\Theta(3n+4)$ are three alternative notations for the same class of cost functions. For readability, $\\Theta(n)$ is usually preferred. Some of the most frequent classes of cost functions for algorithms are (from lower to higher cost):\n$\\Theta(1)$ (a.k.a. constant cost) $\\Theta(\\log n)$ (a.k.a. logarithmic cost) $\\Theta(n)$ (a.k.a. linear cost) $\\Theta(n \\log n)$ $\\Theta(n^2)$ (a.k.a. quadratic cost) $\\Theta(n^3)$ (a.k.a. cubic cost) $\\Theta(2^n)$ Useful simplifications # The definition of asymptotic equivalence implies that the cost function of an algorithm can often be simplified into an equivalent one, using simple rules. We list here a few of them.\n**_Simplification rule._** If $f(n) = c \\cdot g(n)$ for some constant $c$, then $f$ is in $\\Theta(g)$. **_Examples._** - $f(n) = 3n$ is in $\\Theta(n)$ - $f(n) = 2n^3$ is in $\\Theta(n^3)$ - $f(n) = 5 \\log n$ is in $\\Theta(\\log n)$ - etc. **_Simplification rule._** - if $f(n) = \\log_a n$ (for some base $a$), then $f$ is in $\\Theta(\\log n)$ - if $f(n) = n \\log_a n$ (for some base $a$), then $f$ is in $\\Theta(n \\log n)$ - etc. **_Examples._** - $f(n) = \\log_2 n$ is in $\\Theta(\\log n)$ - $f(n) = \\frac{1}{5} \\log_3 n$ is in $\\Theta(\\log_3 n) = \\Theta(\\log n)$ - $f(n) = 4n \\log_2 n$ is in $\\Theta(n \\log_2 n) = \\Theta(n \\log n)$ **_Simplification rule._** If $f(n)$ is a sum of terms (e.g. a polynomial), then it belongs to the class that represents the highest order term. **_Examples._** - $f(n) = 2n^2 + 3n + 20$ is in $\\Theta(2n^2) = \\Theta(n^2)$ - $f(n) = \\frac{3}{2}n^3 + 2n^2 + 3n + 20$ is in $\\Theta(\\frac{3}{2}n^3) = \\Theta(n^3)$ - $f(n) = 2 n\\log(n) + 3n + \\sqrt{n}$ is in $\\Theta(2 n \\log n) = \\Theta(n \\log n)$ Big $O$ # **_Notation._** $O(f)$ denotes the union of all classes of functions that are at most as expensive as $f$ (asymptotically). **_Example._** $f(n) = 3n + 5$ is in $\\Theta(n)$, therefore the following also hold: - $f$ is in $O(n^2)$ - $f$ is in $O(n^2 \\log n)$ - $f$ is in $O(n^{2.5})$ - $f$ is in $O(n^3)$ - $f$ is in $O(2^n)$ **_Note._** As a consequence, $\\qquad f$ is in $\\Theta(g)$ is syntactic sugar for $\\qquad f$ is in $O(g)$ and $g$ is in $O(f)$ Overloaded equality # **_Warning._** Instead of \"$f$ is in $\\Theta(g)$\", it is customary to write: $\\qquad f(n) = \\Theta(g)$ (and similarly for $O$), thus overloading the meaning of the symbol \"$=$\". **_Examples._** - $f(n) = 3n^2 + 5 = \\Theta(n^2)$ - $f(n) = 2 n^2 \\log n = \\Theta(n^2 \\log n)$ - $f(n) = 2 n^2 = O(n^2)$ - $f(n) = 2 n^2 = O(n^3)$ Application # Let us now evaluate the asymptotic cost of some algorithms.\nFor simplicity, we will focus of the worst-case running time (but the same notion of asymptotic cost can be used for average cost and/or memory usage).\nRAM cost model # The so-called Random Access Machine (RAM) model of computation makes several assumptions about computational cost. In particular, for a given index $i$, the cost of accessing the $i^\\text{th}$ element of an array does not depend on the size of this array.\nAnother simplification that is often made (although not consistently by all authors) in the RAM model is that the cost of a value comparison or a basic arithmetic operation (e.g. addition or multiplication) does not depend on the values of its operands.\n**_Example._** Consider the following method ```java boolean myMethod(int[] A, int i){ return A[i] + A.length } ``` Let $n$ be the size of the input array $A$, and let us express the running time of this method as a function of $n$. If we adopt the RAM cost model, then: - the cost $c_1$ of reading the value `A[i]` is independent of $n$ - the cost $c_2$ of reading the length of `A` is also independent of $n$ - the cost $c_3$ of summing these two values is also independent of $n$ Therefore, expressed as a function $f$ of $n$, the running time of this method is $\\qquad f(n) = c_1 + c_2 + c_3$ which is in $\\Theta(1)$. In other words, the running time of this method is _constant_ in the size of the array. **_Example._** Consider the same algorithm as [above](#worstCaseOrAverage) (but where the meaning of `foreach` is made explicit) ```java {linenos=true} boolean contains(int[] A, int a){ int i = 0 while (i \u003c A.length) { if(A[i] == a){ return true } i++ } return false } ``` Once again, let $n$ be the size of the input array `A`, and let us express the worst case running time of this method as a function of $n$. Recall that the worst possible input is the one where the input value `a` does not appear in `A`. In this case, the loop is executed $n$ times. If we adopt the RAM cost model: - the cost $c_1$ of the initialization of `i` (line 2) is independent of $n$ - the cost $c_2$ of _one_ comparison of `i` with `A.length` (line 3) is independent of $n$ - the cost $c_3$ of _one_ execution of the loop is independent of $n$ - the cost $c_4$ of the final `return` statement (line 8) is independent of $n$ Therefore, expressed as a function $f$ of $n$, the cost of this method is $$ f(n) = c_1 + c_2 n + c_3 n + c_4 $$ $$ \\qquad\\ \\ = (c_2 + c_3) n + c_1 + c_4 $$ which is in $\\Theta(n)$. In other words, the worst-case running time of this method is _linear_ in the size of the array. Exercise What is the asymptotic running time of the [binary search](#worstCaseOrAverage) algorithm seen above, expressed as function of the size of the input array `A`? Solution The running time of this algorithm is logarithmic in the size $n$ of the array, i.e. in $\\Theta(\\log n)$. Exercise What is the asymptotic running time of the following method, expressed as function of the size of `A`? Can you think of a more efficient algorithm for the same problem (and what would be its running time)? ```java int myMethod(int[] A){ int val = 0 for (int i = 0; i \u003c A.length; i++){ for (int j = 0; j \u003c A.length; j++){ val += A[i] + A[j] } return val } ``` Solution The method has quadratic running time, i.e. its running time is in $\\Theta(n^2)$. A more efficient algorithm (with _linear_ running time) could be: ```java int myMethod(int[] A){ int val = 0 for (int i = 0; i \u003c A.length; i++){ val += A[i] } return 2 * n * val } ``` --\u003e --\u003e --\u003e --\u003e --\u003e --\u003e "},{"id":83,"href":"/docs/stream/sections/order/","title":"Multithreading and order","section":"Streams in Java","content":" Multithreading and order # Multithreading # We can allow a whole stream pipeline to be executed in a concurrent or parallel fashion, for instance with the instance method Stream.parallel, as follows:\n**_Example._** ```java Listlist = List.of(1, 2, 3); // Contains [3,4,5] List ouputList = list.stream() .parallel() .map(i -\u003e i + 2) .toList(); ``` This allows the JVM to take advantage of available resources to execute operations (like the map operation in this example) in several threads, concurrently.\nOrder # From the Javadoc of the package java.util.stream, if the source of a stream is ordered (e.g. a List), then the effect of an operation on the stream is usually predictable.\nIndeed, most operations are constrained to operate on the elements in their \u0026ldquo;encounter order\u0026rdquo;. For instance, if the source of a stream is a List containing [1, 2, 3], then the result of executing map(x -\u0026gt; x * 2) must be [2, 4, 6].\nHowever, in some cases, the terminal operation forEach may ignore the encounter order. If the stream is executed sequentially (which is the case by default), then this usually has no effect on execution. But if the stream is executed in parallel, then this is likely to affect the output.\nIn such a case, the terminal operation forEachOrdered may be used instead of forEach, in order to force this operation to respect the encounter order.\n**_Example._** ```java Listlist = List.of(1, 2, 3); // Must output `2` `4` and `6, in this order. list.stream() .parallel() .map(x -\u003e x * 2) .forEachOrdered(System.out::println); ``` Besides, it is possible to relax the ordering constraint with the instance method Stream.unordered(). This may improve performance for pipelines with costly operations, in scenarios where the order of processing is irrelevant.\n**_Example._** In this example, the order in which the elements of the stream are processed is irrelevant because: - the map applies a pure function, and - the stream is collected as a set. This is why calling the `unordered` method is safe. ```java Listlist = getList(); list.stream() .parallel() .unordered() .map(o -\u003e expensivePureFunction(o)) .collect(Collectors.toSet()); ``` "},{"id":84,"href":"/docs/background/sections/regular/","title":"Regular languages","section":"Background","content":" Regular languages # Definitions # Alphabet # **_Definition._** An **alphabet** is a finite set of characters. **_Examples._** {`a`} is a alphabet, {`a`,`b`} is another alphabet, {`a`, `b`, `3`, `5`,`\\n`} is yet another alphabet. **_Warning._** A blank space is is a character. The letter $\\Sigma$ is often used to refer to an alphabet.\nWord # **_Definition._** A **word** over an alphabet $\\Sigma$ is a (possibly empty) finite sequence of character in $\\Sigma$. The empty word (a.k.a. \u0026ldquo;empty string\u0026rdquo;) is traditionally denoted with $\\varepsilon$.\n**_Examples._** Let $\\Sigma$ be the alphabet {`a`, `b`, `3`, `5`, `\\n`}. Then possible words over $\\Sigma$ are: - $\\varepsilon$ - `a` - `aa` - `ba\\n` - `\\n\\nba353\\n\\nb` Language # **_Definition._** A formal **language** over an alphabet $\\Sigma$ is a (possibly infinite) set of words over $\\Sigma$. **_Examples._** Let $\\Sigma$ be the alphabet { `a`, `b` }. Then possible languages over $\\Sigma$ are: - { } - { `a` } - { `a`, `aa`, `aaa`, `b`, `aba` } - { $\\varepsilon$, `a`, `ba` } - the set of all words that contain only the character `a` - the set of all words over $\\Sigma$ - the set of all words over $\\Sigma$ that do not contain 2 consecutive `b`'s - the set of all words over $\\Sigma$ that contain as many `a`'s as `b`'s Operations on languages # Element-wise concatenation # If $L_1$ and $L_2$ are languages, then we use $L_1 \\circ L_2$ for the language that consists of the element-wise concatenation of all words in $L_1$ and $L_2$ (in that order). **_Examples._** If $L_1$ = {`ab`, `c`} and $L_2$ = {`d`, `ef`}, then $L_1 \\circ L_2$ = { `abd`, `abef`, `cd`, `cef`} If $L_3$ = {`ab`, `b`} and $L_4$ = { $\\varepsilon$, `ac` }, then $L_3 \\circ L_4$ = { `ab`, `abac`, `b`, `bac` } Closure # If $L$ is a language, then the **closure** (also called **Kleene closure**) $L^*$ of $L$ is the language $L^*$ = { $\\varepsilon$ } $\\cup\\ L \\cup\\ (L \\circ L) \\cup\\ (L \\circ L \\circ L) \\cup (L \\circ L \\circ L \\circ L) \\cup ...$ Equivalently, $L^*$ can be defined as:\nthe set that consists of $L$, the empty word $\\varepsilon$, and all possible concatenations of words in $L$. the smallest superset of $L\\ \\cup$ { $\\varepsilon$ } that is closed under word concatenation (meaning that if $L^*$ contains two words $w_1$ and $w_2$, then it also contains the word $w_1 w_2$). Regular language # **_Definition_.** A language is **regular** if it is: - the empty set, or - the language { $\\varepsilon$ }, or - the language { `a` } for some character `a`, or - the union of two regular languages, or - the element-wise concatenation of two regular languages, or - the closure of a regular language. **_Examples_** - $L_1$ = { `a` } is regular - $L_2$ = { `b` } is regular - $L_3$ = $L_1 \\cup L_2$ = { `a`, `b` } is regular - $L_4 = L_1 \\circ L_3$ = { `aa`, `ab` } is regular - $(L_4)^*$ = { $\\varepsilon$, `aa`, `ab`, `aaaa`, `aaab`, `abaa`, `abab`, `aaaaaa`, `aaaaab`, ... } is regular **_Observation._** If $\\Sigma$ is an alphabet, then the language $\\Sigma^*$ of all possible words over $\\Sigma$ is regular. **_Counter-examples._** If $\\Sigma$ = { `a`,`b` }, then the set of all words over $\\Sigma$ that contain as many `a`'s as `b`'s is not regular. If $\\Sigma$ = {`0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`} $\\cup$ { `+`, `-`, `(` , `)`} , then the set of well-formed algebraic expressions over $\\Sigma$ (in particular, where each opening parenthesis is closed) is not regular. More generally, most programming languages are not regular. Properties # The intersection of two regular languages is a regular language. The difference between two regular languages is a regular language. Regular expressions # A language is regular iff it can be described by a regular expression.\nRegular expressions are covered in the dedicated chapter.\nFinite automata # Regular languages have a close connection to so-called finite automata.\nA finite automaton can be viewed as a simple program that recognizes a regular language $L$, meaning that the automaton takes as input a word $w$ and returns true iff $w$ belongs to $L$.\nFinite automata are one of the simplest (theoretical) models of computation. They (approximately) correspond to computers that cannot use memory.\nAutomata theory is beyond the scope of this course.\n"},{"id":85,"href":"/docs/env/sections/requirements/","title":"Requirements for this course","section":"Development environment","content":" Requirements for this course # For this course, you will need:\nGit Version 2.2 or higher A Java Development Kit (JDK) for Java 17 (e.g. openJDK) Maven Version 3.6 or higher In addition, if you choose the board game as project, you will need:\nGradle Version 7.2 or higher Again, we recommend using a package manager to install these programs if possible.\n**_For Windows users_**. Maven is not available on the winget repository. But you can find it on the Chocolatey repository, or follow [manual installation instructions](https://phoenixnap.com/kb/install-maven-windows). You will also need:\nan IDE a text editor (possibly your IDE) a terminal emulator (possibly your IDE) "},{"id":86,"href":"/docs/input/sections/serialize/","title":"Serialization","section":"I/O and serialization","content":" Serialization # **Serializing** an object (resp. data structure) means converting it into a form that can be stored or transmitted, and such that the object (resp. data structure) can be later reconstructed (a.k.a. **deserialized**). in Java # Java provides a native mechanism to serialize an object (including information about the type of the object). The serialization format is not (meant to be) human-readable.\nThe process is JVM independent, meaning that an object can be serialized on one platform and deserialized on another.\nTransient # In Java, an instance attribute can be marked with the keyword transient (a.k.a. \u0026ldquo;volatile\u0026rdquo;). For instance:\npublic class MyClass { String serializedAttribute; transient int transientAttribute; ... } Transient attributes are excluded from the serialization process (meaning that a serialized object contains no value for its transient attribute).\n**_Warning._** When an object is _deserialized_ (i.e. converted back to an object), [default values](https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.12.5) are assigned to each of its transient attributes: `null` for a reference, `0` for an `int`, `false` for a `boolean`, etc. Serializable # In Java: - a value with primitive type (e.g. `int`) is **serializable**, - an array is **serializable** if its elements are serializable, - an object is **serializable** if: - its class implements the interface `Serializable`, and - each of its attributes is serializable or marked as `transient`. **_Note._** Implementing the interface `Serializable` does not require implementing any method. **_Example._** Instances of the following class are not serializable, because `Country` does not implement `Serializable`. ```java public class Country { String name; public Country(String name) { this.name = name; } } ``` Instances of the following class are not serializable either, because the attribute `country` has type `Country`, which does not implement `Serializable`. ```java public class City implements Serializable { String name; int zipCode; Country country; public City(String name, int zipCode, Country country) { this.name = name; this.zipCode = zipCode; this.country = country; } } ``` However, if we replace ```java Country country; ``` with ```java transient Country country; ``` then instances of the class `City` become serializable, because: - the attribute `name` has type `String`, which implements `Serializable`, and - the attribute `zipCode` has a primitive type, and - the attribute `country` is now declared as transient. **_Note._** Most native implementations of the Java interfaces `Collection` (`ArrayList`, `LinkedList`, `HashSet`, `TreeSet`, etc.) and `Map` (`HashMap`, `TreeMap`, etc.) also implement `Serializable`. serialVersionUID # If a class implements the interface Serializable, it is recommended to add a field: private static final long serialVersionUID (annotated with @Serial) and initialize it. For instance:\npublic class City implements Serializable { @Serial private static final long serialVersionUID = 0; ... } The value is irrelevant, but is meant to be updated if the (instance) attributes of the class are modified.\nFor an explanation, we refer to this page.\nSerialization (and deserialization) methods # The class ObjectOutputStream allows serializing an object, with the method:\nvoid writeObject(Object x) throws IOException Similarly, the class ObjectInputStream allows deserializing an object (i.e. loading it back into memory), with the method:\nObject readObject() throws IOException, ClassNotFoundException **_Note._** The return type of `readObject` is `Object`, so the returned object needs to be cast to its appropriate data type. **_Example._** Let us continue with the example above (assuming that the attribute `City.country` is marked as `transient`). A instance of `City` can be serialized to a file as follows: ```java String path = \"path/to/file.ser\"; Country italy = new Country(\"Italy\"); City bologna = new City(\"Bologna\", 40100, italy); try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(path))) { out.writeObject(bologna); } catch (IOException e) { throw new RuntimeException(e); } ``` And deserialized as follows: ```java City deserializedBologna; try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(path))) { deserializedBologna = (City) in.readObject(); } catch (IOException | ClassNotFoundException e ) { throw new RuntimeException(e); } // Ouputs 'Deserialized city: { name: Bologna, zipCode: 40100, country: null }' System.out.printf( \"Deserialized city: { name: %s, zipCode: %d, country: %s }\", deserializedBologna.name, deserializedBologna.zipCode, deserializedBologna.country ); ``` Observe that the attribute `country` after deserialization has value `null` (because it is marked as `transient`). "},{"id":87,"href":"/docs/git/sections/branches/","title":"Branches","section":"git","content":" Branches # Listing branches # The command\ngit branch allows you to list all local branches (for the current repository).\nCreating a branch # To create a new branch, run\ngit branch \u0026lt;branchName\u0026gt; Then you can switch to this branch with\ngit checkout \u0026lt;branchName\u0026gt; Alternatively, you can perform both operations with a single command:\ngit checkout -b \u0026lt;branchName\u0026gt; Deleting a branch # You can delete a (local) branch other than the current branch with\ngit branch -d \u0026lt;branchName\u0026gt; Merging a branch # To merge a branch \u0026lt;branchToMerge\u0026gt; into a branch \u0026lt;receivingBranch\u0026gt;, switch first to the receiving branch:\ngit checkout \u0026lt;receivingBranch\u0026gt; Then run\ngit merge \u0026lt;branchToMerge\u0026gt; If possible, a fast-forward merge will be performed.\nOtherwise a regular merge will be attempted. If this cannot be done (due to merge conflicts), then you will be asked to fix the merge conflicts. After fixing the conflicts, you can finalize the merge with\ngit commit "},{"id":88,"href":"/docs/lambda/sections/captured/","title":"Captured variables","section":"Callback methods and lambda expressions","content":" Captured variables # In practice, lambda expressions are often used to represent pure functions.\nSome languages (like Java, JavaScript, C++, etc) restrict (or allow the user to restrict) the usage of lambda expressions, so that they lean towards pure functions.\n**_Terminology._** Some programming languages allow a lambda expression to use variables that: - are declared _outside_ of the lambda expression's body, and - are _not_ arguments of the lambda expression. In this case, the expression is called a **capturing lambda expression**, and these variable are said to be **captured**. **_Example._** In the following Java program, the lambda expression `x -\u003e x == a` is a capturing lambda, because it uses the variable `a`, which is defined outside of the lambda expression. ```java boolean myMethod() { int a = 2; return execute( 3, x -\u003e x == a ); } boolean execute(Integer x, Function function) { return function.apply(x); } ``` Captured variables in Java # **_Restriction._** A capture variable in Java must be **effectively final**, meaning that it cannot be modified after its initialization. **_Examples._** The following Java program is nearly identical to the previous one, but does _not_ compile, because the captured variable `a` is not effectively final. ```java boolean myMethod() { int a = 2; a = a + 1; return execute( 3, x -\u003e x == a ); } boolean execute(Integer x, Function function) { return function.apply(x); } ``` The following program does not compile either, for the same reason. ```java boolean myMethod() { int a = 2; return execute( 3, x -\u003e { a = a + 1; return x == a; } ); } boolean execute(Integer x, Function function) { return function.apply(x); } ``` **_Exception._** An exception to the rule above is captured variables that are allocated on the heap, i.e (class or instance) _attributes_. For instance, the following program is nearly identical to the (first) program above that does not compile. However, this new program compiles, because the captured variable `a` is now an instance attribute. ```java public class EnclosingClass { int a = 2; boolean myMethod() { a = a + 1; return execute( 3, x -\u003e x == a ); } boolean execute(Integer x, Function function) { return function.apply(x); } } ``` "},{"id":89,"href":"/docs/objects/sections/classesasobjects/","title":"Classes as objects","section":"Objects and classes","content":" Classes as objects # Some object-oriented languages (like Java, C# or C++) provide ways to access or manipulate classes (almost) as if they were objects.\nStatic attributes and methods # Static attributes # Java (as well as C# and C++) supports attributes that do not depend on a specific object, but on a _class_ instead. These are often called **static attributes** (or sometimes **class attributes** or **class variables**), as opposed to the attributes that we have seen so far, called **instance attributes** (or **member variables**). Static attributes are marked with the keyword static.\n**_Example._** Consider a version of our game where characteristics for each unit type (e.g. default health, etc.) can be declared manually, in a text file. The path to this file could be stored as a static attribute, as follows: ```java public class Unicorn { static String configFile = \"units/unicorn.txt\"; int health; public Unicorn(){ health = getHealthFromConfigFile(configFile); } public regen(){ health++; } } ``` Each instance of Unicorn carries its own value for the attribute health. But the value of configFile is unique.\nFor instance, the following program creates in memory a unique string for configFile, which is carried by the class.\nUnicorn u1 = new Unicorn(); Unicorn u2 = new Unicorn(); Static methods # Similarly to a static attribute, a **static method** does not depend on a specific object, as opposed to an [instance method](http://localhost:41071/docs/objects/sections/methods/). **_Example_** (continued). We can add to our class `Unicorn` a static method that checks whether the configuration file exists: ```java public class Unicorn{ ... static boolean configFileExists() { return Files.exists(Paths.get(configFile)); } } ``` (note that the method `getHealthFromConfigFile` also may also be static, if its execution is identical for all instances of `Unicorn`). Remember that an instance method can be called outside of the class where it is declared, using an instance of the class followed by .:\nUnicorn myUnicorn = new Unicorn(); myUnicorn.regen(); A static method can (syntactically) be called in the same way, for instance:\nUnicorn myUnicorn = new Unicorn(); boolean valid = myUnicorn.configFileExists(); However, this is often discouraged, because this syntax can be misleading (in this example, configFileExists can be mistaken for an instance method).\nAlternatively, since the method depends on the class (rather than an instance), the call can be prefixed with the class name. This syntax is often preferred, because it leaves no ambiguity. For instance:\nboolean valid = Unicorn.configFileExists(); Note that there may be several instances of a same class in memory during the execution of a program, or no instance at all. This is why a static method cannot reference an instance method or attribute. For instance, adding the following static method to our class would cause a compilation error, because health is an instance attribute.\npublic class Unicorn { static void reduceHealth(){ health--; } } Inheritance # Two static methods with the same name and signature can be declared in a class and a superclass. In Java\u0026rsquo;s terminology, this is not called method overriding, but instead method hiding. An important difference is that dynamic dispatch (a.k.a. runtime polymorphism) does not apply to this case (the method to be called is determined at compile time, rather than run time).\n**_Example_** (continued). Let us extend our example with a subclass of Unicorn that **hides** the static method `configFileExists`. ```java public class EvilUnicorn extends Unicorn { static boolean configFileExists(){ return false; } } ``` Now consider the following program, where the method getUnicorns produces an array of unicorns that depend on the player\u0026rsquo;s input. The specific type of objects in this array (Unicorn or EvilUnicorn) cannot be determined at compile time.\nUnicorn[] unicorns = getUnicorns(); for (Unicorn unicorn: unicorns){ System.out.println(unicorn.configFileExists()); } } In this example, the method of the superclass (i.e. Unicorn.configFileExists) will be executed for each object in the array, regardless of its type.\nThis is another reason why calling a static method via an instance (rather than via a class name) is often discouraged. In this example, writing Unicorn.configFileExists() would make it clear that this loop serves no purpose (the same method is executed unicorns.length times).\nReflection # Java (as well as C#) offers a mechanism called reflection to intuitively treat classes analogously to objects. Precisely, each class of a program (e.g. the class Unicorn) is associated with an object that represents it. This object is itself an instance of the Java class called Class. It can be accessed either:\nvia an instance of the class: Unicorn myUnicorn = new Unicorn(); Class unicornClass = myUnicorn.getClass(); or via the qualified name of the class (assuming for instance that the file Unicorn.java is in the folder \u0026lt;workingDirectory\u0026gt;/src/main/java/org/units): Class unicornClass = Class.forName(\u0026#34;org.units.Unicorn\u0026#34;); The instance methods of the class Class are listed here. Among others, they allow:\nlisting the attributes of the class, retrieving its immediate superclass, or the interfaces that it implements, creating a new instance of this class, etc. Reflection is a powerful feature. It is rarely used in everyday code, but can be helpful in specific situations. Notably, it is used (internally) by numerous Java frameworks such as Spring, Jackson or JUnit.\n"},{"id":90,"href":"/docs/env/sections/ide/","title":"IDE","section":"Development environment","content":" Integrated development environment (IDE) # An IDE is an application that consists of a source code editor with additional functionalities such as a debugger or build automation.\nFor this course, you can use any IDE (or enhanced code editor) for Java with at least the following features:\na debugger navigation to variable/class/interface declaration and usage, variable/class/interface renaming, Maven integration, Gradle integration if you choose the board game as your project. We give a brief overview of the most popular choices (for Java).\nEclipse, Netbeans and Intellij IDEA # All three of these editors have similar functionalities, and any of these three can be used for this course. All three were designed with Java in mind, and thus offer advanced integration with a variety of Java frameworks. Each of them also supports other programming languages, but the list varies from one editor to the other.\nAs of today, Intellij IDEA (IntelliJ for short) is probably the most popular Java-centric editor. This is a closed-source project, thus offering more limited customization than the other two.\nEclipse is an open-source project with a large ecosystem. It is known for its community support and its advanced plugin system, which led to the development of a variety of extensions over the years (including support for C/C++, Python, etc.). Note that for performance reasons, Eclipse comes with its own Java Virtual Machine (JVM), which in some (rare) cases may not behave like other JVMs.\nNetbeans is also an open-source project. Notably, Netbeans provides a graphical tool to design Graphical User Interfaces (GUIs) for the Java Swing framework. However, we do not recommended using it for an advanced GUI (multiple windows, etc.), because the generated code can be very difficult to maintain or debug.\nVisual Studio Code (VSCode) # **_Warning_**. VSCode and Visual Studio are two _independent programs_, and serve different purposes. In particular, Visual Studio does _not_ support Java (anymore). **_Note._** VSCode is often categorized as a code editor rather than an IDE. For this course, VSCode (together with some plugins) can serve as a Java IDE, so we will refer to it as an IDE for simplicity. VSCode is a (mostly) open-source project developed by Microsoft. Precisely, Code-OSS is a (fully) open source editor, and VSCode is a distribution of Code-OSS with additional features.\nVSCode has probably become the most popular code editor among developers. For instance, VSCode is used by 74% of respondents of the 2023 StackOverflow developer survey.\nThe success of VSCode is often explained by its rich repository of (community-developed) plugins. This may in turn be explained by the fact that VScode is based on Electron, and thus allows writing plugins in Javascript.\nNote that VSCode was not developed as a Java code editor, but as a general-purpose editor with a focus on web development (Node.js/Javascript). However, VSCode can serve as a Java IDE (at least to some extent) thanks to some plugins. For this course, you may use the extension pack for Java. If you choose the board game as your project, you may also need a plugin for Gradle, such as this one.\nIn some cases, using VSCode may require a little bit more configuration than a Java-centric IDE.\n"},{"id":91,"href":"/docs/errors/sections/errors/","title":"Java errors","section":"Errors","content":" Java errors # Aside from exceptions, a Java program can throw a so-called Error.\nAccording to the Javadoc for the class Error:\nAn Error [\u0026hellip;] indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions.\nFor instance, some subclasses or Error are OutOfMemoryError and StackOverflowError.\n"},{"id":92,"href":"/docs/stream/sections/optional/","title":"Optional","section":"Streams in Java","content":" Optional # The class Optional was introduced in Java 8. An Optional is a container object that may or may not contain a value. Its main purpose is to indicate that the object returned by a function may be null.\n**_Example._** In our [game](http://localhost:41071/docs/intro/sections/board_game/), the interface `Board` provides a method `getUnit(int rowIndex, int columnIndex)`, that returns the unit standing on the tile with these coordinates, _if any_. This could be implemented with a method $\\qquad$ `Unit getUnit(int rowIndex, int columnIndex)` that returns `null` if there is no unit on this tile (and returns the unit otherwise). However, from the signature of this method, it is not immediately clear that the returned unit may be `null`. This may cause a `NullPointerException` at runtime, if the method is called by some program that does not check whether this unit is `null`. Instead, we can use $\\qquad$ `Optional getUnit(int rowIndex, columnIndex)` to clearly indicate that the return value may not be present. Syntax # Declaring an empty Optional # An empty Optional can be initialized with the static method Optional.empty().\n**_Example._** ```java Optional unit = Optional.empty(); ``` Setting an Optional\u0026rsquo;s value # The value of an Optional can be set with the static method Optional.of.\n**_Example._** ```java Optional unicorn = Optional.of(new Unicorn(\"green\")); ``` Getting an Optional\u0026rsquo;s value # Whether an Optional has a value can be checked with the instance method Optional.isPresent(), and the value (if present) can be retrieved with the instance method Optional.get().\n**_Example._** ```java Optional unit = board.getUnit(rowIndex, columnIndex); if(unit.isPresent()){ unit.get().boost(); } ``` The instance method Optional.ifPresent can be used (as an alternative) for the same purpose.\nIf the optional object has type Optional\u0026lt;$T$\u0026gt;, then ifPresent takes as argument a callback method with type\n$\\qquad T \\to$ void\n(a.k.a. a Java Consumer) that is executed iff the Optional is nonempty.\n**_Example._** ```java Optional unit = board.getUnit(rowIndex, columnIndex); unit.ifPresent(u -\u003e u.boost()); ``` Primitive types # Java 8 also introduced the container OptionalInt (resp. OptionalLong, OptionalDouble), which behaves analogously to Optional\u0026lt;Integer\u0026gt; (resp. Optional\u0026lt;Long\u0026gt;, Optional\u0026lt;Double\u0026gt;), but contains an int (resp. long, double). It is mostly used in combination with IntStream (resp. LongStream, DoubleStream).\nOptional and streams # Some methods of the interface Stream\u0026lt;$T$\u0026gt; (resp. IntStream, LongStream, DoubleStream) return an Optional\u0026lt;$T$\u0026gt; (resp.OptionalInt, OptionalLong, OptionalDouble).\nIn particular:\nfindFirst average, max and min etc. "},{"id":93,"href":"/docs/git/sections/sharing/","title":"Synchronization: remote, push, pull","section":"git","content":" Synchronization: remote, push, pull # List remotes # To list the remote(s) associated to your repository (name and address of each remote), you can run\ngit remote -v Upload # If the current branch is already shared with a remote, you can upload it with\ngit push Otherwise, you can share this branch (and its commits) with\ngit push -u \u0026lt;remoteName\u0026gt; \u0026lt;branchName\u0026gt; To delete a remote branch, run\ngit push \u0026lt;remoteName\u0026gt; -d \u0026lt;branchName\u0026gt; Alternatively, you can delete a remote branch using the web interface of your hosting service.\nDownload # If your current branch is shared with your remote, you can update your local copy with\ngit pull **_Warning._** When pulling, git will try to perform a fast-forward merge of the remote branch into your local copy. If you follow the [basic workflow](http://localhost:41071/docs/git/sections/collaboration/#workflow) presented earlier, then this fast-forward merge should succeed. If it does not, then git will suggest you a command to perform a classical merge instead. "},{"id":94,"href":"/docs/multithreading/sections/troubleshooting/","title":"Troubleshooting","section":"Multithreading","content":" Troubleshooting # Alongside race conditions, there are several reasons why a program that uses multithreading may not behave as intended.\nTwo common ones are deadlocks and (to a lesser extent) starvation.\nDeadlock # **_Terminology._** A **deadlock** occurs when two threads wait for each other to release a lock. This notion also generalizes to cyclic deadlocks involving more than two threads.\nIn Java, this may be caused by synchronized methods or statements. A simple illustration can be found here.\nStarvation # A thread is **_starving_** if it does not get regular access to a shared resource, and as a result cannot progress in its execution. This situation can often be avoided with a queue.\n"},{"id":95,"href":"/docs/multithreading/sections/abstractions/","title":"Abstractions","section":"Multithreading","content":" Abstractions # We review here some higher-level utilities available in Java to use multithreading, while reducing the risk of unwanted behaviors.\nThread safety # **_Terminology._** A method is said to be **tread-safe** if it can be accessed by concurrently by several threads without \"unexpected\" consequences. Thread safety is a vague term, which may for instance refers to implementations that are free of race conditions.\nMost high-level libraries or frameworks that exploit concurrency provide methods with some from of thread safety. In particular, this is the case of most Graphical User Interface frameworks (such as JavaFX or Swing for Java).\nBy default, it is highly recommended to rely on such methods when using concurrency. For instance, Effective Java (Item 81) recommends using \u0026ldquo;thread safe\u0026rdquo; concurrency utilities when possible, rather than Java\u0026rsquo;s (error prone) wait, notify and notifyAll methods.\nAtomic operation # **_Terminology._** An operation performed by a thread is **atomic** if no operation performed by a concurrent or parallel thread can affect its execution. We saw earlier that the operation\ni++; is not atomic, but corresponds to a sequence of instructions (fetch, increment and write).\nThe package java.util.concurrent.atomic provides classes like AtomicInteger, AtomicBoolean or AtomicReference that support atomic operations.\n**_Example._** The program ```java AtomicInteger i = new AtomicInteger(0); int j = i.getAndIncrement(); ``` is analogous to ```java int i = 0; int j = i++; ``` but the operation `i.getAndIncrement()` is atomic, whereas `i++` is not. Associative array # ConcurrentMap # The interface ConcurrentMap is a sub-interface of Map (which stands for an associative array) with additional atomicity and thread-safety guarantees.\nIt has two native implementations, one as a hash table, the other as a so-called skip list. The latter maintains the order of insertion, analogously to what we saw for a LinkedHashMap.\nConcurrentNavigableMap # The interface ConcurrentNavigableMap is a sub-interface of SortedMap (like TreeMap, that we saw in the dedicated section), with additional atomicity and thread-safety guarantees. It has one native implementations, as a so-called skip list.\nQueue # The Java interface BlockingQueue is a sub-interface of Queue (which stands for the abstract data type queue). In addition to the traditional operations supported by a queue (dequeue and enqueue), a blocking queue provides variants of these operations to:\nwait for the queue to become non-empty (when dequeuing), or wait for space to be freed in the queue (when enqueueing). These allow implementing the producer/consumer pattern seen earlier, without relying on Java\u0026rsquo;s wait, notify and notifyAll methods.\nBlockingQueue has several native implementations (e.g. as a doubly linked list or as a dynamic array).\nThread pool # A **thread pool** is a (of fixed or flexible) set of threads that can be reused for different tasks. The factory class Executors provides a series of static methods that return a thread pool. In particular:\nExecutors.newFixedThreadPool returns a pool (instance of ExecutorService) with a fixed number of threads (specified as argument), Executors.newCachedThreadPool returns a pool (also instance of ExecutorService), but with flexible size. In both cases, tasks submitted to the pool will reuse existing threads if available.\nAn introduction to Java thread pools can be found here.\n"},{"id":96,"href":"/docs/git/sections/backtracking/","title":"Backtracking","section":"git","content":" Backtracking # We already saw how a file can be unstaged (with git reset) before it is committed.\nIf the file was committed by mistake, then there are at least three scenarios.\nReset # If the commits that contain the file have not been shared yet with a remote, then these commits can be cancelled locally. The command\ngit reset \u0026lt;ID\u0026gt; moves the pointer for the current branch \u0026ldquo;back in time\u0026rdquo; to the commit \u0026lt;ID\u0026gt;. This has the effect of deleting all posterior commits.\nRevert # If the commits that contain the file have been shared with a remote, then git revert is often recommended by default.\nThis command does not affect the history of a branch (as opposed to git reset). Instead, if adds a commit to the history that reverts the k last commits on the current branch.\nFor instance\ngit revert HEAD adds a commit that reverts the latest one.\nAnd\ngit revert HEAD~3.. adds a commit that reverts the 3 latest ones.\nRewriting history # In some (rare) scenarios, one may need to rewrite the history of a branch that has already been shared.\nFor instance, sensitive information (passwords, etc.) or a large dataset may have been committed by mistake.\nDedicated tools may be used in such scenarios.\n"},{"id":97,"href":"/docs/objects/sections/clone/","title":"Duplicating objects","section":"Objects and classes","content":" Duplicating objects # In some scenarios, it may be useful to duplicate an object.\nIn Java, as we saw earlier, copying the value of a variable with reference type does not copy the object that it references. For instance, the following program outputs \u0026ldquo;yellow\u0026rdquo;:\nUnicorn unicorn = new Unicorn(\u0026#34;green\u0026#34;); Unicorn shallowCopy = unicorn; unicorn.color = \u0026#34;yellow\u0026#34;; System.out.println(shallowCopy.color); The need to duplicate objects may notably appear in a program that rely on concurrency.\nExercise In our game, the \"view\" component is in charge of rendering the game visually. This component exposes a method called `drawSnapshot` that takes as input a [game snapshot](http://localhost:41071/docs/interfaces/sections/java_interfaces/#snapshotExample) and draws this snapshot on screen. The backend calls this method whenever a snapshot must be drawn. However, the backend may send these snapshots _faster_ than they can be displayed (due to the duration of on-screen animations). To deal with this scenario, the \"view\" **buffers** the snapshots that it receives (displaying a new snapshot only after all previously submitted ones have been displayed). For the sake of this exercise, you can think of this buffer as an array with type `Snapshot[]`. Now consider the following method `deleteUnit(int x, int y)`, executed by our backend each time it receives the instruction to delete a unit: ```java public class Backend implements EventHandler { Snapshot currentSnapshot; ... public void deleteUnit(int x, int y){ if(\u003c\"there is a unit on the tile x, y\"\u003e){ removeUnitFromTile(x, y); drawSnapshot(currentSnapshot); shiftUnitsInColumn(x); drawSnapshot(currentSnapshot); performUnitMerges(); drawSnapshot(currentSnapshot); ... } } } ``` where the auxiliary methods `removeUnitFromTile`, `shiftUnitsInColumn` and `performUnitMerges` may modify the object `currentSnapshot`. Observe that the method `deleteUnit` calls `drawSnapshot` three times. Now let us assume that the buffer of the \"view\" is nonempty when this method is executed, so that the 3 snapshots are added to the buffer, before any of them can be rendered on screen. How many of these 3 snapshots will be drawn on screen? Solution Only the third snapshot will be drawn (three times), because the buffer contains three references to the same object. Shallow, deep and hybrid copy # Copying a reference to an object can be viewed as the shallowest possible form of copy. As we saw already, this is what happens in Java when a variable with reference type is passed as argument.\nAt the other end of the spectrum is a so-called deep copy, where all attributes of the copied object are duplicated, recursively. In this case, the copy or any object that it references (recursively) can be modified without affecting their original counterparts.\nBetween these two extremes:\na shallow copy creates a new object (with fresh attributes), but does not copy referenced objects recursively, a hybrid copy is anything between a shallow copy and a deep copy. in Java # Copy constructor # A copy can be performed in Java with a so-called **copy constructor**. This is an additional constructor that takes an instance of the class as input, and returns a copy of this instance. For example:\npublic class Hero { int health; // standard constructor public Hero(){ this.health = 10; } // copy constructor public Hero(Hero original){ this.health = original.health; } } In order to perform a deep(er) copy, a copy constructor may call another copy constructor. For example:\npublic class Snapshot { Hero firstHero; Hero secondHero; Board board; int remainingActions; // standard constructor public Snapshot(Hero firstHero, Hero secondHero, Board board, int remainingActions){ // some code here ... } // copy constructor public Snapshot(Snapshot original){ this.firstHero = new Hero(original.firstHero); this.secondHero = new Hero(original.secondHero); this.board = new Board(original.board); this.remainingActions = original.remainingActions; } } **_Warning._** Similarly to what we saw with the methods [toString](http://localhost:41071/docs/objects/sections/tostring/#recursion) or [equals](http://localhost:41071/docs/objects/sections/comparing/#recursion), beware of recursive implementations of copy constructors, if your program can create an object that refers to itself (directly or indirectly). The method clone # Java also provides a native method called clone to duplicate objects. Like the methods toString and equals that we saw earlier, clone is an instance method of the native Java class Object, which is an (implicit) superclass of every other class.\nOverriding clone can be more concise than using a copy constructor (especially for a class with a large number of attributes).\n**_Warning._** Overriding `clone` can be _error-prone_, especially in presence of a class hierarchy (see [Effective Java](http://localhost:41071/docs/intro/sections/bibliography/#effectiveJava), Item 13 for further insight). Notably, the overriding class must implement the `Cloneable` interface, and an implementation of `clone` usually calls `super.clone` recursively (even for a class whose only superclass is `Object`). For these reasons, overriding `clone` is sometimes discouraged, in favor of conceptually simpler solutions (like copy constructors). "},{"id":98,"href":"/docs/input/sections/json/","title":"JSON Serialization","section":"I/O and serialization","content":" JSON serialization # A number of (external) libraries allow transforming Java objects into JSON objects and conversely. For instance Jackson, Gson, JSON-java, JSON-B and JSON-P.\nIn this section, we focus on Jackson.\n**_Note._** Jackson was initially designed for JSON, but extensions of Jackson allow manipulating [other formats](https://github.com/FasterXML/jackson-dataformats-text/tree/2.18): XML, TOML, YAML, CSV and Java property files. Install # Jackson can be used within a Maven project, by declaring the following dependency\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.17.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; And similarly for Gradle:\nimplementation group: \u0026#39;com.fasterxml.jackson.core\u0026#39;, name: \u0026#39;jackson-databind\u0026#39;, version: 2.17.0 For the latest version, search Maven Central.\nInstalling this dependency will transitively install:\njackson-annotations jackson-core Basic syntax # Many tutorials can be found online about Jackson: for instance Jackson in N minutes on the GitHub page of the jackson-databind library.\nWe focus here on some simple features of the library.\nAn ObjectMapper can be used to map a Java object (or array or value) to some JSON string, and conversely.\nObjectMapper mapper = new ObjectMapper(); // Indent the output JSON strings when applicable mapper.enable(SerializationFeature.INDENT_OUTPUT); Convert a value # Serialize # // Outputs 15 System.out.println(mapper.writeValueAsString(15)); // Outputs \u0026#34;abcd\u0026#34; System.out.println(mapper.writeValueAsString(\u0026#34;abcd\u0026#34;)); Deserialize # Convert an array or collection # Serialize # // Outputs [2,3] System.out.println(mapper.writeValueAsString(new int[]{2, 3})); // Outputs either [2,3] or [3,2] System.out.println(mapper.writeValueAsString(Set.of(2, 3))); Map\u0026lt;String, Integer\u0026gt; studentToAge = Map.of( \u0026#34;Alice\u0026#34;, 20, \u0026#34;Bob\u0026#34;, 19 ); /* Outputs { \u0026#34;Alice\u0026#34; : 20, \u0026#34;Bob\u0026#34; : 19 } */ System.out.println(mapper.writeValueAsString(studentToAge)); Map\u0026lt;String, List\u0026lt;Integer\u0026gt;\u0026gt; studentToMarks = Map.of( \u0026#34;Alice\u0026#34;, List.of(8,9), \u0026#34;Bob\u0026#34;, List.of(6,10) ); /* Outputs { \u0026#34;Alice\u0026#34; : [ 8, 9 ], \u0026#34;Bob\u0026#34; : [ 6, 10 ] } */ System.out.println(mapper.writeValueAsString(studentToMarks)); Deserialize # // Creates an array with values [2,3,2] int[] integers = mapper.readValue(\u0026#34;[2,3,2]\u0026#34;, int[].class); // Creates an Arraylist with values [2,3,2] List\u0026lt;Integer\u0026gt; list = mapper.readValue(\u0026#34;[2,3,2]\u0026#34;, List.class); // Creates a HashSet with values {2,3} Set\u0026lt;Integer\u0026gt; set = mapper.readValue(\u0026#34;[2,3,2]\u0026#34;, Set.class); // Creates a LinkedHashMap with values {\u0026#34;Alice\u0026#34; -\u0026gt; 20, \u0026#34;Bob\u0026#34; -\u0026gt; 19} Map\u0026lt;String, Integer\u0026gt; map = mapper.readValue(\u0026#34;{\\\u0026#34;Alice\\\u0026#34;: 20, \\\u0026#34;Bob\\\u0026#34;: 19}\u0026#34;, Map.class); Convert an object # Serialize # ```java public class City { public String name; public Country country; public City(String name, Country country) { this.name = name; this.country = country; } } ``` ```java public class Country { public String name; public City capital; public Country(String name, City capital) { this.name = name; this.capital = capital; } } ``` Country italy = new Country(\u0026#34;Italy\u0026#34;, null); City rome = new City(\u0026#34;Rome\u0026#34;, italy); /* Outputs: { \u0026#34;name\u0026#34; : \u0026#34;Rome\u0026#34;, \u0026#34;country\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Italy\u0026#34;, \u0026#34;capital\u0026#34; : null } */ System.out.println(mapper.writeValueAsString(rome)); However, recall that a JSON object cannot contain a reference to another JSON object. As a consequence, some Java objects cannot be finitely represented in JSON:\nitaly.capital = rome; // Throws a JsonMappingException: Document nesting depth (1001) exceeds the maximum allowed mapper.writeValueAsString(rome); By default, Jackson serializes:\npublic (instance) attributes, non-public fields that have a getter method. However, it is also possible to force serialization of other attributes, either for all classes:\nmapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY); or for a specific class:\n@JsonAutoDetect(fieldVisibility = Visibility.ANY) public class MyClass { ... } **_Warning._** If a public attribute `attribute` and a getter `getAttribute` coexist, then the latter takes precedence. Some public attributes can also be explicitly ignored:\n@JsonIgnoreProperties(\u0026#34;name\u0026#34;) public class MyClass { public String name; ... } Deserialize # In order to create a Java object out of a JSON object, the attributes (a.k.a. \u0026ldquo;keys\u0026rdquo;) of the JSON object must be mapped to attributes of the targeted class.\nThis can be done by adding (Jackson-specific) annotations to a constructor for the class. For instance:\npublic class City { public String name; public int zipCode; @JsonCreator public City(@JsonProperty(\u0026#34;name\u0026#34;) String name, @JsonProperty(\u0026#34;code\u0026#34;) int zipCode) { this.name = name; this.zipCode = zipCode; } } String jsonCity = \u0026#34;{\\\u0026#34;name\\\u0026#34; : \\\u0026#34;Bologna\\\u0026#34;, \\\u0026#34;code\\\u0026#34; : 40100 }\u0026#34;; // Contains the object City{ name: \u0026#34;Bologna\u0026#34;, zipCode: 40100 } City bologna = mapper.readValue(jsonCity, City.class); In the example above, the annotations @JsonProperty(\u0026quot;name\u0026quot;) and @JsonProperty(\u0026quot;code\u0026quot;) indicate which JSON attributes are used to create an instance of Country. Note that the name of the JSON attribute and the name of the constructor argument can differ (e.g. \u0026ldquo;code\u0026rdquo; and zipCode in this example).\nThese annotations can also be used to populate more complex structures, such as nested objects, arrays, collections, etc. For instance:\npublic class Country { String name; @JsonCreator public Country(@JsonProperty(\u0026#34;name\u0026#34;) String name) { this.name = name; } } String jsonCountries = \u0026#34;[ \u0026#34; + \u0026#34;{\\\u0026#34;name\\\u0026#34; : \\\u0026#34;Italy\\\u0026#34;}, \u0026#34; + \u0026#34;{\\\u0026#34;name\\\u0026#34; : \\\u0026#34;Austria\\\u0026#34;} \u0026#34; + \u0026#34;]\u0026#34;; /* Contains the objects Country{ name: \u0026#34;Italy\u0026#34; } and Country{ name: \u0026#34;Austria\u0026#34; }, in this order. */ Country[] countries = mapper.readValue(jsonCountries, Country[].class); Exercise What does the following program print? ```java public class City { public String name; public Country country; @JsonCreator public City(@JsonProperty(\"name\") String name, @JsonProperty(\"country\") Country country) { this.name = name; this.country = country; } } ``` ```java public class Country { public String name; @JsonCreator public Country(@JsonProperty(\"name\") String name){ this.name = name; } } ``` ```java Country italy = new Country(\"Italy\"); City rome = new City(\"Rome\", italy); City bologna = new City(\"Bologna\", italy); City[] cities = new City[]{rome, bologna}; // count countries System.out.println(countCountries(cities)); // serialize String serializedCities = mapper.writeValueAsString(cities); // deserialize City[] deserializedCities = mapper.readValue(serializedCities, City[].class); // count countries System.out.println(countCountries(deserializedCities)); // Counts the number of distinct countries that appear in the input array private int countCountries(City[] cities) { Set countries = new HashSet\u003c\u003e(); for(City city: cities){ countries.add(city.country); } return countries.size(); } ``` Solution 1 2 Writing to or reading from a file # The ObjectMapper class provides utility methods to write (resp. read) the JSON output (resp. input) directly to (resp. from) a file. In particular, in the examples above:\nwriteValueAsString(o) can be replaced with writeValue(file, o), readValue(string, class) can be replaced with readValue(file, class). For instance:\n// Serialize try { mapper.writeValue(new File(\u0026#34;path/to/file.json\u0026#34;), rome); } catch (IOException e) { throw new RuntimeException(e); } // Deserialize City myCity; try { myCity = mapper.readValue(new File(\u0026#34;path/to/file.json\u0026#34;), City.class); } catch (IOException e) { throw new RuntimeException(e); } "},{"id":99,"href":"/docs/env/sections/text_editor/","title":"Text editor","section":"Development environment","content":" Text editor # A text editor allows you to edit plain (i.e. non-formatted) text. A text editor can open any file produced with a text editor (and more), regardless of the file\u0026rsquo;s extension.\nIn this sense, Microsoft Word is not a text editor (neither are Apple Pages or LibreOffice Writer).\nMost operating systems comes with one or several text editor(s) pre-installed, such as Notepad++ (Windows), TextEdit (macOS), gedit (default Ubuntu), etc.\nUsage # Your IDE is an (enhanced) text editor, so you can use it as such.\nBut it some scenarios, it can be useful to use a lighter program, for instance for:\nediting the configuration file of a program, modifying a small script (or even a single command-line instruction) copy-pasted from the web, etc. Among other reasons:\nopening an IDE can take time, if your IDE has autosave enabled, you may accidentally add unrelated files to your current project, etc. Advanced text editors # For most purposes, a basic text editor should be sufficient.\nBut depending on your workflow, you may want to try a more advanced one.\nVSCode # We already introduced VSCode in the section dedicated to IDEs.\nvi and emacs # We also bring to your attention two keyboard-centric editors called vi and emacs. Both were developed in the 70\u0026rsquo;s (before the mouse became a widespread peripheral) but are still commonly used today (in some form) by developers.\nWe do not recommend learning vi or emacs at this (early) stage of your studies, because it often requires time, and you arguably have more fundamental thing to learn. But you may give them a try at some point of your career, because they may significantly improve your productivity.\nvi/vim/neovim # vi was initially released 1978, as part of the first BSD distribution. The original program is rarely used today, but vim (for \u0026ldquo;vi improved\u0026rdquo;), released in 1991, and neovim, released in 2015 are still popular among developers. For instance, 22% (resp. 12%, non-exclusive) of respondents to the 2023 Stack Overflow developer survey use vim (resp. neovim) as a code editor.\nvi/vim/neovim is a so-called modal editor, meaning that users can switch between different modes. In one mode, pressing a standard key inserts the corresponding character on screen, whereas in another mode, pressing the same key has a different functionality (navigation, copy, paste, etc.). These functionalities are referred to as vi keybindings or vi motions, and allow performing a variety of text editing operations in an efficient way.\nvi keybindings are commonly used in applications other than vi/vim/neovim, with dedicated plugins. For instance, most code editors/IDEs (VSCode, IntelliJ IDEA, emacs, etc.), terminal emulators or even web browsers have plugins for vi keybindings.\n**_Note._** Vim and neovim are very customizable, with comprehensive collections of (community-developed) plugins, which allows using them as IDEs. We do _not_ recommend trying this at this stage of your studies, because configuration may require a very significant time investment (significantly more than VSCode for instance). The original vi still comes pre-installed on many operating systems (Windows, macOS, Linux, ...), and may be the default text editor opened by terminal-based applications (e.g. git) on your system. If this is the case (and if you do not know the vi keybindings), we recommend _changing_ this setting. Emacs # Emacs was initially written in 1976. The most popular version is GNU Emacs, released in 91, was notably co-developed by Richard Stallman.\nEmacs is partly responsible for popularizing (sequences of) combinations of keys (e.g. Ctrl+\u0026lt;letter\u0026gt;), as opposed to modal editors like vi. GNU Emacs has more than 10 000 built-in commands, and also provides a (limited) mouse interface.\n5% of respondents to the 2023 Stack Overflow developer survey use emacs as a code editor.\nEmacs is also very customizable, with a comprehensive collections of (community-developed) plugins (probably more comprehensive than vim), and dedicated software repositories. Notably, Emacs tends to serve as a unique user interface for a variety of tasks (code editing, terminal emulation, email management, web browsing, playing music/videos, etc.). **_Note._** Emacs can be used as an IDE, but for the same reason as for vim or neovim, we do _not_ recommend trying this at this stage of your studies. "},{"id":100,"href":"/docs/env/sections/eval/","title":"Evaluation environment","section":"Development environment","content":" Evaluation environment # The evaluation environment for your project is a virtual machine (with Ubuntu 20) deployed on Microsoft Azure. You are not supposed to develop on this machine, but your project must run in this environment to be evaluated.\nEach student gets his or her own clone of the original machine. Maven, Gradle, git and a Java 17 JDK are already installed.\nYou can log in to this machine via ssh (using a terminal), or via RDP (using an RDP client).\nHere is a (non-exhaustive) list of RDP clients:\nWindows:\nWindows Remote Desktop (built in), also called MSTSC Royal TS macOS:\nMicrosoft Remote Desktop Royal TS Linux:\nRemmina rdesktop The registration link is shared on the Microsoft Team for this course. After logging in (with your Unibz credentials), you should see the following:\nToggling the button (bottom-left) will start your own clone of the virtual machine (this may take a few minutes).\nOnce your machine is running, click on the 3 dots (bottom right) and select \u0026ldquo;show RDP information\u0026rdquo;. This will give you the string (host name and port) needed by your RDP client to connect to the machine.\nThe credentials for logging in to the machine are also shared on the Microsoft Team for this course.\nOnce connected:\nyou can select a keyboard layout (English, German or Italian) from the drop-down menu at the top right of the screen,\nyou can use the super key (a.k.a. \u0026ldquo;Windows key\u0026rdquo;) or click on \u0026ldquo;Activities\u0026rdquo; (top left) to display the application menu below. To launch a terminal, click on the terminal icon in this menu or press Ctrl + Alt + t.\n"},{"id":101,"href":"/docs/objects/sections/quasi-objects/","title":"Quasi-objects","section":"Objects and classes","content":" Quasi-objects # Enumerated types # Most imperative languages allow the creation of so-called enumerated types.\nAn enumerated type is a datatype for a finite set or enumerated values. For instance, if our game only allows \u0026ldquo;blue\u0026rdquo;, \u0026ldquo;green\u0026rdquo; and \u0026ldquo;red\u0026rdquo; as unit colors, then we may create a dedicated type that only allows these three values.\nIn Java # An enumerated type in Java is a set of constants. These constants are effectively static, meaning that they depends on the class or interface where the enumerated type is declared (similarly to a static attribute). The name of an enumerated type can generally be used like a regular reference type. For instance\npublic class Unit { enum UnitColor {BLUE, GREEN, RED} int health; UnitColor color; public Unit(int health, UnitColor color){ this.health = health; this.color = color; } ... } **_Note._** In the above example, the enumerated type `UnitColor` could equivalently be represented with an integer. For instance, `0` for blue, `1` for green and `2` for red. However, with such an encoding, a conditional statement (e.g. `if` or `switch`) that checks the color of a unit would also need to handle the case of values `\u003c 0` or `\u003e 2`. So (besides readability), a benefit of the enumerated type in this case is that it restricts possible inputs to _valid_ ones. **_Hint._** Enumerated types in Java are significantly more expressive than their counterparts in some other languages. Notably, a Java `enum` can have its own [constructor and methods](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html). Records # A record is an object whose attributes cannot be modified.\nin Java # Records were introduced in Java 14 (2020). They are a convenient way to avoid boilerplate code. Records provide a concise syntax for \u0026ldquo;lightweight\u0026rdquo; classes that are only meant to hold data.\nFor instance, here is the full implementation of a record City:\npublic record City(String name, int zipCode) {} This record has an implicit constructor, and implements equals, hashcode and toString in the expected way. For instance:\nCity florence = new City(\u0026#34;Florence\u0026#34;, 50100); City florenceAgain = new City(\u0026#34;Florence\u0026#34;, 50100); // Outputs true. System.out.println(florence.equals(florenceAgain)); The attributes of a record cannot be modified. For instance, the following program does not compile:\nCity florence = new City(\u0026#34;Florence\u0026#34;, 50100); florence.zipCode = 50121; A record is often declared inside a class or interface. For instance, in our game:\npublic class Board { public record TileCoordinates(int X, int Y){}; ... } Records are convenient for methods that need to return more than one value. For instance:\nTileCoordinates getOngoingMove(); Strings # Interning # Many modern languages (such as Java, C#, Python, Ruby, JavaScript, Go, etc.) support a technique called **interning**, in order to manage strings in memory. This consists in storing only one copy of each distinct string created during the execution of a program. These strings are stored in a shared **pool**, and each of them is an [immutable](http://localhost:41071/docs/objects/sections/mutability/) object (meaning that it cannot be modified). Some benefits are faster string comparisons, lower memory footprint, etc.\nin Java # In Java, a string is an object. Like for regular objects, comparing two variables of type String with == compares their references:\nString myString = new String(\u0026#34;foo\u0026#34;); String sameString = new String(\u0026#34;foo\u0026#34;); // Outputs false, because the two variables hold different references. System.out.println(myString == sameString); A string can be explicitly interned (i.e. added to the shared pool) with the (instance) method intern. This method:\ntries to add the string to the pool, and then returns a reference to the (only) version of the string contained in the pool. For instance, consider the following program:\n// Creates a string \u0026#34;foo\u0026#34;, String myString = new String(\u0026#34;foo\u0026#34;) // adds it to the pool, myString = myString.intern(); // Creates another string \u0026#34;foo\u0026#34;, String sameString = new String(\u0026#34;foo\u0026#34;); // Outputs false. System.out.println(myString == sameString); // Tries to add \u0026#34;foo\u0026#34; to the pool once again. // Because the pool already contains a version of \u0026#34;foo\u0026#34;, returns a reference to it. sameString = sameString.intern(); // Outputs true, because the two variables now hold the same reference. System.out.println(myString == sameString); A string that is initialized without constructor (i.e. directly with \u0026quot; \u0026ldquo;) is interned. For instance\nString myString = \u0026#34;foo\u0026#34;; String sameString = \u0026#34;foo\u0026#34;; // Outputs true, because of (implicit) interning System.out.println(myString == sameString); In order to support interning, string in Java are immutable.\nIn particular, the instance methods of the class String (like substring, etc.) do not modify a string. Instead, some of them may return (a reference to) a different object. For instance:\nString foo = new String(\u0026#34;foo\u0026#34;); String copy = foo; // Outputs true, because the two variables hold the same object reference. System.out.println(copy == foo); foo = foo.replace(\u0026#39;o\u0026#39;,\u0026#39;O\u0026#39;); // Outputs false, because the method \u0026#39;replace\u0026#39; returns a reference // to another object. System.out.println(copy == foo); The class String overrides the method equals so that it implements string comparison in the expected way. For instance:\nString myString = new String(\u0026#34;foo\u0026#34;); String sameString = new String(\u0026#34;foo\u0026#34;); // Outputs false. System.out.println(myString == sameString); // Outputs true. System.out.println(myString.equals(sameString)); **_Hint._** By default, you can always use `equals` to compare the values of two strings. This is less error-prone than `==` (albeit less efficient if the two strings differ). Java boxed types # Java has 8 primitive types: byte, short, int, long, float, double, boolean and char.\nFor each primitive type, Java has a so-called boxed or (wrapper) type: Byte, Short, Integer, Long, Float, Double, Boolean and Character.\nThese types can be used in Java collections (Set, List, etc.), whereas primitive types cannot. Some boxed types also offer additional functionalities, via instance methods (e.g. an Integer can represent a positive numbers up to \\(2^{32} - 1\\) ).\nConstructors for boxed types are deprecated. Instead, instances can be created via so-called autoboxing, for instance:\nInteger myInteger = 2; Character myCharacter = \u0026#39;a\u0026#39;; Several Java operators (like +, ==, \u0026lt;=, etc.) are also overloaded so that they behave with boxed types as they would with primitive types. For instance:\nInteger i = 1; i += 1; Integer j = 2; // Outputs true System.out.println(i == j); Like strings, instances of boxed types are immutable. This can affect performance. For instance:\nfor (Integer i = 0; i \u0026lt; 1000000 ; i++){ ... } may create up to 1 million objects in memory. This is one of the reasons why it is usually recommended to use primitive types whenever possible (see for instance Effective Java, Item 61). Some boxed types are (partially) interned, analogously to strings.\n"},{"id":102,"href":"/docs/abstractdatatypes/sections/sorting/","title":"Sorting","section":"Abstract data types","content":" Sorting # Sorting a collection (of values or objects) is needed in a variety of scenarios.\nSorting criterion # In order to sort a collection of values (resp. objects), we need a sorting criterion, i.e. a way to compare two values (resp. objects).\nSome data types come with a natural way to compare two values. For instance, two real numbers can be compared w.r.t. $\\le$.\n**_Observation._** Some data type have several natural sorting criteria. For instance, strings may be sorted alphabetically from left to right (in English, Hindi, Russian, etc.) or from right to left (in Arabic, Hebrew, Persian, etc.). Question. What about objects, i.e. which sorting criterion can be used to sort a collection of people, cities, sets, lists, trees, etc.?\nAnswer. Any total preorder (i.e. a total, reflexive and transitive binary relation) can be used to sort a collection.\nExercise Which of the following are total preorders (i.e. can be used as a sorting criterion)? 1. Compare two real numbers w.r.t. to their absolute value. 2. Compare two people w.r.t. to their age. 3. Compare two people w.r.t. to their age _and_ size, i.e. $\\qquad \\qquad p_1 \\preceq p_2$ iff $\\big(p_1.{\\text{age}} \\le p_2.{\\text{age}}$ and $p_1.{\\text{size}} \\le p_2.{\\text{size}}\\big)$. 4. Compare two people w.r.t. to their age _or_ size, i.e. $\\qquad \\qquad p_1 \\preceq p_2$ iff $\\big(p_1.{\\text{age}} \\le p_2.{\\text{age}}$ or $p_1.{\\text{size}} \\le p_2.{\\text{size}}\\big)$. 5. Compare two people w.r.t. to their age, and then their size (if they have the same age). 6. Compare two points w.r.t. to their X coordinate, and then their Y coordinate (if they have the same X coordinate). 7. Compare two trees w.r.t. to their number of nodes. 8. Compare two sets w.r.t. to set inclusion. 9. Compare two lists of integers by first sorting them, and then comparing them lexicographically. Solution - 3. is a partial preorder, - 4. is not transitive, and - 8. is a partial order. The others are total preorders. Properties of sorting algorithms # Sorting algorithms have been extensively studied. We will not cover them this semester (with one exception), because this is part of another course of the bachelor.\nWe only highlight some of their properties.\nStability # **_Definition._** A sorting algorithm is **stable** if it preserves the initial order (in the input collection) of two elements that are equivalent w.r.t. to the sorting criterion. **_Example._** Consider an array `[u1, u2]` of type `Unit[]`, where (the objects referenced by) `u1` and `u2` both have health `2`. And let us sort the elements of this array by health. - A _stable_ sorting algorithm outputs `[u1, u2]`. - A _non-stable_ sorting algorithm may output `[u1, u2]` or `[u2, u1]`. In place # **_Definition._** A sorting algorithm is **in place** if it does not use additional data structures. in Java # Comparing # Java provides several native ways to define a total preorder. We highlight here two of them.\nComparable # A class T can implement the interface Comparable\u0026lt;T\u0026gt;.\n**_Example._** We can create a class `City` that implements `Comparable` as follows: ```java public class City implements Comparable { ... } ``` The interface Comparable\u0026lt;T\u0026gt; specifies a single method\nint compareTo (T otherObject); This method should define a total preorder $\\preceq$ over instances of T, as follows.\nLet $o_1$ be the current object (i.e. the instance used to call the method), and let $o_2$ be the other object (i.e. the argument of the method compareTo). Then this method should return:\na negative integer if $o_1 \\prec_o o_2$ (i.e. if $o_1 \\preceq_o o_2$ and $o_2 \\not\\preceq_o o_1$), 0 if $o_1 =_o o_2$ (i.e. if $o_1 \\preceq_o o_2$ and $o_2 \\preceq_o o_1$), a positive integer otherwise. **_Example (continued)._** Here is an implementation of the method `compareTo` where cities are compared by zip code: ```java public class City implements Comparable { public String name; public int zipCode; public City(String name, int zipCode) { this.name = name; this.zipCode = zipCode; } @Override public int compareTo(City otherCity) { return zipCode \u003c otherCity.zipCode ? -1 : zipCode == otherCity.zipCode ? 0 : 1; } } ``` **_Hint._** Some native Java classes already implement `Comparable`, in the expected way. For instance `Integer`, `String` (left to right alphabetical order), etc. **_Hint._** Comparator methods are also available for primitive types (like `int`, or `bool`). For instance, `Integer` has a static method `compare(int x, int y)` that behaves like `compareTo`. So the method `compareTo` in the example above can be simplified as follows: ```java public class City implements Comparable { ... @Override public int compareTo(City otherCity) { return Integer.compare(zipCode, otherCity.zipCode); } } ``` **_Warning._** The method `compareTo` is implicitly used by some of Java's native data structures (e.g. `TreeSet`). So it is usually recommended to implement `compareTo` in such a way that it \"complies\" with `equals` (and `hashCode`). This means that $\\qquad \\qquad $`o1.compareTo(o2)` should return `0` iff `o1.equals(o2)` returns `true`. If you want to use a sorting criterion that does _not_ satisfy this constraint (or if you want to use alternative sorting criteria for the same class), then we recommend using a `Comparator` instead (explained below). Comparator # A Comparator in Java is intuitively a total preorder.\nThe Java interface Comparator\u0026lt;T\u0026gt; specifies one method that must be implemented by each instance, with signature:\nint compare(T o1, T o2) The return value (negative integer, 0 or positive integer) has the same meaning as the one of Comparable.compareTo.\n**_Example (continued)._** We can create another comparator for our class `City`, which uses the city' name rather than zip code. ```java public class CityNameComparator implements Comparator { @Override public int compare(City c1, City c2) { return c1.name.compareTo(c2.name); } } ``` The interface Comparator also provides convenient (default) methods. For instance, the method thenComparing returns the lexicographic product of two comparators.\nSorting # Java provides several methods to sort an array or collection. We highlight here a few of them.\nSorting an array # For an array of type T[], the static method Arrays.sort(T[] array) can be called as follows:\n**_Example._** ```Java int[] integers = new integer[]{2,1,3,2}; Arrays.sort(integers) // Outputs [1,2,2,3] System.out.println(Arrays.toString(array)); ``` This method sorts the array using the so-called \u0026ldquo;natural ordering\u0026rdquo; for type T. The \u0026ldquo;natural ordering\u0026rdquo; is:\nthe one expected for primitive types (like int), boxed types (like Integer) and a few other native types (like String or Date); a list can be found here, the one defined by T.compareTo if T implements Comparable, underspecified if T is a class that does not implement Comparable. The method Arrays.sort(T[] array, Comparator\u0026lt;? super T\u0026gt; c) is similar, but it uses the input comparator to sort the array.\n**_Example(continued)._** ```Java City trento = new City(\"Trento\", 38121); City bologna = new City(\"Bologna\", 40100); City[] cities = new City[]{trento, bologna}; // After this, the array 'cities' contains [bologna, trento] Arrays.sort(cities, new CityNameComparator()); ``` **_Property._** Both methods guarantee _stable_ sorting. For instance: ```Java City trento1 = new City(\"Trento\", 38122); City bologna = new City(\"Bologna\", 40100); City trento2 = new City(\"Trento\", 38121); City[] cities = new City[]{trento1, bologna, trento2}; // After this, the array 'cities' contains [bologna, trento1, trento2] Arrays.sort(cities, new CityNameComparator()); ``` **_Note._** For an array with primitive type (like `int[]`), these two methods use (a version of) the [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm, even though Quicksort is _not_ stable. Stability is irrelevant for these types: for instance, permuting the elements of the array `[5,5]` yields the same array. However, for an array with (arbitrary) reference type (like `City[]`), these methods use (a version of) the [MergeSort](https://en.wikipedia.org/wiki/Merge_sort) algorithm, which is stable. Sorting a list # The class Collections provides a method Collection.sort(List\u0026lt;T\u0026gt; list), whose behavior is analogous to Arrays.sort. In particular, it also guarantees stable sorting. Like Arrays.sort, it comes in two flavors (with and without comparator).\n**_Example(continued)._** ```Java City bologna = new City(\"Bologna\", 40100); City trento = new City(\"Trento\", 38122); List cities = new LinkedList(); cities.add(bologna); cities.add(trento); // After this, the list 'cities' contains [trento, bologna], // due to the way 'City' implements 'compareTo'. Collections.sort(cities); // After this, the list 'cities' contains [bologna, trento], Collections.sort(cities, new CitynameComparator()); ``` The interface List also provides a default method sort that takes a comparator as argument. So in the above example, we could have used:\ncities.sort(new CitynameComparator()); instead of\nCollections.sort(cities, new CitynameComparator()); Usage # Exercise Consider the following class: ```java public class Hero { String name; int health; public Hero(String name, int health){ this.name = name; this.health = health; } } ``` Write a Java method `void printHeroesOcc(Hero[] heroes)` that takes as input an array of type `Hero[]`, and prints the number of occurrences of each hero in this array, where two heroes are considered identical if they have the same name and health. **_Constraint._** For this exercise, you _cannot_ use an associative array (a.k.a. Java `Map`). Possible solution Create a comparator (compare first by health, then by name): ```Java public class HeroComparator implements Comparator { @Override public int compare(Hero h1, Hero h2) { if(h1.health \u003c h2.health) { return -1; } if(h1.health \u003e h2.health) { return 1; } return h1.name.compareTo(h2.name); } ``` Sort the array and iterate over it to count the number of occurrences of each hero: ```Java void printHeroesOcc(Hero[] heroes) { if (heroes.length == 0) { return; } Comparator comparator = new HeroComparator(); // sort the input array w.r.t. to the comparator Arrays.sort(heroes, comparator); // keeps track of the last hero seen so far Hero previousHero = heroes[0]; // occurrences of the last hero seen so far int occ = 1; // iterate over the array, starting fom the second hero for (int i = 1; i \u003c heroes.length; i++) { // if the current hero and the previous one have the same // name and amount of health if (comparator.compare(previousHero, heroes[i]) == 0) { occ++; } else { printHero(previousHero, occ); previousHero = heroes[i]; occ = 1; } } printHero(previousHero, occ); } private void printHero(Hero hero, int occ) { System.out.println(hero.name + \",\" + hero.health + \": \" + occ); } ``` **_Note._** The solution to the exercise above relies on sorting the input array. But the same problem could be solved with an [associative array](http://localhost:41071/docs/abstractdatatypes/sections/map/), as follows: - override `equals` and `hashCode` in the class `Hero`, - compute a `Map` that maps each hero to its number of occurrences in the input array, - iterates over the entries of this map and print them. When it comes to running time, the latter solution is more efficient _on average_ (assuming a hashmap), but less efficient _in the worst case_. "},{"id":103,"href":"/docs/git/sections/ignore/","title":"Ignoring files","section":"git","content":" Ignoring files # You can add a file named .gitignore to the root folder of your repository.\nIt specifies files that cannot be staged.\nThis is commonly used to exclude from a repository:\ncompiled code (e.g. files with the extension .class in Java), dependencies (e.g. the content of the /node_modules folder in a Node.js project), IDE-generated files (e.g. the .idea/ folder for IntelliJ), OS-generated files (e.g. .DS_Store/ folders for macOS), etc. The .gitignore file uses a dedicated syntax to specify which files should be excluded.\nFor instance the pattern *.class excludes all files with the extension .class.\nHere is a quick tutorial about the syntax of .gitignore files.\nThis repository also contains a large collection of .gitignore patterns, for different programming languages, operating systems, programs, etc. For instance Java, VSCode, IntelliJ, Windows, macOS, Linux, etc.\n"},{"id":104,"href":"/docs/env/sections/terminal/","title":"Terminal","section":"Development environment","content":" Terminal # Using a terminal can be necessary during development, in order to execute a program that does not have a graphical user interface (GUI).\nBut even when a GUI is available, a Command Line Interface (CLI) can still be the preferred way to interact with some programs. Possible benefits are:\nefficiency (thanks to autocompletion, there is very little to type), automation (via scripting), more transparency (a GUI may add a layer of obfuscation), stability over time (GUIs tend to change from one version of a program to another), reproducibility (the same command performs the same action, with a limited reliance on memory), customizability. Demonstration # The following demo is meant to (quickly) illustrate some benefits of a properly configured terminal, as well a few terminal-based applications.\nThis is not an introduction to bash or Linux core utilities.\nVirtual environment # For this demo, we deployed a virtual machine with a pre-configured terminal.\nThe instructions for connecting to this machine are identical to the one for the project evaluation environment.\nCreating a static website # As an exercise, we will create a static website, using a simple framework called Hugo.\nFirst, in our home folder, let us create a subfolder dedicated to our projects. For instance, we can call this subfolder workspace. To create this folder, open a terminal and run:\nmkdir workspace Then navigate to this folder with the command cd (you do not need to type the full name of the directory, just type cd w, and press the Tab key for autocompletion):\ncd workspace Next, we will (loosely) follow the quick start tutorial for Hugo. Explanations about some of the command below can be found here.\nCopy-paste the following instruction and press Enter:\nhugo new site mySite This will create a project in a fresh folder called mySite. Let us navigate to it (again, you can take advantage of autocompletion):\ncd mySite Now copy-paste the following commands to declare this folder as a git repository and download a graphical theme for our website:\ngit init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml Navigation # At any moment, you can run the command:\npwd to display the current directory. With this command, you can check that you are indeed in the folder mySite.\nTo get a overview of the content of the current folder, run:\nll To get a recursive overview of the content of this folder, run:\ntree In order to navigate to a certain subfolder in this tree, we can take advantage of the fuzzy finder. For instance, let us assume that we want to move to some folder called socials, but we forgot its exact path.\nRun:\nc This will display the paths to all directories in this tree. You can type characters to restrict your search, and use the up down arrow keys to select your destination. For instance, type the three character soc. The best matches are displayed at the bottom of the list. To select one of them, navigate up and down with the arrow keys and press Enter.\nNote. Thanks to fuzzy search, the characters that you type do not need to be contiguous in a path. For instance, when you typed soc, all paths containing these three letters (in that order, but not necessarily contiguous) were retained.\nNow let us navigate back to the mySite folder. Here we can use zoxide, which uses our path navigation history to guess our destination. Run:\nz mySite (or possibly fewer letters).\nSimilarly, to go back to the socials subfolder that we previously went to:\nz socials Alternatively, you can switch between your current location and the previous one (thanks to zoxide still) with:\nzz Starting the web server # Navigate (back) to the mySite folder (you should know how to do this by now), and run:\nhugo server This will start a local development server for our website. To visualize the site, open Firefox (from the app menu), and use the address displayed in the terminal (it should be http://localhost:1313/)\nTo stop the server (or any Linux process running in a terminal), go back to the terminal an press Ctrl+C.\nNext, we will add content to our website, while keeping the server running.\nTo restart the server, we can use our command history. Type the first letters of the command that we used above to start the serve (e.g. hu). By pressing the up and down arrow keys, you can scroll through the commands that you already typed and start with these letters. Scroll until you find the command hugo server, and press Enter to restart the server.\nIn order to keep the server running, we will execute our next command in another terminal. You can create a new one by clicking on the boxed \u0026ldquo;+\u0026rdquo; icon:\nAdding content # Navigate to the (immediate) subfolder content of mysite. Then create a subfolder named posts:\nmkdir posts Navigate to this new folder. Then create a new text file called myPost.md. You can for instance do this with the command:\ngedit myPost.md which will open the file with the test editor \u0026ldquo;gedit\u0026rdquo;.\nNote. If you only type ge followed by Tab, the shell will suggest you a list of programs whose name starts with these letters. You can scroll through them by pressing Tab again, or add a letter to disambiguate your search.\nIn the text editor, copy-paste the following content:\n+++ title = \u0026#39;My First Post\u0026#39; date = 2024-01-14T07:07:07+01:00 +++ ## Introduction This is **bold** text, and this is *emphasized* text. ### Subsection This is a [link](https://gohugo.io) to the Hugo website. In this file, everything below the header (title/date) is written in Markdown.\nSave the file, and check with Firefox that your first post has been added to your website (to see your changes, you may need to force Firefox to clear its cache: in \u0026ldquo;Settings | Privacy \u0026amp; Security | Cookiesand Site Data\u0026rdquo;, click on the \u0026ldquo;Clear Data\u0026rdquo; button).\nAliases # The command c that we used above is actually an alias for a more complex command, namely cd $(find * -type d | fzf)\nWe declared this alias in the file ~/.zshrc (remember that ~ is a shortcut for your home folder).\nLet us open this file to see the declaration of this alias. Navigate to your home folder, for instance with:\ncd And list its content:\nll The file .zshrc should be there. Open this file with gedit:\ngedit .zshrc Note. Again, you can take advantage of autocompletion here. For instance, press ged followed by Tab followed by .z followed by Tab.\nTowards the end of this file, you will see the declaration of the alias:\nalias c=\u0026#39;cd $(find * -type d | fzf)\u0026#39; Let us create another useful alias. Ubuntu has a convenient command called xdg-open that opens a file with the default application associated to this file\u0026rsquo;s extension (this is the equivalent of a double-click in a graphical file browser). Let us set a simpler name than xdg-open to execute this command. For instance o (like \u0026ldquo;open\u0026rdquo;).\nFirst, let us check that the name o is not used already for another command. Open a new terminal and run:\no You should get a \u0026ldquo;command not found\u0026rdquo; message, which confirms that this command is free.\nNow let us add the following line to the .zshrc file:\nalias o=\u0026#39;xdg-open\u0026#39; Save the file and open a new terminal.\nYou can now use the o command to open any file.\nTo see this, let us navigate back to the socials folder that we were previously in (e.g. type z so, then up arrow key and then Enter). If you list the files in this folder (with ll), you will see that they have the .svg extension. To open one of these files, you can type o and the first letters of the name of the file, then Tab for autocompletion. This will open the file with the default image viewer application on this machine.\nScripts # If you want to use an alias to execute a (possibly complex) sequence of commands, then the preferred way is to write a script.\nFor instance, we could write a script that navigates to the mySite folder and then starts the hugo server. And we may use the alias ws (like \u0026ldquo;website\u0026rdquo;) to call this script (you can check that it is free).\nNavigate to the ~/bin folder, and create a text file called ws (for instance with gedit, as we did above for the post).\nIn this file, copy-paste the following:\n#! /bin/bash cd ~/workspace/mySite hugo server start Observe that these are the two instructions for the two tasks that we want to execute. Save the file, and make it executable by running:\nsudo chmod u+x ws To test your script, close all running instances of hugo (if any), e.g. with Ctrl + C, as explained above.\nNow regardless of your location, you can type ws to start the web server.\n**_Note._** Linux shells (such as bash or zsh) support the same language for commands and scripts. This is a full-fledged programming language (with conditional statements, loops, etc.), where an instruction can also be a command. Terminal-based applications # To conclude the demo, we introduce a few convenient applications that run in a terminal. These may save you time (compared to similar applications that rely on a GUI).\nripgrep # ripgrep allows you to search files that contain certain words or regular expressions (your IDE offers a similar functionality). For instance, let us assume that we want to search for all files under mySite that contain the string \u0026ldquo;Canada\u0026rdquo;.\nNavigate to the mySite folder. Then run:\nrg Canada This will display the path to each (text) file that contains this word (in this example, there is only one match), and the corresponding line numbers.\nranger # ranger is a popular terminal-based file browser.\nTo open it, type:\nranger You can navigate within the current directory with the up and down arrow keys, and in the directory tree (from child to parent and conversely) with the left and right arrow keys. Note that it also displays previews of text files.\nTo quit ranger, you can press the letter q.\nhtop # htop allows you to monitor processes running on your machine. To open it, type:\nhtop The upper part of the interface displays memory and CPU usage, whereas the lower part displays running process (sorted by CPU usage by default). You can kill a process with F9.\nTo quit htop, you can press the letter q.\nncdu # ncdu allows you to visualize the amount of disk space taken by your files and programs.\nTo open it, type:\nncdu The folders and files in the current folder are sorted by disk space, and you can navigate the directory tree using the arrow keys (like with ranger).\nTo quit ranger, you can press the letter q.\n"},{"id":105,"href":"/docs/objects/sections/encapsulation/","title":"Encapsulation","section":"Objects and classes","content":" Encapsulation # **Encapsulation** is a (vague) principle in object-oriented programming that refers to _\"bundling\"_ data with the code that operates on it, and _restrict visibility_ of this code and data to other components of a system. From Wikipedia: \u0026ldquo;Essentially, encapsulation prevents external code from being concerned [\u0026hellip;]\u0026rdquo;\nEach component hides its internal logic by exposing only data and methods that other components may need.\n**_Example._** As we saw [earlier](http://localhost:41071/docs/objects/sections/clone/), in our game, the \"view\" component (which is in charge of rendering the game on screen) may _buffer_ the game snapshots that it receives from the backend, if these snapshots are received faster than they can be displayed. As a buffer, this component uses a structure called a **queue**. This queue is _not exposed_ to other components, because they do not need to _see_ it, and (most importantly) should not _modify_ it. In other words, this queue is an implementation detail, _internal_ to the \"view\" component. Encapsulation can have many benefits. Among others:\nEasier debugging. If our queue is internal to the \u0026ldquo;view\u0026rdquo; component, then we know that it cannot be responsible for the malfunction of another component. Easier collaboration. Alice may refactor the implementation of the \u0026ldquo;view\u0026rdquo; component, knowing that this will not affect Bob, who is currently working on the backend. This is why a common practice in object-oriented programming consists in hiding all attributes and methods of a new class by default, and make accessible only the ones that need to be (in particular, this is likely to be the default behaviour of your IDE).\nEncapsulation also largely dictates how libraries are structured. For instance, when you create a String in Java, you do not have access to the internal representation of the string object.\nin Java # Each attribute or method of a class can have an access modifier, which specifies which other classes can access it. For instance, the keywords private and protected below are access modifiers.\nprivate int myAttribute; protected int myMethod(){ return 1; } **_Definition._** There are four levels of access in Java: - `private` restricts access to the _current class_, - \"package-private\" relaxes `private` by also allowing access from the _folder_ of the current class (in Java, a folder for source code is called a **package**), _excluding subfolders_, - `protected` relaxes \"package-private\" by also allowing access from the _subclasses_ of the current class, - `public` does not restrict access. **_Warning._** There is no keyword for the \"package-private\" level. Instead, this is the default level for an attribute or method _without_ access modifier. For instance, in the example below, the attribute `myAttribute` is package-private: int myAttribute; Here is a recap table from the Oracle tutorials:\nkeyword class package subclasses world private yes no no no none yes yes no no protected yes yes yes no public yes yes yes yes **_Warning._** A method declared in an [interface](http://localhost:41071/docs/interfaces/sections/java_interfaces/) is (implicitly) public. **_Warning._** If a method _m1_ overrides (or implements) a method _m2_, then _m1_ must be at least as accessible as _m2_. Exercise The following program does not compile. Can you see why, and how to fix this? ```bash âââ Run.java âââ units âââ Unit.java âââ impl âââ Unicorn.java ``` ```java public abstract class Unit { static String configFolder = \"path/to/config\"; } ``` ```java public class Unicorn extends Unit { String name; public Unicorn (String name){ this.name = name; } public static String getConfigFilePath (){ return configFolder + \"/unicorn.properties\"; } } ``` ```java public class Run { void testUnicorn(){ Unicorn myUnicorn = new Unicorn(\"Storm\"); myUnicorn.name = \"Tornado\"; } } ``` Solution - `Unicorn.getConfigFilePath` tries to access the package-private attribute `Unit.configFolder` (it should be made protected of public), - `Run.getConfigFilePath`, tries to access the package-private attribute `name` of `myUnicorn` (it should be made public). **_Hint._** Your IDE may suggest how to fix such compilation errors. To improve encapsulation, it is good practice to restrict access whenever possible (i.e. without compromising compilation).\n**_Hint_.** As a rule of thumb, in Java: - use `private` by default for all attributes and methods that you create, and - if the program does not compile, then use your IDE to relax access. Exercise Encapsulation in this program can be improved. Can you see how? ```bash âââ Run.java âââ units âââ Unit.java âââ impl âââ Unicorn.java ``` ```java public abstract class Unit { public int health; public Unit(int health) { this.health = health; } public void attack(Unit defender){ int copy = health; health -= defender.health; defender.health -= copy; } } ``` ```java public class Unicorn extends Unit { public Unicorn (){ super(1); } @Override public void attack(Unit defender){ regen(); super.attack(defender); } public void regen(){ health += 1; } } ``` ```java public class Run { void testUnicorn(){ Unicorn u1 = new Unicorn(); Unicorn u2 = new Unicorn(); u1.attack(u2); } } ``` Solution - `Unit.health` can be made protected, - the constructor of `Unit` can be made protected, - `Unit.attack` can be made protected, - `Unicorn.regen` can be made private. **_Note._** The constructor of an _abstract_ class can always be made protected (since it can only be called in the constructor of a subclass). Getters and setters # For attributes, the notion of \u0026ldquo;access\u0026rdquo; can be refined. An attribute may be:\nneither visible nor modifiable, or only visible, or only modifiable, or both visible and modifiable. This can be achieved with private attributes and so-called \u0026ldquo;getter\u0026rdquo; and \u0026ldquo;setter\u0026rdquo; methods. For instance, in the following class, the attribute health has public visibility but is not modifiable.\npublic class Unicorn { private int health; public int getHealth(){ return health; } } Conversely, in the following class, the attribute health can be modified but is not visible.\npublic class Butterfly { private int health; public void setHealth(int health){ this.health = health; } } **_Hint._** Getter and setter methods can be automatically generated by your IDE. To go further: inheritance violates encapsulation # Composition # **_Example_** (from [Effective Java](http://localhost:41071/docs/intro/sections/bibliography/#effectiveJava), Item 18). Consider a class `MyHashSet` that extends Java's `Hashset` functionality by keeping track of the number of objects _added_ to the set (as opposed to the output of `HashSet.size()`, which returns the numer of elements _remaining_ in the set). This class `myHashSet` may have an attribute `int counter` (initialized to `0`) that keeps track of the number of elements added to the set so far. And it may be implemented by overriding `add` and `addAll` in the expected way, i.e.: ```java @Override public boolean add(E e){ counter++; return super.add(e); } @Override public boolean addAll(Collection\u003c? extends E\u003e c){ counter += c.size(); return super.addAll(c); } ``` However, this implementation of `addAll` would count every insertion twice, because the implementation of `HashSet.addAll` calls `HashSet.add`. A design pattern called composition can be used to avoid such unintended effects. Intuitively, instead of extending the original class, use an instance Hashset set of it as a (private) attribute of the new class. However, this requires re-implementing all methods of the original class (albeit in a straightforward way), for instance:\npublic boolean isEmpty(){ return set.isempty(); } Prevent overriding or inheritance # As show by the example above, in order to improve encapsulation, one may want in some scenarios to forbid overriding a method or extending a class. In Java, this can be enforced with the keyword final, for instance:\npublic final class NonExtensibleClass { ... } public class MyClass{ public final void nonOverridableMethod(){ ... } } "},{"id":106,"href":"/docs/git/sections/resources/","title":"To go further","section":"git","content":" To go further # Here is a brief selection of resources about git (among many):\na (short) video that goes beyond the content of this chapter, the Atlassian git tutorials, the GitHub training material, guidelines about how to write an informative (yet readable) commit message. Misc # Here is a link to git\u0026rsquo;s very first commit.\n"},{"id":107,"href":"/docs/objects/sections/mutability/","title":"Mutability","section":"Objects and classes","content":" Mutability # Illustration # Exercise The Java method `createUsers` below is incorrect. Can you see why, and how to fix this? ```java public class User { int id; String name; } ``` ```java /* Input: - ids: a nonempty array of user identifiers - names: an array of the same length as 'ids' that contains user names Ouput: an array of users of the same lenght as 'ids', such as the i-th user has identifier ids[i] and name names[i] */ User[] createUsers(int[] ids, String[] names){ User[] users = new User[names.length]; User currentUser = new User(); for(int i = 0; i \u003c ids.length; i++){ currentUser.id = ids[i]; currentUser.name = names[i]; users[i] = currentUser; } return users; } ``` Possible solution The output array contains $i$ times the same user (with the last id and name from the input arrays). One way to fix this is: - add an explicit constructor to the class `User`: ```java public class User { int id; String name; public User(int id, String name){ this.id = id; this.name = name; } } ``` - call this constructor for each new user: ```java public User[] createUsers(int[] ids, String[] names) { User[] users = new User[names.length]; for(int i = 0; i \u003c ids.length; i++){ users[i] = new User(ids[i], names[i]); } return users; } ``` In this example, an instance of the class User is a mutable object, meaning that its attributes (id and name) can be modified after the object is created. However, these two values (or at least the value of the attribute id) are unlikely to change.\nIn Java (or C#, C++, etc.), it is possible to forbid these two values to be modified. This would have prevented compilation of the incorrect program above.\nImmutable object # Informally, an object is mutable if it can be modified after its creation.\nImmutability has many known benefits (but also drawbacks):\nBenefits # Easier debugging: as illustrated above, forcing an object to be immutable may prevent an incorrect program to compile. Compile-time errors are usually easier to fix that bugs. Readability: code that modifies or reuses objects can be harder to understand (and reason about) than code that creates (fresh) immutable objects. Thread-safety: multiple threads can access an immutable object concurrently without race condition. Easier collaboration and maintenance: Alice can safely pass an immutable object to Bob (i.e. make the object visible to Bob\u0026rsquo;s code). This will not affect the correctness of Alice\u0026rsquo;s code (because Bob\u0026rsquo;s code cannot modify this object). Reference. For a more in-depth analysis of the benefits of immutability, we refer to Effective Java, item 17:\n\u0026ldquo;Classes should be immutable unless there\u0026rsquo;s a very good reason to make them mutable.\u0026rdquo;\n**_Observation._** Some programming language (like Haskell or Rust), enforce (a form of) immutability by default. Drawbacks # Performance: on a large scale (e.g. thousands of objects), reusing existing object may be more efficient that creating (fresh) immutable ones. Terminology # The term \u0026ldquo;immutable object\u0026rdquo; (or \u0026ldquo;immutable class\u0026rdquo;) is used with slightly different meanings. In particular:\na weaker notion of immutability only requires the attributes of an object to be non-modifiable, a stronger notion also requires the objects that are referred to (transitively) to be non-modifiable. By convention, we will use in what follows the term \u0026ldquo;final\u0026rdquo; for the weaker requirement, and \u0026ldquo;immutable\u0026rdquo; for the stronger requirement. More precisely:\n**_Definition._** An object is **final** if its attributes cannot be modified after the object's creation. **_Definition._** An object is **immutable** if it is final and the objects that it references are immutable. in Java # final # The Java keyword final ensures that a variable cannot change value after its initialization.\n**_Example._** The following Java program does not compile. ```java final int a = 2; a = 3; ``` **_Warning._** This meaning of the keyword `final` is different from that we already saw in the section on [encapsulation](http://localhost:41071/docs/objects/sections/encapsulation/#final). When the variable is an instance attribute, this also forces the attributes to be explicitly instantiated before the execution of the constructor terminates.\n**_Example._** The following Java program does not compile. ```java public class User { final int id; final String name; public User(int id){ this.id = id; } } ``` **_Example._** The following Java program compiles, and the instances of `User` are immutable (because strings in Java are themselves immutable). ```java public class User { final int id; final String name; public User(int id){ this.id = id; this.name = name; } } ``` **_Note._** Alternatively, a `final` instance attribute can be instantiated immediately after it is declared (because this instruction is executed before the constructor). For instance, the following program compiles. ```java public class User { public final int id; public final String name = \"Alice\"; public User(int id){ this.id = id; } } ``` **_In practice._** Your IDE is likely to create `final` (and `private`) instance attributes by default. final vs immutable # **_Warning._** The `final` keyword may not be sufficient to enforce immutability (at least as it is defined above), in particular when a `final` attribute refers to a mutable object. **_Example._** Instances of the class `User` below are final, but not immutable, because instances of `Address` are not immutable. ```java public class User { final int id; final Address address; public User(int id, Address address){ this.id = id; this.address = address; } } public class Address { int streetNumber; String street; int zipCode; public Address(int streetNumber, String street, int zipCode){ this.streetNumber = streetNumber; this.street = street; this.zipCode = zipCode; } } ``` For instance, the following code compiles. ```java Address myAddress = new Address(14, \"via Goethe\", 39100); User myUser = new User(1, myAddress); myAddress.streetNumber = 12; ``` Final and immutable types # We already encountered several types of Java object and quasi-objects that are:\nfinal: records, sets (resp. lists, maps) that are declared with Set.of() (resp. List.of(), Map.of()), immutable: strings, boxed types (like Integer or Boolean). Record # A record is final.\n**_Examples._** Because strings are immutable, the following records are immutable: ```java record User(int id, String name){}; ``` However, the following records are only final (unless instance of `Address` are immutable): ```java record User(int id, String name, Address address){}; ``` Set, List, Map # If a set (resp. list, map) is created with Set.of() (resp. List.of(), Map.of()), then its content is final.\n**_Example._** The following Java program throws an `UnsupportedOperation` exception. ```java Set mySet = Set.of(2, 3); mySet.add(5); ``` However, if the set (resp. list, map) contains references, then the objects that are referred to may be mutable.\n**_Example._** The following program compiles (assuming that the attribute `streetNumber` of the class `Address` does not have the `final` keyword). ```java Address myAddress = new Address(14, \"via Goethe\", 39100); Set mySet = Set.of(myAddress); myAddress.streetNumber = 12; ``` By design, most other implementations of List, Set and Map are not final (this is expected, for performance reasons).\nHowever, in some scenarios, a program may create a (small) list (resp. set, map) that is not meant to be modified. For instance, the list of all files in a folder. In this case, the list (resp. set, map) can be made final. A common way to achieve this is the class ImmutableList (resp. ImmutableSet, ImmutableMap) of the Guava library.\nTo use Guava in a Maven project, declare this dependency:\n\u0026lt;dependencies\u0026gt; ... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.guava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;guava\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;33.1.0-jre\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; ... \u0026lt;/dependencies\u0026gt; or in a Gradle project:\nimplementation group: \u0026#39;com.google.guava\u0026#39;, name: \u0026#39;guava\u0026#39;, version: \u0026#39;33.1.0-jre\u0026#39; String # Java\u0026rsquo;s strings are immutable.\nHowever, the class StringBuilder implements a mutable string. It provides instance methods like append, insert, delete (a substring), etc.\nBoxed types # Java\u0026rsquo;s boxed types (like Integer or Boolean) are immutable.\nHowever, each boxed types has a mutable \u0026ldquo;atomic\u0026rdquo; counterpart, e.g. AtomicInteger for Integer and AtomicBoolean for Boolean.\nThe main purpose of these classes is to offer build-in thread safety for common sequences of operations. For instance, AtomicInteger provides a method equivalent to i++, but thread-safe (note that i++ is a shortcut for three operations: read the value, increment it and write it back).\nExercise What does the following program output? ```java Boolean b = true; // Create an atomic boolean with value true AtomicBoolean ab = new AtomicBoolean(true); List booleans = new LinkedList\u003c\u003e(); List aBooleans = new LinkedList\u003c\u003e(); booleans.add(b); aBooleans.add(ab); b = false; // Set the value of the atomic boolean to false ab.set(false); booleans.add(b); aBooleans.add(ab); System.out.println(booleans); System.out.println(aBooleans); ``` Solution ``` [true, false] [false, false] ``` "},{"id":108,"href":"/docs/objects/sections/quiz/","title":"Quiz","section":"Objects and classes","content":" Quiz # To answer the quiz (and check your answers), click here or scan this code:\nBoxed type # public class City { int population; public City (int population){ this.population = population; } } int myInteger = 1; Integer myBoxedInteger = 1; Integer myBoxedCopy = myInteger; City myCity = new City(5000); myMethod(myInteger, myBoxedInteger, myBoxedCopy, myCity); System.out.println( myInteger + \u0026#34;, \u0026#34;+ myBoxedInteger + \u0026#34;, \u0026#34;+ myBoxedCopy + \u0026#34;,\u0026#34; + myCity.population); void myMethod(int integer, Integer boxedInteger, Integer boxedCopy, City city) { integer += 1; boxedInteger += 1; boxedCopy += 1; city.population += 1; } This Java program outputs:\n1, 1, 1, 5000 1, 1, 1, 5001 1, 2, 1, 5000 1, 2, 1, 5001 1, 2, 2, 5000 1, 2, 2, 5001 2, 2, 2, 5000 2, 2, 2, 5001 I do not know the answer Objects and references # ```java public class City { String name; Country country; public City(String name, Country country) { this.name = name; this.country = country; } } ``` ```java public class Country { String name; City capital; public Country(String name, City capital) { this.name = name; this.capital = capital; } } ``` Country italy = new Country(\u0026#34;Italy\u0026#34;, null); City florence = new City(\u0026#34;Florence\u0026#34;, italy); City rome = new City(\u0026#34;Rome\u0026#34;, italy); italy.capital = rome; System.out.print(italy.capital.name + \u0026#34;, \u0026#34;); System.out.print(florence.country.capital.name + \u0026#34;, \u0026#34;); System.out.print(rome.country.capital.name + \u0026#34;, \u0026#34;); System.out.print(rome.country.capital.country.capital.name); This Java program:\ndoes not terminate outputs null, null, null, null outputs null, null, Rome, null outputs null, null, Rome, Rome outputs Rome, null, null, null outputs Rome, null, Rome, null outputs Rome, null, Rome, Rome outputs Rome, Rome, Rome, Rome I do not know the answer Copy constructor # ```java public class City { String name; Country country; public City(String name, Country country) { this.name = name; this.country = country; } public City (City original) { this.name = original.name; this.country = original.country; } } ``` ```java public class Country { String name; City capital; public Country(String name, City capital) { this.name = name; this.capital = capital; } public Country(Country original){ this.name = original.name; this.capital = new City(original.capital); } } ``` Country italy = new Country(\u0026#34;Italy\u0026#34;, null); City rome = new City(\u0026#34;Rome\u0026#34;, italy); italy.capital = rome; Country littleItaly = new Country(italy); littleItaly.name = \u0026#34;littleItaly\u0026#34;; littleItaly.capital.name = \u0026#34;littleRome\u0026#34;; System.out.print(littleItaly.capital.name+ \u0026#34;, \u0026#34;); System.out.print(littleItaly.capital.country.name+ \u0026#34;, \u0026#34;); System.out.print(littleItaly.capital.country.capital.name); This Java program:\ndoes not terminate outputs Rome, Italy, Rome outputs Rome, littleItaly, Rome outputs littleRome, Italy, Rome outputs littleRome, littleItaly, Rome outputs littleRome, littleItaly, littleRome I do not know the answer toString # ```java public class City { String name; Country country; public City(String name, Country country) { this.name = name; this.country = country; } @Override public String toString() { return \"City{\"+ \"name=\" + name + \", \"+ \"country=\" + country + \"}\"; } } ``` ```java public class Country { String name; City capital; public Country(String name, City capital) { this.name = name; this.capital = capital; } @Override public String toString() { return \"Country{\"+ \"name=\" + name + \", \"+ \"capital=\" + capital + \"}\"; } } ``` In this program, the method City.toString():\ncan output the empty string always outputs the empty string never outputs the empty string is recursive is not recursive may not terminate always terminates never terminates Static attribute # public class MyClass { static int value; boolean flag; public MyClass(int value, boolean flag){ this.value = value; this.flag = flag; } void print(){ System.out.print(\u0026#34;[\u0026#34;+value+\u0026#34; \u0026#34;+flag+\u0026#34;]\u0026#34;); } void incrementValue(){ value++; } void setFlag(boolean flag){ this.flag = flag; } } MyClass o1 = new MyClass(2, true); MyClass o2 = new MyClass(3, false); o1.print(); myMethod(o1); o1.print(); void myMethod(MyClass object) { object.setFlag(false); object.incrementValue(); object.print(); } This (strange) Java program outputs:\n[2 true][3 false ][3 false] [3 true][4 false ][4 false] [2 true][3 false ][2 true] [3 true][4 false ][3 true] [2 false][3 false ][3 false] [3 false][4 false ][4 false] [2 false][3 false ][2 true] [3 false][4 false ][3 true] I do not know the answer. "}]