<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Generic programming on Programming project 2024-25</title>
    <link>https://unibz-pp-24-25.github.io/docs/generics/</link>
    <description>Recent content in Generic programming on Programming project 2024-25</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://unibz-pp-24-25.github.io/docs/generics/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Type checking</title>
      <link>https://unibz-pp-24-25.github.io/docs/generics/sections/type_checking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-24-25.github.io/docs/generics/sections/type_checking/</guid>
      <description>&lt;h1 id=&#34;type-checking&#34;&gt;&#xA;  Type checking&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#type-checking&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;statically-vs-dynamically-typed-languages&#34;&gt;&#xA;  Statically vs dynamically typed languages&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#statically-vs-dynamically-typed-languages&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;blockquote class=&#34;book-hint warning&#34;&gt;&#xA;&lt;p&gt;A compiled programming language is said to be &lt;strong&gt;statically typed&lt;/strong&gt; if (most) type checks are performed during the compilation of a program, rather than during its execution.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;Such languages include , C/C++, C#, Go, Java, Kotlin, Typescript, Rust, etc., as well as functional (or functional-like) languages like Haskell or Scala.&lt;/p&gt;&#xA;&lt;blockquote class=&#34;book-hint info&#34;&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Example.&lt;/em&gt;&lt;/strong&gt;&#xA;The following Java program does not &lt;em&gt;compile&lt;/em&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Generics</title>
      <link>https://unibz-pp-24-25.github.io/docs/generics/sections/generics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-24-25.github.io/docs/generics/sections/generics/</guid>
      <description>&lt;h1 id=&#34;generics&#34;&gt;&#xA;  Generics&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#generics&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;blockquote class=&#34;book-hint warning&#34;&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Terminology.&lt;/em&gt;&lt;/strong&gt; The term &lt;strong&gt;generics&lt;/strong&gt; usually refers to &lt;a href=&#34;#genericMethod&#34;&gt;generic methods&lt;/a&gt; and &lt;a href=&#34;#genericType&#34;&gt;generic types&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;type-variable&#34;&gt;&#xA;  Type variable&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#type-variable&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;blockquote class=&#34;book-hint warning&#34;&gt;&#xA;&lt;p&gt;A &lt;strong&gt;type variable&lt;/strong&gt; is a variable ranging over types.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;For instance, in the chapter dedicated to &lt;a href=&#34;https://unibz-pp-24-25.github.io/docs/stream/sections/pipeline/&#34;&gt;streams&lt;/a&gt;, we repeatedly used the variable $T$ to refer to the type of the elements of a stream.&lt;/p&gt;&#xA;&lt;h2 id=&#34;genericMethod&#34;&gt;&#xA;  Generic method&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#genericMethod&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;blockquote class=&#34;book-hint info&#34;&gt;&#xA;&lt;h3 id=&#34;example&#34;&gt;&#xA;  Example&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#example&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;Consider the following interface &lt;code&gt;Unit&lt;/code&gt; and its two implementations &lt;code&gt;Butterfly&lt;/code&gt; and &lt;code&gt;Unicorn&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Subtype</title>
      <link>https://unibz-pp-24-25.github.io/docs/generics/sections/subtype/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-24-25.github.io/docs/generics/sections/subtype/</guid>
      <description>&lt;h1 id=&#34;subtype&#34;&gt;&#xA;  Subtype&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#subtype&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;As we saw in the previous sections, the purpose of generic programming is to write abstract code while enforcing type constraints.&#xA;As a result, when we write a program that &lt;em&gt;uses&lt;/em&gt; a generic type (e.g. a native Java &lt;code&gt;Collection&lt;/code&gt;),&#xA;we need to make sure that our code complies with these type constraints.&lt;/p&gt;&#xA;&lt;p&gt;In some situations, this requires &lt;em&gt;reasoning&lt;/em&gt; about types and their hierarchy (notably for programs that use &lt;a href=&#34;https://unibz-pp-24-25.github.io/docs/lambda/sections/callback/&#34;&gt;callback methods&lt;/a&gt;).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Variance</title>
      <link>https://unibz-pp-24-25.github.io/docs/generics/sections/variance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-24-25.github.io/docs/generics/sections/variance/</guid>
      <description>&lt;h1 id=&#34;variance&#34;&gt;&#xA;  Variance&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#variance&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;subtype&#34;&gt;&#xA;  Subtype&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#subtype&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;blockquote class=&#34;book-hint warning&#34;&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Notation.&lt;/em&gt;&lt;/strong&gt;&#xA;If $A$ and $B$ are types, we will use $A \sqsubseteq B$ to denote the fact that $A$ is a &lt;a href=&#34;https://unibz-pp-24-25.github.io/docs/generics/sections/subtype/#subtype&#34;&gt;subtype&lt;/a&gt; of $B$.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;subtype-and-substitution&#34;&gt;&#xA;  Subtype and substitution&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#subtype-and-substitution&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;blockquote class=&#34;book-hint warning&#34;&gt;&#xA;&lt;p&gt;The &lt;a href=&#34;https://en.wikipedia.org/wiki/Liskov_substitution_principle&#34;&gt;Liskov substitution principle&lt;/a&gt; intuitively states that If $A \sqsubseteq B$, then it should be possible to replace $B$ by $A$ in a program, without affecting the correctness of type checks.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote class=&#34;book-hint info&#34;&gt;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Examples.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;If &lt;code&gt;Integer&lt;/code&gt; $\sqsubseteq$ &lt;code&gt;Number&lt;/code&gt;, then a method that takes a &lt;code&gt;Number&lt;/code&gt; as input should also accept an &lt;code&gt;Integer&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;If &lt;code&gt;Butterfly&lt;/code&gt; $\sqsubseteq$ &lt;code&gt;Unit&lt;/code&gt;, then a method that takes a &lt;code&gt;Unit&lt;/code&gt; as input should also accept a &lt;code&gt;Butterfly&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;type-parameters-and-subtyping&#34;&gt;&#xA;  Type parameters and subtyping&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#type-parameters-and-subtyping&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;A natural question is whether subtyping between &lt;a href=&#34;https://unibz-pp-24-25.github.io/docs/generics/sections/generics/#genericType&#34;&gt;parameterized types&lt;/a&gt; should be determined by subtyping between their parameters.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Type erasure</title>
      <link>https://unibz-pp-24-25.github.io/docs/generics/sections/erasure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-24-25.github.io/docs/generics/sections/erasure/</guid>
      <description>&lt;h1 id=&#34;type-erasure-in-java&#34;&gt;&#xA;  Type erasure in Java&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#type-erasure-in-java&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;blockquote class=&#34;book-hint warning&#34;&gt;&#xA;&lt;p&gt;Java compilers rely on an approach called &lt;strong&gt;&lt;em&gt;type erasure&lt;/em&gt;&lt;/strong&gt; to compile:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;type parameters (e.g. &lt;code&gt;Box&amp;lt;Integer&amp;gt;&lt;/code&gt;),&lt;/li&gt;&#xA;&lt;li&gt;type variables (e.g. &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;), and&lt;/li&gt;&#xA;&lt;li&gt;question marks (e.g. &lt;code&gt;Box&amp;lt;? extends Number&amp;gt;&lt;/code&gt;).&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;More often than not, when a Java program does not compile, we can understand why without understanding the compilation procedure.&#xA;However, for generics, some basic understanding of type erasure can help.&lt;/p&gt;&#xA;&lt;h2 id=&#34;procedure&#34;&gt;&#xA;  Procedure&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#procedure&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Intuitively, type erasure consists in producing a program equivalent to the initial one,&#xA;but free of generic or parameterized types (i.e. intuitively with no &amp;ldquo;diamond&amp;rdquo;).&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
