[{"id":0,"href":"/docs/multithreading/sections/concurrency/","title":"Concurrency","section":"Multithreading","content":" Concurrency # Core # A core is a basic processing unit.\nA Central Processing Unit (CPU) contains one or several cores (e.g. 4 or 8).\nA Graphical Processing Unit (GPU) can contain thousands of cores.\nParallelism vs concurrency # Terminology. We call time span of a (computational) tasks the time interval comprised between the task\u0026rsquo;s start and completion.\nThe time spans of two tasks may overlap.\nExample. While downloading a video, Alice may use git to commit changes to her repository. These two tasks overlap.\nDefinitions. Two overlapping tasks can be executed either:\non different cores: this is called parallelism, or on the same core, in an interleaved fashion: this is called concurrency. Example. Consider a core that executes (sequentially) a task $t_1$ that repeatedly reads data from a database (stored on a hard drive). The core is likely to remain unused while data is being fetched from the hard drive. Instead, while $t_1$ is fetching data, the same core could be used to perform computations for a task $t_2$.\nContext switch # Definition. A context switch is the operation that consists in storing the system\u0026rsquo;s state for a running task (so that it can be paused and resumed later on), and restoring a different, previously saved state.\n"},{"id":1,"href":"/docs/recursion/sections/linear/","title":"Linear recursion","section":"Recursion","content":" Linear recursion # Definition. A recursive method is linear recursive if it performs at most one recursive call each time it is executed.\nTerminology. The term unary recursion is sometimes used to refer to linear recursive algorithms (as opposed to n-ary recursion).\nHint. A linear recursive algorithm is often easy to transform into an iterative one (i.e. an algorithm that uses only loops).\nExample # Exercise Write in pseudocode a (linear) recursive algorithm for a method int occ(char[] A, char c) that:\ntakes as input a (non-null) array A of characters and a character c, and returns the number of occurrences of c in A. Possible solution int occ(char[] A, char c) { return occRec(A, c, 0) } int occRec(char[] A, char c, int i) { // Base case: the segment under consideration is empty if(i == A.length){ return 0 } // Inductive case. // Count the number of occurrences of c in the \u0026#34;suffix\u0026#34; segment A[i+1 .. A.length-1] int occInSuffix = occRec(A, c, i + 1) return A[i] == c ? // If the current character is c, then return this value + 1, occInSuffix + 1 : // otherwise return this value as it is. occInSuffix } Tail recursion # Motivation # Consider a (not necessarily recursive) method method1 that calls a method method2, for instance:\nmethod1() { ... method2() ... } The execution of method1 is interrupted when it calls method2.\nDuring this interruption, the call stack contains:\nmethod2 method1 \u0026lt;bottom of the stack\u0026gt; Variables that are local to the execution of a method are allocated on the so-called stack memory.\nIn this example, variables that are local to method1 remain in memory during the execution of method2 (because they may be needed when the execution of method1 resumes). However, if no instruction in method1 needs to be executed after the call to method2, then there is no need to maintain this information in memory.\nmethod1() { ... method2() } In other words, the call stack in this case could be safely be reduced to:\nmethod2 \u0026lt;bottom of the stack\u0026gt; This optimization technique is known as tail-call elimination. Some compilers apply it (but most Java compilers do not).\nDuring the execution of a recursive algorithm, the size of the call stack may become important, therefore also the amount of stack memory required. Therefore identifying calls that may be safely be removed from the stack can significantly reduce memory consumption.\nDefinition # A linear recursive method is tail recursive if no instruction in this method can be executed after a recursive call.\nA tail recursive algorithm can easily be transformed into an iterative one. This transformation can be viewed as a \u0026ldquo;manual\u0026rdquo; form of tail-call elimination.\nExercise The algorithm above for the method int occ(char[] A, char c) is linear recursive, but not tail-recursive.\nRewrite it into a tail-recursive algorithm. Then convert it into an iterative algorithm.\nPossible solution Tail recursive algorithm:\nint occ(char[] A, char c) { return occRec(A, c, 0, 0) } int occRec(char[] A, char c, int i, int occurences) { // Base case: the segment under consideration is empty if(i == A.length){ return 0; } // Inductive case. // If the current character is c, then increment the number of occurrences. if (A[i] == c) { occurrences++; } // Recursive call return occRec(A, c, i + 1, occurrences) } Iterative algorithm:\nint occ(char[] A, char c) { int occurrences = 0 for (int i = 0; i \u0026lt; A.length; i++) { if (A[i] == c) { occurrences++ } } return occurrences } A common strategy to convert a linear recursive method into a tail-recursive one consists in using additional arguments (like the argument occurrences in the above example). These extra arguments are sometimes called accumulators.\nUsage # Linear recursive implementations are not very frequent, because most of them can be easily converted into iterative ones, as illustrated above. Besides, as we explained above, the iterative solution is often more efficient (at least memory-wise) for large inputs.\nHowever, some problems can be easier to solve in a linear recursive form (e.g. as a first attempt). This may also produce code that is easier to read and/or debug.\nIn particular, it may be the case when manipulating linked lists.\nLinked list # Definition. A linked list is a set of objects organized in a sequence, such that each object (except for the last one) points to its successor.\nEquivalently, a linked list is a unary tree (and conversely), i.e. a tree where each node has exactly one (possibly null) child.\nFor instance:\nTerminology.\nthe first object in a linked list is often called the head of the list, and the rest of the list (i.e. the sublist with the second object as head) is often called the tail of the list. Example # Exercise Consider linked lists that consist of instances of the following class:\nWrite (in pseudocode) a linear recursive algorithm Node removeDuplicates(Node head) that:\ntakes as input the head of a list with nodes sorted according to their label (in alphabetical order), returns the head of a list with the same labels, in alphabetical order, but where each label appears exactly once. For instance, for the following input list:\nthe algorithm should output a list with labels:\nPossible solution Node removeDuplicates(Node head) { // Base case: empty list. if(head == null) { return null } // Inductive case. // Remove all duplicate in the tail. Node tailHead = removeDuplicates(head.next) // Compare the head with the (possibly new) head of the tail. if (tailHead != null \u0026amp;\u0026amp; head.label == tailHead.label) { // If they have the same label, then return the tail. return tailHead } // Otherwise add the head to the returned list. head.next = tailHead return head } "},{"id":2,"href":"/docs/objects/sections/objects/","title":"Objects","section":"Objects and classes","content":" Objects # An object groups data in a meaningful way.\nA simple example: JSON objects # Here is a JSON object (in Javascript syntax) that describes the city of Florence:\n{ name: \u0026#34;Florence\u0026#34;, zipcode: 50100 } A JSON object may contain other objects, as well as arrays (of values, objects or arrays). For instance:\n{ name: \u0026#34;Alice\u0026#34;, age: 26, birthPlace: { name: \u0026#34;Florence\u0026#34;, zipcode: 50100 }, jobs: [ { employer: \u0026#34;Kolping\u0026#34;, start: 2021, end: 2022 }, { employer : \u0026#34;Eurac\u0026#34;, start: 2023 } ] } In JSON:\nan element can be either: a scalar (e.g. an integer), or an array of elements, or an object, an object is a finite set of key-value pairs, where keys are distinct, and each value is an element. Besides, a JSON element must have finite depth.\nEquivalently, a JSON object can be viewed as a function (with finite domain) that maps keys to JSON elements.\nObjects and programming languages # JSON objects do not exactly correspond to the objects that can be created in Java (and many other programming languages). We highlight here two important differences.\nTypes # Exercise Find a JSON object that satisfies the above description but cannot be represented as an object in a (strongly) typed language such as Java, C/C++, C#, etc.\nPossible solution { key: [1, \u0026#34;a\u0026#34;]; } In a typed language (like Java), the elements of an array must be of the same type.\nThis is not required in Javascript, Python, etc.\nReferences # A Java (or Python, C#, etc.) object does not contain objects or arrays, but references to objects or arrays. For instance, the equivalent in Java of the above object may be pictured as follows (abusing notation):\n_1: { name: _2, age: 26, birthPlace: _3, jobs: _4, } _2: [\u0026#39;A\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;e\u0026#39;] _3: { name: _5, zipcode: 50100 } _4: [ _6, _7 ] _5: [\u0026#39;F\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;e\u0026#39;] _6: { employer: _8, start: 2021, end: 2022 } _7: { employer: _9, start: 2023 } _8: [\u0026#39;K\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;g\u0026#39;] _9: [\u0026#39;E\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;] Each object or array has an ID (e.g. _1 in this example), which can be used to refer to it (you can think of this ID as an address in memory).\nAs a consequence, some objects can be created in Java that have no (finite) representation in JSON.\nExercise Find one of these objects.\nPossible solution _1: { name: _2, friends: _3 } _2: [\u0026#39;A\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;e\u0026#39;] _3: [ _4, _7 ] _4: { name: _5, friends: _6 } _5: [\u0026#39;B\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;b\u0026#39;] _6: [ _1, _8 ] If we try to represent this object in JSON, we get (assuming that we start with Alice):\n{ name: \u0026#34;Alice\u0026#34;, friends: [ { name: \u0026#34;Bob\u0026#34;, friends: [ { name: \u0026#34;Alice\u0026#34;, friends: [ ... ]}]}]} Cyclic references (like in this exercise) naturally occur in object-oriented code. Identifying them may be essential to debug a program that does not terminate or runs out of memory (stack overflow, \u0026hellip;).\n"},{"id":3,"href":"/docs/project/sections/free_project/","title":"Option 1: free project","section":"Project","content":" Option 1: free project # The first possible type of group projects is for students to develop a Java application of their choice.\nThis application is only a prototype, so it does not need a comprehensive list of features or functionalities.\nThe evaluation of the project will be mostly based on its backend (rather than the frontend). This means that the application:\ndoes not need a graphical user interface (but may have one), should perform non-trivial backend task(s) (e.g. writing and/or reading to/from files is not sufficient). Guidelines # Motivation # A good projects is driven by an idea.\nFeel free to design your application so that it matches your own interests. For instance:\nrelate it to a hobby (music, cinema, fashion, sport, games, social media, astronomy, etc.), use the project as an opportunity to explore a topic that you are curious about (natural language processing, computer vision, recommender systems, robotics, etc.), develop a functionality that one of your favorite applications is missing. Do not hesitate to be ambitious at first. You can restrict the scope of your project (to certain features or components) later on.\nSpecification # A frequent source of failure for this course is students focusing on tools (e.g. following tutorials) without having a precise objective. The short deadline (June 2024) does not give you this flexibility. Besides, without a precise objective, the amount of libraries that are available to you (especially in Java) can be overwhelming.\nSo we recommend you to clarify what your application should do, before thinking about how you could implement it. In other words, specify which problem(s) (i.e. input and expected output) your program and/or components should solve. Then only think about algorithms, libraries, tools and/or tutorials that can help you solve these problems.\nIn order to determine whether your specification is precise enough, you may check whether it leaves some doubt as to whether an output is correct or not.\nUser interface # Developing a Graphical User Interface (GUI) requires familiarity with a graphical framework. Learning the details of such a framework (terminology, syntax, setup, etc.) can be an important time investment, and this knowledge may not transfer to other graphical frameworks. In other words, developing a GUI may not require lot of thinking, but a lot of reading (and web browsing).\nBeware also that GUIs technologies are still rapidly evolving, and that recent innovation has largely been driven by web development. So learning a graphical framework for Java may not be a strategic investment of your time (compared to learning a Javascript framework like React or Angular). Note that even desktop and mobile applications are increasingly relying on web technologies for their GUIs (thanks to frameworks like Electron or React Native).\nThis is why we recommend you to think carefully before committing to a Java GUI, and to keep it minimal if you do. Note also that we will not evaluate your project based on aesthetic criteria.\nSo in order to design your interface, you may follow the following guidelines:\nAsk yourself whether your application really needs a GUI. A command-line interface (CLI) may be sufficient, because: your program takes files as input and produces files as output, or your program is (primarily) meant to be used by other programs (rather than human beings), or your program is meant to be used by other developers, or external programs with GUIs (such as IDEs) can easily call your application, or you leave the GUI for future work (again, your application is just a prototype), etc. If you really need a GUI, then: decouple frontend and backend (whenever possible), so that the backend could be used with another frontend, and conversely. Example. Many applications accessible via GUI have a natural decoupling of frontend and backend. For instance, consider an application that allows booking hotel rooms. The backend takes as input some data (e.g. number or guests, duration, etc.), and outputs data as well (available rooms, prices, etc.). These input and output are independent of the aspect or structure of the GUI (windows, menus, buttons, fields, etc.).\nExample. Even for some games, frontend and backend can easily be decoupled. Consider for instance a program that plays chess against a human opponent. The backend:\nkeeps track of the current state of the board, takes as input either a move from the white player, or a request to play as the black player, outputs the next state of the board. These input and output do not depend on a specific GUI (they can for instance be encoded using algebraic notation). So the backend can be implemented without any reference to graphical elements or controller inputs (mouse clicks, etc.).\ndevelop the backend first (and write unit tests for it),\ndevelop the frontend afterwards (if you have time for it).\nIf you really need a GUI, then try to keep it minimal. In particular, restrict the input to what is essential for your application. The more freedom the user is given, the more likely he/she is to input a sequence of actions that your program cannot handle. Illustrations # Here are some examples of (past and imaginary) possible projects:\na program that detects texts generated by a large language model, a program that takes as input a dataset of Tweets and identifies communities and/or influencers based on the network formed by re-tweets, a program that retrieves news articles about an input topic (using web APIs), and analyses their polarity (via sentiment analysis) together with their provenance (news outlet, country, etc.), a (toy) recommender system, a program that generates (solvable) sudoku grids with different sizes and/or level of difficulty, a game to help people improve their typing speed, a web crawler that retrieves sport-related statistics from various websites and exposes them via a web API, a classroom reservation system for the Unibz that can computes a default schedule for a whole semester, satisfying a set of constraints (room capacity, etc.) and/or preferences (minimize days of presence per week of a same group, etc.), a flashcard app that incorporates answers produced by a chatbot, an (Obsidian-like) note management application, a program to organize and manage coding contests (similar to this one), a password manager (with encryption), for instance similar to pass, where password update and synchronization are performed via git, a program that analyzes the commit and/or branching history of a git repository (e.g. contributions of the different users, frequency of commits, percentage of preserved code, etc.). "},{"id":4,"href":"/docs/regex/sections/pattern/","title":"Pattern matching","section":"Regular expressions","content":" Pattern matching # Two of the main uses of regexes are:\nstring validation, i.e. check whether a string satisfies certain constraints. For instance: has at least one digit and one special character, is a valid address, etc. string search, i.e. identify occurrences of a pattern in a line or in a file. This can be useful for: replacing strings in a file or a folder (e.g. within a codebase), splitting a sentence into (natural language) words, splitting a program into meaningful substrings, e.g. split the instruction int a=5; into int, a, =, 5 and ;, filtering (e.g. with the grep command) of modifying (e.g. with the sed command) lines in a file, etc. In both scenarios, a regex is viewed as a pattern that should be matched against a string.\nSegment # To make the notion of pattern matching more precise, we will represent a word $w$ as an array of characters, and a segment of $w$ as a (possibly empty) subarray of this array.\nNotation. If $w$ is a word, we use $w[i .. j)$ for the subsegment of $w$ that starts at index $i$ included, and ends at index $j$ excluded.\nExample. Let $w$ = abca. Then:\n$w[0 .. 1)$ is a segment of $w$ with length 1 and word a, $w[3 .. 4)$ is another segment of $w$ with length 1 and word a $w[0 .. 3)$ is a segment of $w$ with length 3 and word abc $w[0 .. 0)$ is a segment of $w$ with length 0 and word $\\varepsilon$ $w[1 .. 1)$ is another segment of $w$ with length 0 and word $\\varepsilon$ Match # We can now define what a match is:\nDefinition. Let $w$ be a word (viewed as an array), and let $e$ be a regex that describes the language $L$.\nA match for $e$ in $w$ is a (possibly empty) segment of $w$ whose word belongs to $L$.\nExample. Let $e$ be the regex ab*, and let $w$ be the word aba.\nThere are 3 matches for $e$ in $w$:\n$w[0 .. 1)$ with word a, $w[0 .. 2)$ with word ab, $w[2 .. 3)$ with word a Warning. Several matches may carry the same word (e.g. the first and third matches in the example above).\nWarning. Some matches may overlap (e.g. the first and second matches in the example above).\nExercise Consider the regex $e$ = a* and the word $w$ = aa.\nHow many matches are there for $e$ in $w$?\nSolution There are 6 matches for the regex a* in the word aa:\n$w[0 .. 0)$: $\\varepsilon$ $w[0 .. 1)$: a $w[0 .. 2)$: aa $w[1 .. 1)$: $\\varepsilon$ $w[1 .. 2)$: a $w[2 .. 2)$: $\\varepsilon$ Best first match # In practice, (most) regex engines do not identify all matches for a regex in a word. Instead, they rely on the notion of best first match (explained below). Reasons include:\nperformance, avoiding overlapping matches (e.g. when performing a global \u0026ldquo;search and replace\u0026rdquo;). Let $e$ be a regex, let $w$ be a word, and let $m_1$ and $m_2$ be two matches for $e$ in $w$.\n$m_1$ is preferred to $m_2$ if:\n$m_1$ starts before $m_2$: for instance $w[1 .. 4)$ is preferred to $w[3 .. 8)$, or they start at the same index and the regex engine favors $m_1$ over $m_2$. Preference is a total order over the matches for for $e$ in $w$, meaning that if there is a match, then there can be at most one best first match.\nNote. When $m_1$ and $m_2$ start at the same index (second case above), whether $m_1$ is favored over $m_2$ can vary in subtle ways from one regex engine to the other. These preferences are usually explained in algorithmic terms (and half-informally).\nFor a reasonably detailed tutorial about the behavior(s) of regex search engine, we refer to this website. For Java, the Oracle tutorial on regexes can also be a good entry point (although less precise that the previous reference).\nIn this section, we only introduce basic behaviors of regex engines.\nLeft-to-right # Commutative operations are evaluated from left-to-right.\nExample. Consider the word $w$ = ab.\nthe best first match for the regex ab|a in $w$ is $w[0 .. 2) (with word ab) the best first match for the regex a|ab in $w$ is $w[0 .. 1) (with word a) Exception. In this example, A POSIX-compliant regex engine would produce $w[0 .. 2) (with word ab) as best first match for both expressions.\nWarning. As illustrated with the above example, two regexes that describe the same language may have different best first matches (in the same word).\nGreedyness # The * operator is evaluated (by default) in a greedy way. This means that the engine tries to matches as many characters as possible for this operator. More precisely, when encountering a subexpression of the form $e$*:\nthe engine first considers the longest possible match for $e$*, if this match does not result in a match for the whole expression, then the engine backtracks by one character (i.e. reduces the length of the match for $e$* by one), and tries again to find a match for the whole expression, if this fails again, then the engine backtracks again by one character, etc. Examples.\nThe best first match for the regex a* in aa is the whole word. The best first match for the regex a* in aab is $[0 ..2)$ (with word aa). The best first match for the regex a* in aabaa is $[0 ..2)$ (with word aa). The best first match for the regex (a|b)*b in abab is the whole word. In this case, the engine first tries to match (a|b)* against the whole word, this does not result in a match for the whole regex, because the trailing b in the regex is not matched, so the engine backtracks, and matches (a|b)* against $[0 .. 3)$ (with word aba), this results in a match for the whole expression. Warning. The interaction of left-to-right evaluation and greedy matching can be hard to predict. This is why we highly recommend writing and debugging regexes with a validation engine, such as regex101.\nWarning. Nested * operators can be costly, due to a combinatorial explosion of the number of attempts to find a match. This is sometimes referred to as catastrophic backtracking.\nSuccessive best first matches # Most regex engines can return best first matches in an iterative way. Intuitively, the engine \u0026ldquo;consumes\u0026rdquo; the best first match. Then the next match is the best first match in the remaining string, etc.\nMore precisely:\nDefinition. Let $e$ be regex and let $w$ be a word with lenght $n$.\nThen:\nthe first match $w[i_1 .. j_1)$ for $e$ in $w$ is the best first match (if any) for $e$ in $w$, the second match $w[i_2 .. j_2)$ for $e$ in $w$ is the best first match (if any) for $e$ in $w[j_1 .. n)$, the third match $w[i_3 .. j_3)$ for $e$ in $w$ is the best first match (if any) for $e$ in $w[j_2 .. n)$, etc. Example. Let $e$ be the regex ab*, and let $w$ be the word abac.\nThe best first match for $e$ in $w$ is $w[0 ..2)$, with word ab.\nThe second match is the best first match in the rest of $w$, i.e. in $w[2 .. 4)$. This match is $w[2 .. 3)$, with word a.\nThere is no third match.\nExercise In each of the cases below, find all successive best first matches for the regex $e$ in word $w$:\nregex $e$ word $w$ a aba a*b aba a* a a* aba (ab)* aba (ab)* abab Solution regex $e$ word $w$ matches a aba $[0 .. 1)$:a, $[2 .. 3)$:a a*b aba $[0 .. 2)$:ab a* a $[0 .. 1)$:a, $[1 .. 1)$: $\\varepsilon$ a* aba $[0 .. 1)$:a, $[1 .. 1)$: $\\varepsilon$, $[2 .. 3)$:a, $[3 .. 3)$: $\\varepsilon$ (ab)* aba $[0 .. 1)$:ab, $[2 .. 2)$: $\\varepsilon$, $[3 .. 3)$: $\\varepsilon$ (ab)* abab $[0 .. 3)$:abab, $[3 .. 3)$: $\\varepsilon$ Lazy closure # Some regex engines (notably the ones used by default in Java, Javascript, Python, etc.) support alternative ways to evaluate * operators.\nOne of them is lazy evaluation (also called reluctant). In this case, the star operator matches the shortest possible segment.\nExamples.\nregex $e$ word $w$ best first match with lazy evaluation of star operators a* aa $[0 .. 0)$:$\\varepsilon$ a*ac ac $[0 .. 2)$:ac a*ac aac $[0 .. 3)$:aac Note. In a same regular expression, it is possible to specify that some * operators must be evaluated in a lazy way, and others in a greedy way.\nExercise In each of the cases below, find all successive best first matches for the regex $e$ in word $w$, where * operators are evaluated in a lazy way.\nregex $e$ word $w$ ab* ab a*b aba a*ab* ab a* a a* aa b* aa Solution regex $e$ word $w$ lazy matches ab* ab $[0 .. 1)$:a a*b aba $[0 .. 2)$:ab a*ab* ab $[0 .. 1)$:a a* a $[0 .. 0)$:$\\varepsilon$, $[1 .. 1)$:$\\varepsilon$ a* aa $[0 .. 0)$:$\\varepsilon$, $[1 .. 1)$:$\\varepsilon$, $[2 .. 2)$:$\\varepsilon$ b* aa $[0 .. 0)$:$\\varepsilon$, $[1 .. 1)$:$\\varepsilon$, $[2 .. 2)$:$\\varepsilon$ Warning. Lazy * operators can be hard to predict.\n"},{"id":5,"href":"/docs/stream/sections/pipeline/","title":"Pipeline","section":"Streams in Java","content":" Pipeline # Stream computations are specified as a pipeline, which consists of:\na source (e.g. a collection or an I/O channel), a sequence of zero or more intermediate operations, each of which transforms a stream into another stream (e.g. filtering or modifying the stream\u0026rsquo;s elements), one terminal operation (e.g. collecting the elements of the transformed stream). Intermediate operations are generally specified via callback methods (the terminal operation may as well). More precisely, the Java interface Stream provides instance methods (like filter or map) that take a callback method as argument, and transform the stream accordingly.\nExample # Consider the following classes Unit, Butterfly, Caterpillar and Unicorn.\nThe pipeline below:\ncreates a stream out of a list of units, retains only butterflies, extracts the color of each butterfly, collects these colors as a set. List\u0026lt;Unit\u0026gt; units = getUnits(); Set\u0026lt;String\u0026gt; butterflyColors = units.stream() // create a stream .filter(u -\u0026gt; u instanceof Butterfly) // retain butterflies .map(b -\u0026gt; b.color) // map each butterfly to its color .collect(Collectors.toSet()); // collect the colors as a set Explanation # This pipeline can be decomposed as follows:\nSource # The instance method Collection.stream generates a stream out of a collection (e.g. out of a List or a Set):\nunits.stream() In this example, because units has type List\u0026lt;Unit\u0026gt;, the stream that is returned by units.stream() has type Stream\u0026lt;Unit\u0026gt;.\nIntermediate operations # Filter # .filter(u -\u0026gt; u instanceof Butterfly) The instance method Stream.filter retains certain elements of the stream.\nLet us assume that the stream has type Stream\u0026lt;$\\mathit{T}$\u0026gt; (for instance, in our example, $\\mathit{T}$ is Unit).\nThe method filter takes as argument a callback function of type\n$\\qquad \\mathit{T} \\to$ Boolean\n(equivalently, in Java\u0026rsquo;s terminology, the callback function must implement the native functional interface Predicate\u0026lt;$\\mathit{T}$\u0026gt;).\nIn this example, the callback function is\nu -\u0026gt; u instanceof Butterfly which has type\n$\\qquad$ Unit $\\to$ Boolean\nThe method filter returns a Stream\u0026lt;$\\mathit{T}$\u0026gt; (e.g. in this example a Stream\u0026lt;Unit\u0026gt;) that consists of the elements for which the callback method evaluates to true (in this case, it retains only butterflies).\nMap # .map(b -\u0026gt; b.color) The instance method Stream.map applies a function to each element of the stream.\nLet us assume that the stream has type Stream\u0026lt;$\\mathit{T}$\u0026gt; (for instance, in our example, $\\mathit{T}$ is Unit).\nThe method map takes as argument a callback function of type\n$\\qquad T \\to T'$\nwhere $T\u0026rsquo;$ can be any type (equivalently, in Java\u0026rsquo;s terminology, the callback function must implement the native functional interface Function\u0026lt;$T$,$T\u0026rsquo;$\u0026gt;, seen earlier).\nIn this example, the callback function is\nb -\u0026gt; b.color which has type\n$\\qquad$ Unit $\\to$ String\nLet us name this callback function $f$.\nThe method map returns a Stream\u0026lt;$\\mathit{T\u0026rsquo;}$\u0026gt; (e.g. in this example a Stream\u0026lt;String\u0026gt;) that consists of all objects $f(a)$ such that $a$ belongs to the original stream.\nTerminal operation # .collect(Collectors.toSet()); The instance method Stream.collect takes as argument a so-called Collector, which is in charge of collecting the elements of the stream into a Collection (e.g. List or Set), or a Map, or a string, etc.\nIn this example, we call the static method Collectors.toSet, which returns a collector that produces a set. Because the stream has type Stream\u0026lt;String\u0026gt;, the instruction .collect(Collectors.toSet()) returns a set with type Set\u0026lt;String\u0026gt;.\nReading a pipeline # Exercise What do the following methods compute?\nSet\u0026lt;Unit\u0026gt; method1(Set\u0026lt;Unit\u0026gt; set1, Set\u0026lt;Unit\u0026gt; set2) { return set1.stream() .filter(u -\u0026gt; set2.contains(u)) .collect(Collectors.toSet()); } Set\u0026lt;Unit\u0026gt; method2(Set\u0026lt;Unit\u0026gt; set1, Set\u0026lt;Unit\u0026gt; set2) { return set1.stream() .filter(set2::contains) .collect(Collectors.toSet()); } Solution Both methods compute the intersection of set1 and set2.\nExercise What do the methods method1 to method4 below compute?\nStream\u0026lt;Unit\u0026gt; method1(List\u0026lt;Unit\u0026gt; units) { return units.stream() .filter(u -\u0026gt; u.health \u0026gt; 0); } List\u0026lt;Unit\u0026gt; method2(Stream\u0026lt;Unit\u0026gt; stream) { return stream.map(u -\u0026gt; transform(u)) .toList(); // collects the stream into a list } Unit transform(Unit u) { if (u instanceof Caterpillar) { return new Butterfly(u.color, u.health); } return u; } List\u0026lt;Unit\u0026gt; method3(List\u0026lt;Unit\u0026gt; units) { return method2(method1(units)); } List\u0026lt;Unit\u0026gt; method4(List\u0026lt;Unit\u0026gt; units) { return units.stream() .filter(u -\u0026gt; u.health \u0026gt; 0) .map(u -\u0026gt; u instanceof Caterpillar ? new Butterfly(u.color, u.health) : u ) .toList(); } Solution method1: Input: A list of units. Output: a stream that contains the same units, but discarding units with no health. method2: Input: A stream of units. Output: A list that contains the same units, but where caterpillars become butterflies. method3: Input: A list of units. Output: A list that contains the same units, but discarding units with no health, and transforming caterpillars into butterflies. method4 is equivalent to method3. "},{"id":6,"href":"/docs/lambda/sections/pure/","title":"Pure function","section":"Callback methods and lambda expressions","content":" Pure function # Side effects # Definition. A method has side effects if it modifies resources (variable, object, array, etc.) that are accessible outside of its scope.\nDefinition # A pure function is a method that intuitively behaves like a mathematical function. More precisely:\nDefinition. A pure function is a method that:\nreturns a value, returns the same value if called twice with the same arguments, and has no side-effect. Example # Exercise The Java method createUsers below violates each of the three properties that define a pure function.\nCan you see why?\nHow would you rewrite it into a pure function?\nint[] ids = parseIds(); String[] names = parseNames(); User[] users = new User[ids.length]; createUsers(ids, names, users); void createUsers(int[] ids, String[] names, User[] users) { for(int i = 0; i \u0026lt; ids.length; i++){ users[i] = new User(ids[i], names[i]); } } Possible solution int[] ids = parseIds(); String[] names = parseNames(); User[] users = createUsers(ids, names); User[] createUsers(int[] ids, String[] names) { User[] users = new User[ids.length]; for(int i = 0; i \u0026lt; ids.length; i++){ users[i] = new User(ids[i], names[i]); } return users; } Benefits # Easier debugging # Because it has no side effect, a pure function may cause of a bug only if it returns an incorrect value. Because it only depend on its arguments, the behavior of a pure function is easier to predict. Readability # The behavior of a pure function can be fully documented by describing its signature (arguments and return value).\nEasier parallelization # Consider two pure functions $f$ and $g$. If the input of $f$ (resp. $g$) does not depend on the output of $g$ (resp. $f$), then they can be executed in any order (therefore also in parallel).\nExample. If $f$ and $g$ are pure functions, the two programs below (written in pseudocode) are equivalent:\nx = f(a) y = g(b) result = x + y y = g(b) x = f(a) result = x + y "},{"id":7,"href":"/docs/intro/sections/schedule/","title":"Schedule","section":"This course","content":" Schedule # The course consists of 60 hours of lectures and 30 hours of labs.\nLectures # By default, lectures are scheduled:\nMonday 13:30 - 15:30 Tuesday 08:30 - 10:30 Wednesday 08:30 - 10:30 All students attend the same lectures.\nLabs # By default, labs are scheduled:\nMonday 15:30 - 17:30 Wednesday 13:30 - 15:30 Students are split in two groups (to be determined) for the labs, with identical content. Students who collaborate on the same group project are expected to attend the same lab.\nMost labs will be dedicated to the assignments for this course. Two labs will be dedicated to a presentation and discussion of the advancement of the group projects.\nTimetable # Some weeks will see fewer lectures/labs, and schedules or room numbers may vary from one week to the other. So make sure to check the timetable.\n"},{"id":8,"href":"/docs/interfaces/sections/specification/","title":"Specification and programming interface","section":"Interfaces","content":" Specification and programming interface # Specification # The specification of a method usually consists of:\nthe computational problem that the method solves (if any), and (if needed,) a description of the format of the input and expected output, and (if applicable,) a description of the behavior of the program for invalid inputs (e.g. errors thrown by the method), and (if useful,) information about the implementation (e.g. if this may have an impact on performance for certain inputs). Example.\nboolean isSolvable(int[][] grid) Input: a 9 x 9 array of integers with numbers between 0 and 9 Output: true is this array represents a sudoku grid with a unique solution (where 0 stands for the absence of value) Errors: if the array\u0026rsquo;s size is not 9 x 9 if the array contains a number smaller that 0 or greater than 9 If a method has no return type or is not a pure function, then the specification may indicate the effect the method on its environment.\nThe specification of a command (for a program with a command line interface) is similar, but may include additional information about the syntax of the command (options, arguments, etc.)\nProgramming interface # In its simplest form, a programming interface is a set of method/command specifications.\n"},{"id":9,"href":"/docs/intro/","title":"This course","section":"Docs","content":" Structure and organization of the course # This chapter explains how the course is structured and provides a brief overview of its content.\n"},{"id":10,"href":"/docs/lambda/sections/anonymous/","title":"Anonymous method","section":"Callback methods and lambda expressions","content":" Anonymous method # An anonymous method is a method without a name.\nIllustration # The two following Java methods only differ by their name:\nint square(int x){ return x * x; } int toThePowerOfTwo(int x){ return x * x; } So in a sense, these two methods are the same method.\nAn anonymous method simply abstracts away from the name of the method. For instance, in Java, the two methods above could be described with the following lambda expression:\n(int x) -\u0026gt; { return x * x; } Or (with a more concise syntax):\nx -\u0026gt; x * x "},{"id":11,"href":"/docs/simplify/sections/break/","title":"Break statements and flags","section":"Simplifying code","content":" Break statements and flags # A method with multiple boolean flags can be complex to read and/or debug, in particular when combined with break and/or continue statements.\nThis can usually be avoided:\nusing return statements (possibly with auxiliary functions), and/or (in Java) using streams with anyMatch, allMatch or findFirst. Example # Exercise Rewrite the following Java method:\nwithout boolean flag and without break statement. /** * Returns true iff each of the input lists contains a number \u0026gt; 20 */ boolean check(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; lists) { boolean flag1 = true; boolean flag2 = false; for (List\u0026lt;Integer\u0026gt; list : lists) { for (Integer value : list) { if (value \u0026gt; 20) { flag2 = true; break; } } if (!flag2) { flag1 = false; break; } } return flag1; } Solution 1 With an auxiliary method:\nboolean check(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; lists) { for (List\u0026lt;Integer\u0026gt; list : lists) { if(!isValid(list)) { return false; } } return true; } private boolean isValid(List\u0026lt;Integer\u0026gt; values) { for (Integer value : values) { if(value \u0026gt; 20) { return true; } } return false; } Solution 2 boolean check(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; lists) { return lists.stream() .allMatch(l -\u0026gt; l.stream().anyMatch(v -\u0026gt; v \u0026gt; 20)); } "},{"id":12,"href":"/docs/objects/sections/classes/","title":"Class and instance","section":"Objects and classes","content":" Class and instance # A class can be viewed as a blueprint for a set of similar objects.\nFor instance, consider the two objects:\n{ name: \u0026#34;Florence\u0026#34;, zipCode: 50100, region: \u0026#34;Tuscany\u0026#34; } { name: \u0026#34;Rome\u0026#34;, zipCode: 00100, region: \u0026#34;Lazio\u0026#34; } Each of these objects describes a city, and they share the same keys (name, zipCode and region). A possible class for these two objects may enforce this structure, and it could be named City. An object that follows this blueprint is called an instance of this class.\nDeclaration # In a typed language (like Java), a class must specify not only the \u0026ldquo;keys\u0026rdquo; of its instances, but also their types. For instance, the class City could be declared as follows in Java:\npublic class City { String name; int zipCode; String region; ... } In Java, a class is often declared in a dedicated file. This file must have the same name as the class (e.g. City.java in this example).\nThe three variables (name, zipCode and region) are called attributes (or sometimes member variables).\nConstructor # A class also needs a special method called a constructor.\nThe constructor is in charge of creating a (fresh) instance of the class.\nNote. A class may have several constructors (with different signatures).\nWriting a constructor in Java # The constructor of a Java class must have the same name as the class.\nFor instance:\npublic class City { String name; int zipCode; String region; public City(String n, int z, String r){ name = n; zipCode = z; region = r; } ... } Note. In this example, the variable names n, z and r are not very explicit. However, using name, zipCode and region would be ambiguous (because these names are already used for the attributes of the class). In Java, we can use the prefix this. to refer to attribute names, thus eliminating the ambiguity.\nFor instance:\npublic class City { String name; int zipCode; String region; public City(String name, int zipCode, String region){ this.name = name; this.zipCode = zipcode; this.region = region; } ... } Calling a constructor in Java # A Java constructor is called with the keyword new. For instance:\nCity myCity = new City(\u0026#34;Florence\u0026#34;, 50100, \u0026#34;Tuscany\u0026#34;); City yourCity = new City(\u0026#34;Rome\u0026#34;, 00100, \u0026#34;Lazio\u0026#34;); Warning. In Java (as in Python, C#, etc.), the constructor does not return the instance itself, but a reference (sometimes called \u0026ldquo;pointer\u0026rdquo;) to this instance.\nNote. The object that is created in memory contains extra information, in particular a reference to its class. This allows type checking, casts, etc. (more on this later).\nAccessing an object in Java # The attributes of an object can be accessed like regular variables, using ., followed by the name of the attribute. For instance,\nCity thatCity = new City(\u0026#34;Siena\u0026#34;, 53100, \u0026#34;Lazio\u0026#34;); System.out.println(\u0026#34;Wrong region: \u0026#34; + thatCity.region); thatCity.region = \u0026#34;Tuscany\u0026#34;; System.out.println(\u0026#34;Better now: \u0026#34; + thatCity.region); will output\nWrong region: Lazio Better now: Tuscany Reference type vs primitive type # Recall that a Java constructor returns a reference to the object that it creates. So in the examples above, the value of each variable (myCity, yourCity and thatCity) is a reference, not the object itself.\nThis also holds for variable with an array type (like int[] myArray).\nThe types of these variables (e.g. City or int[]) are called reference types.\nSyntax. In Java, types that start with a capital letter (like City or Array\u0026lt;Integer\u0026gt;) are usually reference types.\nTypes that are not references types (like int or char) are called primitive types.\nIn Java, the value of a reference cannot be output (printed, displayed, etc.) by a program (as opposed to C/C++ for instance). But this value can be overwritten or compared to another.\nExercise What is the output of the following program?\nCity aCity = new City(\u0026#34;Matera\u0026#34;, 75100, \u0026#34;Basilicata\u0026#34;); City theSameCity = new City(\u0026#34;Matera\u0026#34;, 75100, \u0026#34;Basilicata\u0026#34;); System.out.println(aCity == theSameCity); System.out.println(aCity.zipCode == theSameCity.zipCode); Solution false true Exercise What is the output of the following program?\nCity anotherCity = new City(\u0026#34;Bologna\u0026#34;, 40100, \u0026#34;Emilia-Romagna\u0026#34;); City yetAnotherCity = new City(\u0026#34;Mantua\u0026#34;, 46100, \u0026#34;Emilia-Romagna\u0026#34;); yetAnotherCity.name = anotherCity.name; System.out.println(yetAnotherCity.name); anotherCity = yetAnotherCity; System.out.println(anotherCity.zipCode); System.out.println(anotherCity == yetAnotherCity); Solution Exercise 2.\n\u0026#34;Bologna\u0026#34; 46100 true Passing by value or by reference # Programming languages differ in the way arguments are passed to methods. Two common strategies are:\npassing by value: the method receives as input a copy of each argument, passing by reference: the method receives as input a reference to each argument (which allows modifying the initial argument). Consider for instance the following program (in pseudocode):\nint myInteger = 0 myMethod(myInteger) print(myInteger) void myMethod(int argument){ argument += 1 } If the argument is passed by value, then the program will print 0. If the argument is passed by reference, then the program will print 1. Java passes by value # In Java (and many other programming languages, like C, Python, Javascript, etc.), arguments are passed by value. So the above program translated in Java will print 0.\nWarning. Consider a method with a reference type argument. Because Java passes by value, this method will receive a copy of this argument. But this is a copy of the reference, not a copy of the object itself.\nExercise What does the following Java program print?\nint myInteger = 0; City myFirstCity = new City(\u0026#34;Florence\u0026#34;, 50100, \u0026#34;Tuscany\u0026#34;); City mySecondCity = new City(\u0026#34;Mantua\u0026#34;, 46100, \u0026#34;Emilia-Romagna\u0026#34;); myMethod(myInteger, myFirstCity, mySecondCity); System.out.println(myInteger); System.out.println(myFirstCity.zipCode); System.out.println(mySecondCity.zipCode); public void myMethod(int integer, City firstCity, City secondCity){ integer += 1; System.out.println(integer); firstCity.zipCode = 20590; System.out.println(firstCity.zipCode); secondCity = new City(\u0026#34;Rome\u0026#34;, 00100, \u0026#34;Lazio\u0026#34;); System.out.println(secondCity.zipCode); } Solution 1 20590 00100 0 20590 46100 "},{"id":13,"href":"/docs/unittests/sections/structured/","title":"Code units","section":"Unit tests","content":" Code units # A unit test is meant to test to a small unit of code. This is only possible if the program contains small units of code.\nTherefore unit testing is closely related to decomposing complex problems into smaller ones (and creating methods that solve these smaller problems).\nBenefits # Possible benefits of decomposing complex methods into smaller ones are:\nreadability, easier debugging, opportunities to factorize code (the same small methods can be called in several places), easier collaboration (two person modifying the same method in parallel is less likely if the method is small), Some good indicators that auxiliary methods may be helpful are:\nmultiple levels of nested blocks (\u0026ldquo;curly braces\u0026rdquo; in Java), a loop that contains a important amount of code. Exercise Simplify (and factorize) the following pseudocode using auxiliary methods:\nif(\u0026lt;condition1\u0026gt;){ while(\u0026lt;condition2\u0026gt;){ if(\u0026lt;condition3\u0026gt;){ \u0026lt;block1\u0026gt; } else { \u0026lt;block2\u0026gt; } \u0026lt;block3\u0026gt; } \u0026lt;block4\u0026gt; } else { if(\u0026lt;condition3\u0026gt;){ \u0026lt;block1\u0026gt; } else { \u0026lt;block2\u0026gt; } \u0026lt;block5\u0026gt; } \u0026lt;block6\u0026gt; Possible solution method1() \u0026lt;block6\u0026gt; method1(){ if(\u0026lt;condition1\u0026gt;){ method2() \u0026lt;block4\u0026gt; } else { method3() \u0026lt;block5\u0026gt; } } method2(){ while(\u0026lt;condition2\u0026gt;){ method3() \u0026lt;block3\u0026gt; } } method3(){ if(\u0026lt;condition3\u0026gt;){ \u0026lt;block1\u0026gt; } else { \u0026lt;block2\u0026gt; } } "},{"id":14,"href":"/docs/unittests/sections/tdd/","title":"Development driven by unit tests","section":"Unit tests","content":" Development driven by unit tests # Test-driven development (TDD) consists in converting a program\u0026rsquo;s requirements into test cases, before the program is fully developed.\nNote that this approach is not restricted to unit tests.\nIn practice # For a non-trivial method:\nCreate a method stub (e.g. return null is the method\u0026rsquo;s return type is a reference type). Specify the expected behavior (input and expected output) of the method. Write one or several test(s) for this method, illustrating the specification. Implement the method until the test(s) is (are) successful. Hint. Your IDE can generate method stubs.\nNote. This implementation may be temporary. For instance, it may be refactored later on (moving code where it logically belongs, factorizing duplicate code, etc.). However, the tests that were written before refactoring are (usually) still relevant afterwards, because they correspond to functional requirements.\nBenefits # Some benefits of TDD are:\nStarting from an example often helps clarifying what a method should do. TDD provides intermediate objectives (milestones) to a developer. The sooner a bug is identified (during the development process), the easier it is to fix. The program is likely to be more robust, because development was guided by requirements (rather than technologies or algorithmic considerations). Each unit test created during TDD provides an alternative entry point (\u0026ldquo;green arrow\u0026rdquo; in an IDE) into the codebase (in addition to the \u0026ldquo;main\u0026rdquo; method). This allows experimenting with a specific feature in isolation, ignoring aspects that are not relevant for this feature (e.g. GUI, network, data storage, etc.). Example # In our game, let us consider once again the method EventHandler.deleteUnit, which modifies the current board when a unit deletion instruction is received.\nProblem decomposition # First, let us decompose this method into simpler ones. For instance as follows:\npublic class Backend implements EventHandler { private Snapshot currentSnapshot; ... void deleteUnit(int rowindex, int columnIndex) { // reduce by 1 the number of remaining actions for the active player decrementNumberOfRemainingActions(); // delete the unit (leaving a blank tile) currentSnapshot.getBoard().removeUnit(rowIndex, columnIndex); // shift up or down the units that followed it (if any) shiftUnitsInColumn(columnIndex); // perform resulting unit merges (if any) performUnitMerges(); // if there is no more action for the active player, then end the turn if (currentSnapshot.getNumberOfRemainingActions() == 0){ endTurn(); } } ... } At first sight, the auxiliary method decrementNumerOfRemainingActions seems trivial, so it may not benefit from unit tests. The method shiftUnitsInColumn seems relatively simple as well. However, the two remaining ones (performUnitMerges and endTurn) seem more complex. So it could be helpful to decompose them and/or devise unit tests for them.\nLet us focus on endTurn. It may for instance be decomposed as follows:\nvoid endTurn() { // perform attacks for units whose counter is 1 // (on the active player\u0026#39;s side) performAttacks(); // change the active player swapActivePlayer(); } And performAttacks may in turn be decomposed as follows:\nvoid performAttacks() { int maxColumnIndex = currentSnapshot.getBoard().getMaxColumnIndex(); // for each column for (int columnIndex = 0; columnIndex \u0026lt;= maxColumnIndex; columnIndex++){ performAttacks(columnIndex); } } void performAttack(int columnIndex) { // for each combined unit in this column (for the active player), // starting from front units for (Unit unit: getCombinedUnits(columnIndex)){ int countdown = unit.getAttackCountdown(); // if the unit is ready to attack if(countdown \u0026gt; 1) { unit.setAttackCountdown(countdown - 1); } else { attack(columnIndex); } } } Unit test # The auxiliary method attack seems non-trivial, so it may be a good candidate for unit testing.\nOne possible (\u0026ldquo;happy path\u0026rdquo;) test could be:\nInput (for column 1):\nExpected output:\n"},{"id":15,"href":"/docs/regex/sections/practice/","title":"in practice","section":"Regular expressions","content":" Regexes in practice # Concrete regexes deviate from theoretical ones in several ways. In particular:\nConcrete syntaxes include a wide range of syntactic sugar, i.e. operators that could in theory be expressed in terms of |, * and concatenation.\nMany regex engines support expressions with features (such as backreferences) that go beyond the expressivity of theoretical regexes. Technically, such expressions do not qualify as as regexes (they may describe a language that is not regular). However, in practice, they are still referred to as \u0026ldquo;regexes\u0026rdquo;. This is also what we will do in this section.\nFlavours # Multiple syntaxes for regexes coexist, which have a lot in common. Among these:\nRegexes defined by the IEEE POSIX standards are supported by a variety of command-line utilities, scripting languages or database engines.\nThe regex engine of the programming language Perl has been very influential. A widely used variant is the PCRE (Perl Compatible Regular Expressions) library, written in C (and natively used by PHP and R). Besides, many programming languages (Java, Javascript, Python, C#, etc.) have adopted a regex syntax and engine inspired by Perl\u0026rsquo;s.\nA detailed comparison of some the main flavours of regexes can be found here.\nWarning. The patterns used in .gitigore files are not regular expressions.\nJava regexes # Java regexes are very similar to PCRE regexes (albeit less expressive).\nWe list below some of the main constructs of Java regexes, and refer to the Javadoc for an exhaustive list. Most of these are identical in other regex languages inspired by Perl\u0026rsquo;s.\nCharacters # A character in a Java regex can alternatively be written using its Unicode hexadecimal identifier, preceded with \\u.\nExamples.\nthe character A can be written either in its normal form, or \\u0041 the carriage return character can be written either \\r or \\u000D Special characters (like | or *) need to be escaped to be treated as standard ones (except in some specific contexts, see below).\nExamples. In order to be treated as a standard character:\n* can be either escaped (\\*) or written \\u002A \\ can be either escaped (\\\\) or written \\u005C Syntactic sugar # We have seen in previous sections that in theory, regular expressions only admit three operators:\nconcatenation ($e_1e_2$), union ($e_1$|$e_2$) and closure ($e$*). However, this is impractical for most implication.\nExample. In order to match a character that is not a digit, with these three operators only, one would need to write an expression that enumerates all other characters in the underlying alphabet, e.g.:\n$\\qquad\\qquad$ a | b | c | .. | A | B | C | .. | \u0026amp; | ! | \u0026gt; | ..\nFor the simple ASCII alphabet, this is already more than a hundred characters. For the Unicode alphabet, this is more than 100 000.\nIn practice, regexes include additional operators, most of which are syntactic sugar (i.e. could in theory be expressed with only concatenation, union, and closure).\nCharacter class # Square brackets ([ and ]) are used to denote a set of characters, called a character class.\nExamples.\n[abcd] is equivalent to a|b|c|d\ngr[ae]y is equivalent to gr(a|e)y\nA character class can also be defined with ranges of characters. If $c_1$ and $c_2$ are two characters, then $c_1$-$c_2$ (within square brackets still) denotes any character between $c_1$ and $c_2$ in the Unicode alphabet.\nExamples.\n[A-Z] matches any character between A and Z [A-Za-z0-9] matches any character between (A and Z) or between (a and z) or between (0 and 9) [A-Za-z@] matches @ or any character between (A and Z) or between (a and z) The complement (in the Unicode alphabet) of a character class is described by adding a ^ after the opening square bracket [.\nExamples.\n[^a] matches any character different from a [^abc] matches any character that is neither a, b or c [^0-9] matches any character that is not a digit [^A-Za-z0-9] matches any character that is not an ASCII letter or digit Most special characters (like * or |) can be used unescaped inside square brackets to refer to a character (some exceptions to this rule are -, ^ or \\).\nExamples.\n[|*] matches either a | or a * [^|] matches any character that is not | The special character . stands for any (Unicode) character\nExamples.\n.. matches any string of two characters .* matches any Unicode string Exercise List all matches returned by a regex engine for:\nthe regex gr[ae]y in the words grey and gray are homonyms the regex [A-Z][^;]*; in Alice:12;Bob,35; the regex \u0026lt;.*\u0026gt; in \u0026lt;span class=\u0026quot;title\u0026quot;\u0026gt;My Title\u0026lt;/span\u0026gt; Solution $[10 .. 14)$: grey, $[19 .. 23)$: gray $[0 .. 8)$: Alice:12;, $[19 .. 23)$: Bob:35; $[0 .. 35)$: \u0026lt;span class=\u0026quot;title\u0026quot;\u0026gt;My Title\u0026lt;/span\u0026gt; Exercise Use the regex validation tool regex101 to write a regex whose evaluation matches HTML tags. For instance, in the word\n$\\qquad\\qquad$\u0026lt;span class=\u0026quot;title\u0026quot;\u0026gt;My Title\u0026lt;/span\u0026gt;\nthe regex should match \u0026lt;span class=\u0026quot;title\u0026quot;\u0026gt; and \u0026lt;/span\u0026gt;.\nPossible solution \u0026lt;[^\u0026gt;]*\u0026gt;\nPredefined character classes # Some escaped characters denote common character classes:\n\\d is equivalent to [0-9] \\w is equivalent to [A-Za-z0-9] \\s stands for any whitespace character. It is equivalent to $\\qquad\\qquad$[ \\t\\n\\x0B\\f\\r]\n\\R stands for any Unicode linebreak sequence. It is equivalent to\n$\\qquad$\\u000D\\u000A|[\\u000A\\u000B\\u000C\\u000D\\u0085\\u2028\\u2029]\nThe complements of some of these classes are also available:\n\\D is equivalent to [^\\d] \\S is equivalent to [^\\s] \\W is equivalent to [^\\w] Quantifiers # If $i \\le j \\in \\mathbb{N}$ then $e${$i$,$j$} concatenates $e$ with itself at least $i$ times and at most $j$ times, and is evaluated in a greedy way.\nExamples.\na{1,3} is equivalent to aaa|aa|a [A-Z]{1,3} greedily matches a sequence of 1 to 3 capital letters [A-Z]{0,3} greedily matches a (possibly empty) sequence of at most 3 capital letters $e${$i$} is equivalent to $e${$i$,$i$}.\nExamples.\na{3} is equivalent to aaa [A-Z]{4} matches a sequence of 4 capital letters $e$+ is equivalent to $ee$*.\nExamples.\na+ greedily matches a sequence of at least one a \\d+ greedily matches a nonempty sequence of digits [^\\d]+ greedily matches a nonempty sequence of non-digits If $e$ does not end with a quantifier, then $e$? is equivalent to $e$|$\\varepsilon$.\nExamples.\na? greedily matches at most one occurrence of a (ab)? greedily matches at most one occurrence of ab [A-Z]? greedily matches at most one capital letter Lazy quantification # If $e$ ends with a quantifier (e.g. with * or +) then $e$? forces a lazy evaluation of this quantifier.\nExamples.\nIn the word $w$ = ab:\nab* matches $w$ ab*? matches $w[0 .. 1)$: a In the word $w$ = abbb:\nab{1,3} matches $w$ ab{1,3}? matches $w[0 .. 2)$: ab Boundary matchers # Some special characters match empty segments (i.e. segments with word $\\varepsilon$).\nIn particular:\n^ (outside of a character class definition) matches the beginning of a string, $ matches the end of a string. Examples. Consider the string $w$ = a123b\nthe regex \\d+ matches $w[1 .. 3)$: 123 the regex ^\\d+ has no match in $w$ the regex \\d+$ has no match in $w$ Hint. These two special characters are widely used, in particular for string validation: an input word $w$ belongs to the language described by a regex $e$ iff there is a match for the regex ^$e$$ in $w$.\nBesides, if this is the case, then the best first match is also the longest possible match.\nExample. In the string $w$ = ab:\nthe best first match for a|ab is $w[a .. 1)$: a the best first match for ^(a|ab)$ is $w[a .. 2)$: ab The special character \\b matches any \u0026ldquo;natural language word\u0026rdquo; boundary (i.e. beginning or end).\nExample. Consider the string $w$ = User Alice797 is 55 years old\nThe best first match for \\d+ in $w$ is $w[10 .. 13)$: 797 The best first match for \\d+\\b in $w$ is $w[10 .. 13)$: 797 The only match for \\b\\d+ in $w$ is $w[17 .. 19)$: 55 The only match for \\b\\d+\\b in $w$ is $w[17 .. 19)$: 55 Group # A group in a regex is the content of a pair of parentheses.\nGroups allow capturing subsegments of a matched segment.\nExample. Consider the regex: $e$ = a(b|c)d and the word $w = $abd\nThere is only one match for $e$ in $w$ (namely $w$ itself).\nWithin this match, the subsegment captured by the group (a|b) is $w[1 .. 2)$: b.\nGroups in a regex are (totally) ordered based on the position of their opening parenthesis.\nExample. In the regex a(([\\d]*)(a|b))\nGroup number 1 is (([\\d]*)(a|b)) Group number 2 is ([\\d]*) Group number 3 is (a|b) Exercise Use the regex validation tool regex101 to write a regex with a group that matches what is inside a pair of opening and a closing HTML tags. For instance, in the word\n$\\qquad\\qquad$\u0026lt;span class=\u0026quot;title\u0026quot;\u0026gt;My Title\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026quot;content\u0026quot;\u0026gt;Hello\u0026lt;/span\u0026gt;\nthe group should match My Title and Hello\nPossible solution \u0026gt;([^\u0026lt;]*)\u0026lt;/\nBackreference # A group can be referenced within a regex, with \\$n$, where $n$ is the group number. If the reference appears after the group, this is called a backreference.\nExample.\nIn the regex a(b|c)d\\1q, the backreference \\1 refers to the group (b|c) In the regex (a(b|m))d\\2m, the backreference \\2 refers to the group (b|m) Evaluation. Let $e$ be a regex with backreferences.\nConsider the expression $e\u0026rsquo;$ identical to $e$, but where each backreference is replaced with the group that it references. Then a match for $e$ is a match for $e\u0026rsquo;$ where each group and its copy capture segments with identical words.\nExample. The regex (a|b)\\1 is equivalent to aa|bb\nExercise Which words does the following regex match?\n$\\qquad\\qquad$((\\d)_\\2)@\\1\nSolution .\n1_1@1_1, 2_2@2_2, 3_3@3_3, etc. Note. Regexes with backreferences go beyond the expressivity of traditional regular expressions, meaning that they can describe languages that are not regular.\n"},{"id":16,"href":"/docs/interfaces/sections/java_interfaces/","title":"Java interfaces","section":"Interfaces","content":" Java interfaces # A Java interface is a programming interface with additional (object-oriented) features.\nSyntactically, a Java interface is similar to a class. But (in its simplest form), it contains no code. Instead, it specifies the behavior of some methods (which are implemented in some classes).\nExamples # The implementation of our game contains an interface called Snapshot, which describes what a game snapshot is. This interface specifies (among others) a method called getSizeOfReinforcement, as follows:\npublic interface Snapshot { ... /** * Returns the number of units that will enter the board if reinforcement * is called for the input player. */ int getSizeOfReinforcement(Player player); ... } Note that this description contains no code.\nA Java interface acts not only as documentation, but also as a contract : any (non-abstract) class that implements this interface must implement all methods declared in the interface (otherwise the program will not compile).\nA Java interface can be used to specify how two components of a system communicate (before the interface is even implemented!). For instance, the Snapshot interface specifies which information must be provided by our backend to the component in charge of displaying the game on screen.\nThe name of an interface can be used as a reference type (similarly to the name of a class). For instance, the Snapshot interface also specifies a method\nBoard getBoard(); which must return an object of type Board. And Board is itself an interface, which specifies the information needed to draw the game board (units, position, etc).\nHere is for instance a fragment of the Board interface:\n/** * Board for an ongoing game. * This is a two-dimensional grid. * * Tile coordinates are natural numbers and start at 0. * The top left tile has coordinates (0,0). */ public interface Board { ... /** * Returns true if the input coordinates are within the board\u0026#39;s boundaries */ boolean areValidCoordinates(int rowIndex, int columnIndex); /** * Removes the unit standing at the input coordinates, and does nothing * if there is none. */ void removeUnit(int rowIndex, int columnIndex) throws CoordinatesOutOfBoardException; ... } Finally, the interface DisplayManager specifies a method that can be called (e.g. from the backend) to draw a Snapshot on screen (together with a message):\npublic interface DisplayManager { ... /** * Displays the input snapshot on screen, as well as the input message. */ void drawSnapshot(Snapshot snapshot, String message); ... } Observe that these interfaces only specify what classes should implement, not how. In other words, these interfaces specify how components can communicate without exposing unnecessary implementation details.\nWhen to use a Java interface? # Technically, Java interfaces are not needed in a project. But they can make collaboration within a team of developers significantly easier. In particular:\nAn interface is a convenient way to expose what is needed to interact with your code, while hiding the details of your implementation. For instance, the method drawSnapshot (mentioned above) can be called to draw a snapshot on screen, without knowing how this method is implemented.\nAs a contract, an interface allows two programmers to work independently, ensuring interoperability between the methods and/or components that they are respectively developing.\nInheritance # An interface in Java can extend another interface, like a class can extend another class, with the same keyword extends.\nHowever, Java interfaces support multiple inheritance (whereas java classes do not). This means that an interface A can extend two interfaces B and C even if B and C do not extend each other.\nImplementing an interface # In Java, the keyword implements is used to indicate that a class implements an interface. For instance:\npublic class SnapshotImpl implements Snapshot { ... } Note. It is good practice to avoid a class and an interface with the same name (even if they describe the same objects). To differentiate them, you may for instance use the suffix Impl, as illustrated above.\nConsider a class C that implements an interface I :\nif C is abstract, then it can implement some of the methods declared in I if C is not abstract, then each method declared in I must be implemented in C (or some superclass of C ), otherwise the program will not compile. Exercise The program represented by the following diagram does not compile. Can you see why?\nSolution The class Butterfly does not implement the method sleep.\nNote. In this example, the class Butterfly inherits an implementation of boost (from AbstractUnit), and overrides it. This is not an error.\nSince Java interfaces support multiple inheritance, a Java class can implement several interface that do not extend each other.\nFor instance, the class Unicorn could implement an interface Animal and another interface ImaginaryCreature, even though none of these two interfaces extends the other (not all animals are imaginary, and not all imaginary creatures are animals). This would be declared as follows:\npublic class Unicorn extends MobileUnit implements Animal, ImaginaryCreature { ... } Exercise The program represented by the following diagram does not compile. Can you see why?\nSolution The class Unicorn does not implement the method hide.\nInterfaces vs abstract classes # In theory, Java\u0026rsquo;s interfaces and abstract classes serve different purposes:\nabstract classes are meant to factorize code (i.e. avoid redundant code), whereas interfaces are meant to document code and act as a contract. However, in practice, they have partially overlapping features, which may be confusing.\nIn particular:\nan abstract class can have abstract methods, which behave similarly to interface methods (with the additional constraint that an abstract method must be implemented by at least one subclass). Since Java 8 (2014), interfaces can carry code, in so-called default methods. This feature was introduced for backward compatibility reasons, but arguably contradicts the meaning of the term \u0026ldquo;interface\u0026rdquo;. A benefit of default methods (i.e. methods implemented in interfaces) is that they allow multiple inheritance of implemented methods (since interfaces allow multiple inheritance), which is not possible with classes. For this reason, some authors (like Joshua Bloch) recommend using default methods instead of abstract methods. However, a program where interfaces play the role of abstract classes may be confusing for less experienced Java developers.\nFor this course, we chose to present Java interfaces from a more traditional (pre-Java 8) perspective, because this perspective is arguably easier to understand, and because this is still the dominant usage of Java interfaces. However, for your project, feel free to deviate from this model if you think that this is appropriate (in particular if you need multiple inheritance).\n"},{"id":17,"href":"/docs/recursion/sections/nary/","title":"N-ary recursion","section":"Recursion","content":" N-ary recursion # Definition. A recursive method that is not linear recursive uses n-ary recursion.\nSpecific cases include:\nbinary recursion if a method performs up to two recursive calls each time it is executed, ternary recursion if it performs up to three recursive calls each time it is executed, etc. Examples.\nThe algorithm seen earlier to print all files in a folder uses n-ary recursion.\nAll the binary tree algorithms seen earlier use binary recursion.\nDivide and conquer # The divide-and-conquer paradigm is a variation of the methodology seen earlier to solve a problem recursively. In the divide-and-conquer approach, the smaller inputs $I_1$, .., $I_k$ usually have (nearly) the same size.\nDivide-and-conquer has been instrumental in discovering efficient solutions to pervasive computational problems. Well-known examples include:\nthe Karatsuba algorithm for multiplying two numbers, the Strassen algorithm for matrix product, Mergesort for (stable) sorting. Example: Mergesort # Mergesort is one of (many) algorithms commonly used to sort an array, i.e. to solve the following problem:\nInput: an array $A$\nOutput: a sorted array with the same elements as $A$\nObservation. As we saw already, the array can be of any type (int, String, City, Unit, etc.), and the sorting criterion can be any total preorder over this type.\nThe Mergesort algorithm may be summarized as follows:\n(Base case). If $A$ has size $1$, then return it ($A$ is already sorted). (Inductive case). Otherwise: (divide): partition $A$ into its left half $A_1$ and its right half $A_2$, (solve): sort $A_1$ and sort $A_2$ (recursively), (combine): merge (the sorted versions of) $A_1$ and $A_2$. Here is a naive implementation, in pseudocode:\n// Returns a sorted array that contains the same elements as A. Type[] mergesort(Type[] A) { // Base case: the input array has size 1, it is already sorted. if(A.length == 1){ return A } // Inductive case (the input array has size \u0026gt; 1) // Compute the middle index (rounded down) int middleIndex = (A.length - 1) / 2 // Copy the left half of A into a new array Type[] leftHalf = copy(A[0 .. middleIndex]) // Sort it leftHalf = mergesort(leftHalf) // Copy the right half of A into a new array Type[] rightHalf = copy(A[middleIndex + 1 .. A.length - 1]) // Sort it rightHalf = mergesort(rightHalf) // merge the two sorted halves return merge(leftHalf, rightHalf) } Warning. This implementation is suboptimal (some arrays can be reused). We only used it to keep the explanation simple.\nExercise To complete this algorithm, implement (in pseudocode) the auxiliary method\nType[] merge(Type[] A, Type[] B) that takes as input two sorted arrays A and B, and returns a sorted array that contains their values.\nTry also to write it in such a way that the overall Mergesort algorithm is stable.\nPossible solution Iterate over A and B in parallel:\nif A[0] (resp. B[0]) is smaller than B[0] (resp. A[0]), then: add A[0] (resp. B[0]) to the output array, and repeat with A[1] and B[0] (resp. A[0] and B[1]), etc. when reaching the end of A (resp. B), add the remaining elements of B (resp. A) to the output array. More precisely:\nType[] merge(Type[] A, Type[] B){ // Output array Type[] C = new Type[A.length + B.length] // Index to iterate over A int a = 0 // Index to iterate over B int b = 0 // Index to iteratate over C int c = 0 // while we have not reached the end of A or B while (a \u0026lt; A.length \u0026amp;\u0026amp; b \u0026lt; B.length) { if(A[a] \u0026lt;= B[b]) { C[c] = A[a] a++ } else { C[c] = B[b] b++ } // If we reached the end of A, if(a == A.length){ // append all remaining elements of B to the output array. append(B, b, C, c) } else // Otherwise we reached the end of B. // So append all remaining elements of A to the output array. append(A, a, C, c) } } append (Type[] D, int d, Type[] C, int c) { while (d \u0026lt; D.length){ C[c] = D[d] d++ } } Merge sort in action. You can find visual illustrations of the execution of merge sort online. For instance this animation, or this (more accurate) one.\nObservation. Merge sort is a stable sorting algorithm.\nTree and graph traversal # Earlier in this chapter, we used different algorithms to traverse a binary tree, where nodes were instances of the following class:\nOne of these algorithms was the so-called \u0026ldquo;pre-order traversal\u0026rdquo;:\ntraverse(Node root){ // inductive case only (do nothing in the base case) if (root != null){ print(root.label) traverse(root.leftChild) traverse(root.rightChild) } } This algorithm naturally generalizes to trees where nodes may have more than two children. Nodes in such a tree can be represented as instances of the following class:\nAnd the algorithm becomes:\ntraverse(Node root){ if (root != null){ print(root.label) foreach child in root.children { traverse(child) } } } This algorithm can in turn be adapted to traverse a graph. More precisely, to explore all nodes reachable (directly or transitively) from a given source node in the graph.\nWarning. When applied to a graph, the algorithm above:\nmay not terminate (if the graph contains a loop), may process some nodes multiple times (even if the graph is acyclic). In order to avoid this, a common technique consists in labelling nodes in a graph with an additional boolean attribute visited, which indicates whether a node has already been visited during a traversal:\nAnd the algorithm becomes:\ntraverse(Node root){ if (root != null \u0026amp;\u0026amp; !root.visited){ root.visited = true print(root.label) foreach child in root.children { traverse(child) } } } Terminology. This approach is often called depth-first exploration of a graph.\nExercise Consider the following graph.\nWhat does the above algorithm print for input node A, assuming that the children of each node are sorted in label\u0026rsquo;s alphabetical order?\nSolution A B D F C E\nMinimax/Maximin # Minimax is a recursive algorithm with applications in games, robotics, decision making, etc.\nMinimax may be easier to explain in the context of a turn-based zero-sum game, i.e. a game (like chess or tic tac toe) where players compete with each other (as opposed for instance to a collaborative game).\nZero-sum two player games can be used to model decisions that minimize risk, assuming that the worst will happen if it can. In other words, one the two players represents the decision maker, and the other player represents \u0026ldquo;bad luck\u0026rdquo;.\nNumerous extensions and heuristics have been devise for Minimax. Here we only focus on the algorithm in its basic form.\nWinning strategy # Let Alice and Bob be our two players.\nExercise Consider the following state of a game of tic-tac-toe, where Alice plays with crosses, and is the next person to play.\nAssuming that Alice plays optimally, she already has won the game. Can you see why?\nSolution If Alice plays top right or bottom right, then regardless of Bob\u0026rsquo;s action, she can complete a line or a diagonal as her next move.\nLet us generalize this observation.\nIn a turn-based two player game, a sequence of moves can be viewed as a list of board states, whose head is the initial board state.\nThe tree that consists of all these lists represents all possible sequences of moves from the initial board state.\nExample. In the following tree, the root is a board state (of an imaginary game), and each branch represents a possible sequence of moves. Alice\u0026rsquo;s possible moves are the green edges, and Bob\u0026rsquo;s possible moves are the red edges.\nThe numbers on the leaves represent the payoff for Alice:\n9 if this is a winning state for Alice, and 0 if this is a winning sate for Bob. Warning. In such a tree, several nodes may represent the same board state (e.g. in a chess game, where different sequences of moves may lead to the same board state).\nExercise In the tree above, determine whether Alice has already won the game (assuming that she plays optimally).\nSolution The answer is yes, if Alice selects the right child of the tree\u0026rsquo;s root.\nObservation. In both exercises above, we were able to determine that Alice had already won the game, regardless of Bob\u0026rsquo;s actions. Intuitively, this holds iff:\nthere is a move for Alice such that, for every possible move of Bob, there is a move for Alice such that, for every possible move of Bob, \u0026hellip; either: there is a move for Alice that produces a winning state for Alice, or every possible move of Bob produces a winning state for Alice. This observation leads to a natural recursive definition.\nTerminology. In our tree, let us assuming that the root has depth $0$. We call a node existential if its depth is even, and universal if its depth is odd.\nExistential (resp. universal) nodes are the ones selected by Alice (resp. Bob).\nDefinition. A node $n$ is a winning node (for Alice) if:\nit represents a winning state for Alice, or $n$ is existential and some child of $n$ is a winning node, or $n$ is universal and all children of $n$ are a winning nodes. Naive algorithm # Let us start with a naive algorithm for games where:\nthe height of the tree is finite (as opposed to chess for instance, where there can be infinite sequences of moves). each leaf is a winning state for either Alice or Bob (as opposed to tic-tac-toe for instance, where there can be a draw). In such a game, every node of the tree must be a winning node for Alice or for Bob. In order to determine this, we can intuitively propagate labels up the tree:\nLet us assume that nodes in our tree are instance of the following class Node.\nNotation.\nIf nodes is an array of nodes and f a function that takes a node as argument, we will use:\n$\\qquad$ [ f(n) | n in nodes ]\nfor the array obtained by applying f to each element of nodes.\nObservation. Let n be a non-leaf node whose children have label 0 or 9. Then:\nthere exists a child of n with label 9 iff max [ c.label | c in n.children ] = 9 every child of $n$ is labeled with 9 iff min [ c.label | c in n.children ] = 9 Using this observation and our definition of a winning node (above), we can write the following recursive algorithm (in pseudocode):\n// existential node int maxiMin(Node n){ // base case (leaf node) if(n.children.length == 0){ return n.label } // inductive case: return the largest label computed for a child return max [ miniMax(c) | c in n.children ] } // universal node int miniMax(Node n){ // base case (leaf node) if(n.children.length == 0){ return n.label } // inductive case: return the least label computed for a child return min [ maxiMin(c) | c in n.children ] } In this algorithm, the method maxiMin (resp. miniMax) takes an existential (resp. universal) node as input, and returns:\n9 if this node is a winning node for Alice, or 0 if this node is a winning node for Bob. Note. The code can be (slightly) factorized by writing a unique recursive method, with an additional boolean argument that indicates whether the input node is existential or universal.\nThis is usually how the algorithm is presented. We used two methods instead for didactic reasons.\nApplication # In practice, in order to apply this algorithm to a game, the class Node is unnecessary. Instead, we can use:\nan auxiliary procedure that compute the \u0026ldquo;children of a node\u0026rdquo;, i.e. takes as argument a board state, and enumerates all board states that can be reached from it in one move. an auxiliary procedure score that determines whether a \u0026ldquo;node\u0026rdquo; is a leaf, and its \u0026ldquo;label\u0026rdquo; if it is a leaf. This procedure takes a state as input, and determines whether this state is a winning state for Alice or Bob. Then Alice can decide her next move by calling miniMax(s) for each successor state s of the current state, and select any of the states with the highest score.\nGeneralization # Arbitrary weights # The Minimax algorithm can be generalized to scenarios where a leaf node may not represent a winning state for Alice or Bob. For instance, in order to model tic-tac-toe, we may label some leaves with the value 4 for a draw.\nMore generally, any function score that assigns a score to a node can be used, as long as it assigns a maximal value to a winning state for Alice, and a minimal value to a winning state for Bob.\nThe algorithm is unchanged.\nLarge or infinite trees # Warning Minimax can be prohibitive for games with an important tree height (since the number of board states to explore may grow exponentially with the height of the tree).\nBesides, Minimax does not terminate if the tree has infinite branches (for instance in a chess game).\nThis is why the tree of game states is usually explored up to a certain depth.\nExample. Deep Blue (the first program that defeated a chess world champion) was only looking 12 moves ahead.\nThe algorithm becomes:\n// existential node int maxiMin(Node n, int depth){ // base case if(n.children.length == 0 | depth == 0){ return score(n) } // inductive case: return the largest label computed for a child return max [ miniMax(c, depth - 1) | c in n.children ] } // universal node int miniMax(Node n, int depth){ // base case if(n.children.length == 0 | depth == 0){ return score(n) } // inductive case: return the least label computed for a child return min [ maxiMin(c, depth - 1) | c in n.children ] } Optimization # A variety of optimization techniques have been proposed for Minimax (e.g. alpha-beta pruning). They are beyond the scope of this course.\n"},{"id":18,"href":"/docs/project/sections/board_game/","title":"Option 2: board game","section":"Project","content":" Option 2: board game # The second project option available to you consists in developing a video game with mechanics analogous to the ones of Might \u0026amp; Magic: Clash of Heroes or Legend of Solgard.\nStudents who choose this option you will be provided:\na basic graphical user interface (GUI) that they can reuse and/or customize, examples during lectures that they may adapt to their project. Requirements # The minimal requirement to submit this project is a player vs player game playable on a single machine.\nBut of course, you are free to go further and add your own features. Among other possibilities, you could for instance:\nimplement new mechanics (e.g. a rock-paper-scissor logic for unit encounters, events that may affect the board, etc.), make the game deterministic (i.e. eliminate randomness), create units with specific behaviors, implements scripted encounters (\u0026ldquo;boss fights\u0026rdquo;), implement a story, character progression, etc., develop a player vs bot mode, etc, Note. If you choose the last options in the list above (player vs bot), then you may benefit from an algorithm seen in the chapter on recursion. Besides, if several groups choose this option, we may organize a competition between bots (provided that they play by the same rules).\nGuidelines # GUI # The source code for the GUI can be cloned from GitHub. The project is designed so that:\nyou can develop a fully functional game (player vs player or player vs bot) by focusing exclusively on the backend (i.e. the mechanics of the game), without modifying the GUI. backend and frontend are decoupled. Communication between frontend and backend is specified via Java interfaces. It revolves around the notion of a game snapshot, which contains all the information needed to describe a state of the game (equivalently, you can think of a snapshot as a save state). In particular, snapshots are independent of a specific GUI.\nFor instance, a method is available that allows you to pass a snapshot to the GUI component. When you call this method, the snapshot will be drawn on screen, replacing the previous one (if any).\nAs input, your code receives the next action of the active player (for instance, delete the unit present on a specific tile). These are again specified by an interface. Your code should react accordingly: modify the current snapshot, and then send it the GUI component for display.\nThe README.md file (at the root of the project) contains a description of the different components and interfaces, as well as building instructions, and explains where your code could fit. Read it carefully before you start working on your project!\nNote. You are of course free to modify the interfaces that come with the project. But this may require modifying the implementation of the GUI.\nDisclaimer. By design, the project compromises performance for simplicity and modularity. This is not how a resource intensive game would be implemented.\nMore generally, this exercise is not meant to teach game development, but general-purpose programming and problem solving.\n"},{"id":19,"href":"/docs/multithreading/sections/thread/","title":"Process vs thread","section":"Multithreading","content":" Thread # Process # A process is (usually) an instance of a computer program.\nProcesses can interact in several ways. In particular:\na process may spawn another process, a process may wait for another process to terminate or release a lock on some resource. Thread # A process consists of one or several threads.\nConceptually, a thread is similar to a process. In particular, threads can interact analogously to processes.\nHowever, threads are designed to allow heavier concurrency, thanks a shared address space and fast context switches.\nin Java # A Java program is normally executed by a single process.\nThis process consists of several threads. Among these, the main thread is the one that executes the main method of the application (e.g. the method public static void main of the main class).\nProgramming with threads # Many high-level programming languages (like Java) allow creating threads and assigning tasks to these threads. However, by default, a program does not specify whether two threads are executed on the same core (i.e. concurrently) or not (i.e. in a parallel fashion). The decision is usually left to the operating system, and depends on the resources available at runtime.\nIn particular, if a program allows two threads to be executed concurrently (on the same core), then it also allows them to be executed in parallel (on different cores).\n"},{"id":20,"href":"/docs/input/sections/read/","title":"Reading from and writing to a file in Java","section":"I/O and serialization","content":" Reading from and writing to a file in Java # There are numerous ways to read from or write to a file in Java, using either native of external libraries.\nWe highlight here some of the simplest ones (syntactically), even though they may not be the most efficient.\nWe also restrict our scope to:\nreading and writing text (but Java also offers multiple ways to read or write sequences of bytes), reading sequentially and writing by appending (but some classes like RandomAccessFile allow accessing any position in a file). Reading # Reading a text file line by line # Here is one way to process the content of a text file line by line:\ntry (BufferedReader reader = Files.newBufferedReader(Path.of(\u0026#34;path/to/file.txt\u0026#34;))){ String line = reader.readLine(); while (line != null){ System.out.println(line); line = reader.readLine(); } } catch (IOException e) { throw new RuntimeException(e); } Reading an entire text file # Alternatively, if the file is small, its whole content can be stored as a list of strings (one per line), as follows:\nList\u0026lt;String\u0026gt; lines = null; try (Stream\u0026lt;String\u0026gt; stream = Files.lines(Path.of(\u0026#34;path/to/file.txt\u0026#34;))){ lines = stream.toList(); } catch (IOException e) { throw new RuntimeException(e); } Or even as a single string:\nString text; try { text = Files.readString(Path.of(\u0026#34;path/to/file.txt\u0026#34;)); } catch (IOException e) { throw new RuntimeException(e); } Splitting # The method String.split can be used to decompose a string into an array of substring, based on some delimiter. For instance, in a csv file, each line can be decomposed using a comma (,), as follows:\nString line = \u0026#34;Alice,Bob,Carol\u0026#34;; // Contains [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Carol\u0026#34;] String[] names = line.split(\u0026#34;,\u0026#34;); We will see in the chapter dedicated to regular expressions that more expressive delimiters can be used.\nReading with a scanner # The class Scanner is a versatile tool that allows reading from the standard input, but also from a file.\nWe refer to last year\u0026rsquo;s course for an overview.\nWriting # Warning. In Java, methods that write an (underspecified) line separator produce a (sequence of) character(s) that depends on the operating system running the program: \\r\\n on Windows, and \\n on most other modern operating systems.\nThis is the case in all three examples below, with the methods BufferedWriter.newLine, PrintWriter.println and Files.write.\nWriting incrementally # A common way to write to a file consists in using a BufferredWriter. For instance:\ntry(BufferedWriter writer = new BufferedWriter(new FileWriter(\u0026#34;path/to/file.txt\u0026#34;))){ writer.write(\u0026#34;Hi\u0026#34;); writer.newLine(); } catch (IOException e) { e.printStackTrace(); } A PrintWriter offers additional methods to easily format the output, such as print, println or printf, analogous to the methods of the standard output stream System.out. It is often used as a wrapper around another writer, for instance a BufferedWriter:\ntry(PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(\u0026#34;path/to/file.txt\u0026#34;)))){ writer.println(\u0026#34;Hi\u0026#34;); } catch (IOException e) { e.printStackTrace(); } Writing an entire list # The method Files.write can be used to write all elements of a list to a file (one per line):\nList\u0026lt;String\u0026gt; strings = List.of(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;); try { Files.write( Path.of(\u0026#34;path/to/file.txt\u0026#34;), strings ); } catch (IOException e) { throw new RuntimeException(e); } Writing a single string # The method Files.writeString can be used to write a single string to a file\ntry { Files.writeString( Path.of(\u0026#34;path/to/file.txt\u0026#34;), \u0026#34;foo\u0026#34; ); } catch (IOException e) { throw new RuntimeException(e); } Note that this will overwrite the content of the file.\nInstead, in order to append a string to a file, a third argument can be added to the method Files.writeString:\ntry { Files.writeString( Path.of(\u0026#34;path/to/file.txt\u0026#34;), \u0026#34;foo\u0026#34;, StandardOpenOption.APPEND ); } catch (IOException e) { throw new RuntimeException(e); } "},{"id":21,"href":"/docs/stream/sections/init/","title":"Source","section":"Streams in Java","content":" Source # Collection # A stream can be created out of a Java Collection with the instance method stream.\nExample.\nList\u0026lt;Unit\u0026gt; units = getUnits(); units.stream(); If the collection has a predictable order of iteration (e.g. if the collection is a List), then the elements will appear in this order in the stream.\nTo create a stream out of the entries of a map, we can use the instance method Map.entrySet (which returns a set).\nExample.\nMap\u0026lt;String, Integer\u0026gt; map = getMap(); map.entrySet().stream(); Array # A stream can be created out of a Java array with the static method Arrays.stream.\nExample.\nUnit[] units = getUnits(); Arrays.stream(units); Generate a stream with indices # An IntStream is a stream of int (see the dedicated section on streams with primitive numeric types). An IntStream can for instance be created with the static method IntStream.range, as follows:\nExample.\n// Contains [0, 2] List\u0026lt;Unit\u0026gt; evenIntegers = IntStream.range(0, 4) // produce the stream (0, 1, 2, 3) .filter(i -\u0026gt; i % 2 == 0) // retain even numbers .toList(); This can be used to iterate over a list or array while keeping track of the elements\u0026rsquo; positions.\nExample.\nUnit[] units = getUnits(); List\u0026lt;Unit\u0026gt; evenUnits = IntStream.range(0, units.length) .filter(i -\u0026gt; i % 2 == 0) .mapToObj(i -\u0026gt; units[i]) .toList(); However, for this usage, external libraries offer more natural options. For instance, the StreamEx library can create a map from index to entry in an array, and generate a stream out of the entries of this map (analogous to the set of entries produced by Map.entrySet).\nUnit[] units = getUnits(); List\u0026lt;Unit\u0026gt; evenUnits = EntryStream.of(units) .filterKeyValue((index, unit) -\u0026gt; index % 2 == 0) .values() .toList(); } To use StreamEx in a Maven project, declare this dependency:\n\u0026lt;dependencies\u0026gt; ... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;one.util\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;streamex\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.8.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; ... \u0026lt;/dependencies\u0026gt; or in a Gradle project:\nimplementation group: \u0026#39;one.util\u0026#39;, name: \u0026#39;streamex\u0026#39;, version: \u0026#39;0.8.2\u0026#39; "},{"id":22,"href":"/docs/intro/sections/lecturers/","title":"Teaching staff","section":"This course","content":" Teaching staff # Julien Corman will teach the lectures and one lab.\nDjamila Oukharijane will teach the other lab.\nOffice hours # If you need additional help with the content of the course, the assignments and/or your project, you can ask for office hours with any (or both) of us.\nThese appointments must be scheduled via email (follow the links above for our email addresses).\n"},{"id":23,"href":"/docs/multithreading/sections/simple/","title":"A simplified view","section":"Multithreading","content":" A simplified view # From an abstract perspective, in order to understand the properties of a program that allows concurrency and/or parallelism, it can be convenient to assume an simplified, ideal machine that:\nhas an unlimited number of cores, and relies exclusively on parallelism. Parallel computation # In this section, we borrow the simple syntax for parallel computation used in the popular textbook Introduction to algorithms.\nThis syntax extends imperative pseudocode with three keywords:\nspawn sync parallel These keywords correspond to primitives that are available (in one form or another) in many programming languages (like Java) or libraries (like OpenMP) that support multithreading.\nspawn and sync # the keyword spawn allows the current thread to create a child thread and execute an instruction (possibly a method call) in this child thread, as follows: $\\qquad$ spawn \u0026lt;myInstruction\u0026gt;\nthe keyword sync forces the current thread to pause its execution, until all the threads that it has spawned have terminated. Example. The following method:\ntakes as arguments two vectors with integer values, computes the sum of the values of each vector, and returns the sum of the two results. int aggregate (int[] v1, int[] v2){ int s1 = spawn sumElts(v1) int s2 = sumElts(v2) print(\u0026#34;waiting\u0026#34;) sync return s1 + s2 } int sumElts(int[] v){ int sum = 0 for(int i = 0; i \u0026lt; v.length; i++){ sum += v[i] } print(\u0026#34;done\u0026#34;) return sum } In this method:\nthe statement spawn sumElts(v1) creates a child thread and executes the auxiliary method sumElts (with argument v1) in this child thread. the statement sync forces the main thread to wait for termination of the child thread. There is no guarantee on which of the two threads will first finish executing the method sumElts. As a result, depending on the runtime environment, the program may output either\ndone done waiting or\ndone waiting done parallel # The keyword parallel is associated to a loop. Intuitively, it allows the environment to execute iterations of this loop in different threads (for instance, the library OpenMP provides such a keyword).\nThe (abstract) syntax is the following:\nfor parallel (\u0026lt;myIterationCondition\u0026gt;){ \u0026lt;myLoopBody\u0026gt; } Example. We can parallelize the auxiliary method sumElts in our previous example by adding the keyword parallel to the loop:\nint sumElts(int[] v){ int sum = 0 for parallel (int i = 0; i \u0026lt; v.length; i++){ sum += v[i] } return sum } The keyword parallel can be replaced with combinations of spawn and (if needed) sync.\nExample. The example that immediately precedes can be rewritten as follows:\nint sumElts(int[] v){ sumRec(v, 0, v.length - 1) } int sumRec(int[] v, int i, int max){ // base case if(i = max){ return v[i] } // inductive case. // compute the middle index int mid = (i + max) / 2 // recursive call on the left half, in a separate thread int leftSum = spawn sumRec(v, i, mid) // recursive call on the right half (in the current thread) int rightSum = sumRec(v, mid + 1, max) sync return leftSum + rightSum } Definition. The span of a program\u0026rsquo;s execution is the maximal number of instructions that it has to perform sequentially.\nExercise Let $f(n)$ measure the span of the program above, where $n$ is the size of the input vector.\nAssuming a number of cores $\\ge n$, which asymptotic class of cost functions does $f$ belong to?\nSolution $f$ is in $\\Theta(\\log n)$\nNote. In this example, it may be tempting to spawn the threads sequentially, rather than recursively. However, the benefit of parallelization is lost:\nint sumElts(int[] v){ int sum = 0 for (int i = 0; i \u0026lt; v.length; i++){ spawn sum += v[i] sync } return sum } in Java # Creating a thread # A thread in Java is an instance of the class java.lang.Thread.\nThere are many alternative syntaxes to create an instance of this class. We cover here two of the most common ones.\nInstantiate Runnable # The constructor Thread(Runnable runnable) takes as input an instance of the interface Runnable.\nRunnable is a functional interface, whose method is called run and has type\n$\\qquad$ void $\\to$ void\nTherefore it can be instantiated with a callback method (that takes no argument and returns no value).\nExample.\nThread myThread = new Thread( () -\u0026gt; { System.out.println(\u0026#34;Hello World\u0026#34;); } ); Alternatively, in order to pass an argument to the thread, we can create a class that implements Runnable, and pass the argument to the constructor if this class.\nExample.\npublic class MyRunnable implements Runnable { String arg; public MyRunnable(String arg){ this.arg = arg; } @Override public void run() { System.out.println(arg); } } $\\qquad$\nThread myThread = new Thread(new MyRunnable(\u0026#34;Hello\u0026#34;)); Create a subclass of Thread # Instead of instantiating Runnable, we can create a subclass of Thread ans instantiate it.\npublic class MyThread extends Thread { String arg; public MyThread(String arg){ this.arg = arg; } @Override public void run() { System.out.println(arg); } } Thread myThread = new MyThread(\u0026#34;Hello\u0026#34;); An advantage of this approach (compared to the previous one) is that we do not need to create an instance of Runnable. A drawback is that the class MyThread cannot extend another class (since Java does not support multiple inheritance). Spawning a thread # The instance method Thread.start spawns a thread.\nExample.\nThread myThread = new Thread( () -\u0026gt; { System.out.println(\u0026#34;Hello\u0026#34;); } ); myThread.start(); Waiting for a thread to terminate # Java provides a functionality analogous to the sync keyword seen above, but with a more fine-grained control.\nCalling the instance method Thread.join for a thread $t$ causes the current thread to pause its execution until termination of $t$.\nThread myThread = new Thread( () -\u0026gt; { myExpensiveMethod(); } ); myThread.start(); try { // wait for the spawned thread to terminate myThread.join() } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(\u0026#34;Job done, resuming execution\u0026#34;); Loop # In Java, an operation analogous to the parallel keyword is the instance method Stream.parallel that we saw in the dedicated section\nExample.\nList\u0026lt;Integer\u0026gt; vector = getVector(); vector.stream() .parallel() .filter(\u0026lt;myPredicate\u0026gt;) .map(\u0026lt;myFunction\u0026gt;) .forEach(\u0026lt;myConsumer\u0026gt;); In this case, the whole stream pipeline is executed in a concurrent fashion (possibly parallel if some cores are available).\nBy default, a pool of threads of size $k - 1$ is used, where $k$ is the number of cores of the CPU (but a larger pool can be manually configured).\nPause # The static method Thread.sleep can be used to pause the current thread for a certain amount of time.\nExample.\nSystem.out.ptinln(\u0026#34;Going to sleep...\u0026#34;); // sleep for 4 seconds Thread.sleep(4000); System.out.ptinln(\u0026#34;Waking up\u0026#34;); Warning. The method Thread.sleep does not guarantee that the input sleeping duration is precisely enforced. Therefore sleeping times should not be used to synchronize the activity of two threads.\n"},{"id":24,"href":"/docs/simplify/sections/boolean/","title":"Boolean conditions","section":"Simplifying code","content":" Boolean conditions # A complex boolean sub-expression in the scope of a negation can be difficult to read and/or debug.\nExample. The two following expressions are equivalent (but the latter is arguably easier to read):\n$$ \\neg(\\neg(a \\lor b) \\land \\neg (\\neg c \\lor d)) $$\n$$ a \\lor b \\lor \\neg c \\lor d $$\nSimplification # In a Boolean expression, negations can always be \u0026ldquo;pushed\u0026rdquo; inside parentheses, as follows:\nbase case:\n$\\neg (x = y)$ becomes $x \\neq y$ $\\neg (x \\le y)$ becomes $x \u0026gt; y$ $\\neg (x \u0026gt; y)$ becomes $x \\le y$ etc. inductive case:\n$\\neg (\\phi \\land \\psi)$ becomes $\\neg \\phi \\lor \\neg \\psi$ $\\neg (\\phi \\lor \\psi)$ becomes $\\neg \\phi \\land \\neg \\psi$ Exercise Simplify the following Java condition:\n!(x != y \u0026amp;\u0026amp; ( !x.hasNext() || !y.hasNext() || x.next() != y.next())) Solution The expression is of the form\n!(x != y \u0026amp;\u0026amp; \u0026lt;expression 1\u0026gt;) So we can transform it into\nx == y || ! \u0026lt;expression 1\u0026gt; Next observe that\n! \u0026lt;expression 1\u0026gt; is\n!( !x.hasNext() || !y.hasNext() || x.next() != y.next()) which can be transformed into\nx.hasNext() \u0026amp;\u0026amp; y.hasNext() \u0026amp;\u0026amp; x.next() == y.next() So the whole expression becomes\nx == y || ( x.hasNext() \u0026amp;\u0026amp; y.hasNext() \u0026amp;\u0026amp; x.next() == y.next() ) "},{"id":25,"href":"/docs/recursion/sections/correctness/","title":"Correctness","section":"Recursion","content":" Correctness # To check whether a recursive method is correct, it is (usually) sufficient to check that the two following two properties hold:\n(Base case(s)). The method is correct for the smallest possible inputs.\n(Inductive case). For an arbitrary $n$:\n$\\qquad\\qquad$ if the method is correct for all inputs of size $\\leq n$, then it is correct for all inputs of size $n+1$.\nExample. Consider the algorithm seen earlier to compute the sum of all nodes in a binary tree, if nodes are instance of the following class:\n1 2 3 4 5 6 7 8 int sum(Node root){ // base case if (root == null){ return 0 } // inductive case return root.value + sum(root.leftChild) + sum(root.rightChild) } For the size $n$ of the input, we can use in this example the height of the tree (i.e. the length of its longest branch).\nLet use verify that our two properties hold:\n(Base case). The sum of all labels in an empty tree is 0, so the method is trivially correct.\n(Inductive case). Consider any natural number $n$, and any tree of height $n+1$, with root $r$. And let us assume that the method sum is correct for all trees of height $\\le n$. We need to show that under this assumption, the method is correct for the tree rooted in $r$.\nObserve that the subtrees rooted in r.left and r.right have height $\\le n$. So from our assumption, the two recursive calls (Line 6) to the method sum are correct, meaning that they return the sum of all values in each of the two subtrees. Next, observe that the sum of all labels in our tree must be equal to the sum of all values in these two subtrees, plus the label of $r$. Which is precisely what the method returns. These two properties (1 and 2 above) provide an immediate proof by induction that the method is correct for all inputs.\nProof. Partition the set of all possible inputs by size, i.e. (assuming that inputs in our base case have size 0):\nthe set $S_0$ of all inputs of size $0$, the set $S_1$ of all inputs of size $1$, the set $S_2$ of all inputs of size $2$, etc. In order to show that the method is correct, it is sufficient to show that it is correct for each $S_i$ (where $i \\in \\mathbb{N}$).\nNow let us assume that properties 1 and 2 hold, i.e.:\n(Base case). The method is correct for $S_0$. (Inductive case). For any $n$, $\\qquad\\qquad$ if the method is correct for $S_0 \\cup S_1 \\cup \u0026hellip; \\cup S_n$, then it is correct for $S_{n+1}$.\nWe know that Property 2 holds for an arbitrary $n$. In particular, it holds for $n= 0$. In other words (replacing $n$ with $0$):\nIf the method is correct for $S_0$, then it is correct for $S_1$. So from Properties 1 and 3, we can infer:\nThe method is correct for $S_1$.\n$\\qquad$\nNext, consider the case where $n = 1$. From Property 2 still, we know (replacing $n$ with $1$) that:\nIf the method is correct for $S_0 \\cup S_1$, then it is correct for $S_2$. So from Properties 1 and 4 and 5, we can infer:\nThe method is correct for $S_2$.\n$\\qquad$\netc.\n"},{"id":26,"href":"/docs/intro/sections/evaluation/","title":"Evaluation","section":"This course","content":" Evaluation # Evaluation for this course is based on:\nassignments: up to 30 points, a group project: up to 60 points, and an oral exam: up to 10 points. Your final grade is the sum of the above, multiplied by 0.3.\nAssignments # There will be 7 or 8 assignments for this course. These are standard programming exercises, related to notions seen during the lectures. The labs are (mostly) dedicated to these assignments.\nThe assignments are individual (do not submit the code of another student).\nThe release of each assignment is announced via Teams.\nAssignments are submitted via GitHub classroom. You can submit an assignment multiple times (but only before its deadline).\nNote. In order to submit your assignments (and your project), you will need a GitHub account. If you do not have one already, please create one and communicate it to the lecturer, preferably via Teams. Make sure that you use a single GitHub account for all your assignments and your project.\nGroup project # Guidelines for the content of the project are in the dedicated chapter. We focus here on organization and evaluation.\nEach group must consist of 3 to 4 students. Groups should be decided by March 20, and communicated via mail or Teams to the lecturer.\nProjects are delivered via GitHub.\nThe project\u0026rsquo;s code is expected to apply techniques seen during the lectures, but only if relevant. Please do not add artificial functionalities to your project for the sole purpose of illustrating a certain technique.\nGrades for a project are awarded individually, based on each student\u0026rsquo;s contribution. Students are expected to work on different computers. Make sure that:\neach student uses a different (and only one) GitHub account, and each student commits (via git) his/her own code. Among other evaluation criteria, we consider:\nquantity of work, non-trivial logic, appropriate data types and data structures, structure of the code (no code duplication, good usage of methods, classes, interfaces, inheritance, etc.) readability, documentation, naming, collaboration, integration with the rest of project, evidence of testing, etc. Oral exam # The oral exam is individual.\nNo revision is needed.\nWe will ask you questions about your code and/or involvement in the project.\nFor instance:\nwhich design choices you made, which difficulties you encountered, the expected behavior of a certain method, how some portions of the code may be improved, etc. In particular, we will check whether you have a good understanding of the code that you submitted. If not, then your mark for the project may be reevaluated.\n"},{"id":27,"href":"/docs/objects/sections/inheritance/","title":"Inheritance","section":"Objects and classes","content":" Inheritance # Subclass # In most (class-based) object-oriented languages, a class A can extend another class B. In this case, A is called a subclass of B.\nThe intuitive meaning is inclusion between their respective sets of instances, i.e. every instance of A is also an instance of B (but the converse may not hold).\nThis can be paraphrased in English by \u0026ldquo;every A is a B \u0026ldquo;. For instance:\nevery banana is a fruit every square is a rectangle every rectangle is a geometric shape, etc. Exercise In each of the following cases, is A a subclass of B ?\nA B Student Vegetarian Polygon Hexagon Continent Country Country Continent City Country ZoomMeeting Meeting ZoomMeeting Calendar Chapter Book Minute TimeInterval Hour TimeInterval Minute Hour Integer RationalNumber RationalNumber RealNumber Integer RealNumber SetOfStudents Student Student SetOfStudents SetOfStudents Set SetOfStudents SetOfPeople ArrayOfIntegers ArrayOfRealNumbers ArrayOfIntegers SetOfIntegers Tree Graph Graph Tree AcyclicGraph Tree UnionOfSets Set Set UnionOfSets Object Class Subclass Class Class Superclass Solution A B Answer Student Vegetarian no Polygon Hexagon no Continent Country no Country Continent no City Country no ZoomMeeting Meeting yes ZoomMeeting Calendar no Chapter Book no Minute TimeInterval yes Hour TimeInterval yes Minute Hour no Integer RationalNumber yes RationalNumber RealNumber yes Integer RealNumber yes SetOfStudents Student no Student SetOfStudents no SetOfStudents Set yes SetOfStudents SetOfPeople yes ArrayOfIntegers ArrayOfRealNumbers yes ArrayOfIntegers SetOfIntegers no UnionOfSets Set yes Set UnionOfSets yes (arguably) Tree Graph yes (arguably) Graph Tree no AcyclicGraph Tree no Object Class no Subclass Class yes Class Superclass no Transitivity # The \u0026ldquo;extend\u0026rdquo; relation is transitive, meaning that if A extends B and B extends C, then A extends C (for any classes A, B and C ).\nFor instance, from the above examples, one can infer that \u0026ldquo;every square is a geometric shape\u0026rdquo;.\nAntisymmetry # If A extends B and B extends A, then they are the same class.\nExample. In the exercise above, Set and UnionOfSets are (arguably) the same class.\nInheritance # Naturally, if A is a subclass of B then it inherits the properties of B.\nFor instance, a rectangle has four right angles. Since every square is a rectangle, a square has four right angles as well.\nFactorizing code with a (possibly abstract) superclass # Inheritance can be used to avoid redundant code.\nDirect inheritance: illustration # Let us model the units of our game as objects.\nEach unit has:\na type (e.g. mage, unicorn, etc.), a color (at least in the original game), and a certain amount of health. The behavior and stats of a unit (e.g. number of turns before attacking when combined, default health, etc.) are dictated by its type. So it makes sense to group units by type.\nFor instance, one can create a class Unicorn whose instances are all units of type unicorn. In Java:\npublic class Unicorn { String color; int health; int attackCountdown; public Unicorn(String color) { this.color = color; health = 1; attackCountdown = -1; } } Note. We used the keyword attackCountdown in this example to indicate the number of turns before the unit attacks (and a special value of -1 when it is not set to attack). But there are of course other ways to model this.\nNote. In this example, we used the prefix this. for the attribute color only, because there is no ambiguity for the three other attributes.\nWe can also create a class Butterfly on the same model\npublic class Butterfly { String color; int health; int attackCountdown; public Butterfly(String color) { this.color = color; health = 2; int attackCountdown = -1; } } Now consider a method encounter that manages an encounter between two units. Without inheritance, one would need to implement four versions of this method:\nunicorn vs unicorn, unicorn vs butterfly, butterfly vs unicorn, and butterfly vs butterfly. For instance, the first of these four methods could be implemented as follows:\nvoid encounter(Unicorn u1, Unicorn u2) { // save the initial value of the first unit\u0026#39;s health int copy = u1.health; u1.health -= u2.health; u2.health -= copy; } More generally, if the game has $n$ types of units, then the code will contain $n^2$ nearly identical encounter methods.\nQuestion. Can we use inheritance in this example to avoid duplicate code (and how)?\nObserve that a unicorn and a butterfly (viewed as object) have identical attributes (a.k.a. \u0026ldquo;keys\u0026rdquo;), namely String color, int health, and int attackCountdown. So we can create a superclass of UnicornandButterflythat carries these attributes, and let the two subclasses inherit it. For instance, this superclass may be called Unit.\nHowever, we may also want every unit in the game to have a concrete type (like \u0026ldquo;unicorn\u0026rdquo; or \u0026ldquo;butterfly\u0026rdquo;), rather than being a generic \u0026ldquo;unit\u0026rdquo;. In Java, this can be achieved with the abstract keyword. This keyword ensures that our superclass cannot be directly instantiated (even though it can still have a constructor). For instance:\npublic abstract class Unit { String color; int health; int attackCountdown; public Unit(String color, int health) { this.color = color; this.health = health; int attackCountdown = -1; } } Because this class is abstract, the following code will not compile:\nUnit myUnit = new Unit(\u0026#34;green\u0026#34;, 2); Next, we can declare that Unicorn extends Unit, by using the Java keyword extends. We can also use the constructor of Unit within the constructor of Unicorn, with the Java keyword super.\nNote. In Java (as opposed to C++ for instance), a class can only have one immediate superclass, so the keyword super is never ambiguous.\nThis yields:\npublic class Unicorn extends Unit { public Unicorn(String color) { super(color, 1); } } And we can proceed similarly for the class Butterfly.\nObserve that all the attributes are now carried by the superclass Unit. However, because they are inherited, these attributes can be accessed as if they were regular attributes of the subclass. For instance,\nUnicorn myUnit = new Unicorn(\u0026#34;green\u0026#34;); System.out.println(myUnit.health); outputs\n1 This allows us to write a generic encounter method, as follows:\nvoid encounter(Unit u1, Unit u2) { // save the initial value of the first unit\u0026#39;s health int copy = u1.health; u1.health -= u2.health; u2.health -= copy; } And this method can be used with unicorns and/or butterflies. For instance:\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); Butterfly myButterfly = new Butterfly(\u0026#34;yellow\u0026#34;); encounter(myUnicorn, myButterfly); } Transitive inheritance # In the example above, we assumed that all units have a color and can attack. What if we also want to create a type of unit called Wall that has no color and cannot attack? An instance of this class does not need the attributes color and attackCountdown.\nA quick solution here consists is setting attackCountdown to -1, and color to null. However, unnecessary attributes make code harder to understand, and such a design may not scale well if the game is extended with more units types.\nExercise Modify our model to accommodate for the class Wall, so that an instance of Wall only has the health attribute.\nPossible solution One solution (among others) is the following:\nmodify the class Unit so that it only carries the attribute health, Wall extends Unit, create an (abstract) subclass of Unit (for instance MobileUnit) that carries the other two attributes, Butterfly and Unicorn extend MobileUnit (therefore they also extend Unit, by transitivity). Or in Java:\npublic abstract class Unit { int health; public Unit(int health) { this.heath = health; } } public class Wall extends Unit { public Wall() { super(5); } } public abstract class MobileUnit extends Unit { String color; int attackCountdown; public MobileUnit(String color, int health) { super(health); this.color = color; this.attackCountdown = -1; } } public class Unicorn extends MobileUnit { public Unicorn(String color) { super(color, 1); } } and similarly for Butterfy.\n"},{"id":28,"href":"/docs/stream/sections/intermediate/","title":"Intermediate operations","section":"Streams in Java","content":" Intermediate operations # In a stream pipeline, an intermediate operation takes a stream as input, and produces another stream.\nStateless operations # A stateless intermediate operation processes each element of the input stream independently, and without the need to memorize information about previous elements in the stream.\nStream.filter and Stream.map # These two instance methods allow specifying a stateless operation, via a callback method. We have already explained their behavior in detail in our initial pipeline example.\nStream.flatMap # This is another very useful instance method, which can produce several objects out a single object in the stream.\nExample. Consider the following classes City and Region.\nGiven as input a collection regions of regions, we can use the function flatMap to create a stream that consists of all cities in these regions, as follows:\nregions.stream() .flatMap(r -\u0026gt; r.cities.stream()) For instance, the following method takes as argument a list of regions, and returns the zip codes of all cities in these regions, with the exceptions of the zip code of Bologna:\nList\u0026lt;Integer\u0026gt; allZipCodesButBologna(List\u0026lt;Region\u0026gt; regions) { return regions.stream() .flatMap(r -\u0026gt; r.cities.stream()) .filter(c -\u0026gt; !c.name.equals(\u0026#34;Bologna\u0026#34;)) .map(c -\u0026gt; c.zipCode) .toList(); } Let us assume that the stream has type Stream\u0026lt;$\\mathit{T}$\u0026gt; (for instance, in our example, $\\mathit{T}$ is Region).\nThe method flatMap takes as argument a callback function of type\n$\\qquad T \\to$ Stream\u0026lt;$T\u0026rsquo;$\u0026gt;\nwhere $T\u0026rsquo;$ can be any type.\nIn this example, the callback function is\nr -\u0026gt; r.cities.stream() which has type\n$\\qquad$ Region $\\to$ Stream\u0026lt;City\u0026gt;\nLet us name this callback function $f$.\nThe method flatMap returns a Stream\u0026lt;$\\mathit{T\u0026rsquo;}$\u0026gt; (e.g. in this example a Stream\u0026lt;City\u0026gt;). This stream is the concatenation of all streams $f(a)$ such that $a$ belongs to the original stream.\nStateful operations # Stateful intermediate operations are the ones that are not stateless.\nWe list here some of the most useful ones.\nStream.distinct # This instance method produces an identical stream, but without duplicates.\nExample.\nList\u0026lt;Integer\u0026gt;list = List.of(2, 1, 1, 3, 1, 2); // Contains [2, 1, 3] List\u0026lt;Integer\u0026gt; ouputList = list.stream() .distinct() .toList(); For a stream of objects, duplicates are identified based on Java\u0026rsquo;s object equality (i.e. as specified by the method Object.equals).\nReminder. If a class overrides the method Object.equals, then it should also override Object.hashCode (and these two implementations should be consistent with each other).\nStream.sorted # This instance method outputs a sorted stream. It can be called with or without a Comparator.\nIts behavior (with and without a comparator) is analogous to the methods Arrays.sort and Collection.sort.\nExample.\nList\u0026lt;Integer\u0026gt;list = List.of(2, 1, 3, 1, 2); // Contains [1, 1, 2, 2, 3] List\u0026lt;Integer\u0026gt; ouputList = list.stream() .sorted() .toList(); Hint. Recall that Comparator\u0026lt;$T$\u0026gt; is a functional interface, whose (only) method is compare($T$ e1, $T$ e2). As a result, it can be implemented with an anonymous method.\nFor instance, the following method removes duplicates in a list of cities, and returns it sorted:\nList\u0026lt;City\u0026gt; sortDistinctCitiesByName(List\u0026lt;City\u0026gt; cities){ return cities.stream() .distinct() .sorted((c1, c2) -\u0026gt; c1.name.compareTo(c2.name)) .toList(); } Stream.limit # This instance method takes as argument an integer $n$, and outputs the $n$ first elements of the stream.\nExample.\nList\u0026lt;Integer\u0026gt;list = List.of(2, 1, 3, 1, 2); // Contains [2, 1, 3, 1] List\u0026lt;Integer\u0026gt; ouputList = list.stream() .limit(4) .toList(); Stream.skip # This instance method takes as argument an integer $n$, and outputs the stream without its $n$ first elements.\nExample.\nList\u0026lt;Integer\u0026gt;list = List.of(2, 1, 3, 1, 2); // Contains [3, 1, 2] List\u0026lt;Integer\u0026gt; ouputList = list.stream() .skip(2) .toList(); "},{"id":29,"href":"/docs/lambda/sections/lambda/","title":"Lambda expression","section":"Callback methods and lambda expressions","content":" Lambda expression # In certain programming languages like Java, C#, C++ or JavaScript, the term lambda expression (sometimes called closure expression) is used to denote an anonymous method with a certain syntax.\nThe term is a (loose) reference to lambda calculus, a model of computation exclusively based on function composition and application.\nSyntax in Java # A Java method\n\u0026lt;ReturnType\u0026gt; myMethod (\u0026lt;Type 1\u0026gt; \u0026lt;argument 1\u0026gt;, .., \u0026lt;Type n\u0026gt; \u0026lt;argument n\u0026gt;){ \u0026lt;Body\u0026gt; } can be written anonymously as the lambda expression:\n(\u0026lt;Type 1\u0026gt; \u0026lt;argument 1\u0026gt;, .., \u0026lt;Type n\u0026gt; \u0026lt;argument n\u0026gt;) -\u0026gt; { \u0026lt;Body\u0026gt; } For instance, the method:\nint division (int x, int y){ return x / y; } is equivalent to the lambda expression\n(int x, int y) -\u0026gt; { return x / y ; } However, a more concise syntax can often be used:\nArguments # If the types of the arguments can be inferred by the compiler (which is most often the case), then they can be omitted.\nExample.\n(int x, int y) -\u0026gt; { ... } can often be written\n(x, y) -\u0026gt; { ... } If the method has exactly one argument and its type is omitted, then parentheses can also be omitted.\nExample.\n(x) -\u0026gt; { ... } can always be written\nx -\u0026gt; { ... } If the method takes no argument, then parentheses are mandatory.\nExample.\n() -\u0026gt; { ... } Body # If:\nthe body of a lambda expression consists of a single statement, and the return type of this lambda expression (or void if there is none) can be inferred by the compiler (which is most often the case), then the semicolon (;), curly braces ({ and }) and return keyword (if any) can be omitted.\nExample.\n(x, y) -\u0026gt; { return x / y ; } can often be written\n(x, y) -\u0026gt; x / y "},{"id":30,"href":"/docs/objects/","title":"Objects and classes","section":"Docs","content":" Objects and classes # This chapter introduces some basic notions of (class-based) object-oriented programming.\n"},{"id":31,"href":"/docs/regex/sections/java/","title":"Using Java regexes","section":"Regular expressions","content":" Using Java regexes # Escaping \\ # A regex in Java is a string.\nRecall that within a Java string, a \\ character must be escaped (i.e. written \\\\) to be read as a normal character. So in a Java string that represents a regex, every \\ should be written \\\\.\nExample. The string \u0026quot;[A-Z]\\\\d+\u0026quot; represents the regex [A-Z]\\d+\nHint. This is another good reason for using a regex validation tool (e.g. regex101) to test and debug a regex, before incorporating it into a program.\nWarning. We saw earlier that when \\ is treated as a normal character in a regex, it must be escaped (\\\\). Therefore in this specific case, the Java string should contain \\\\\\\\.\nExample. The string \u0026quot;\\\\d+\\\\\\\\[A-Z]\u0026quot; represents the regex \\d+\\\\[A-Z]\nRegexes and String instance methods # Some instance methods of the class String take a regex as input. Among these:\nboolean matches(String regex) returns true iff the whole string belongs to the language described by the regex. Or equivalently if there is a match for the regex ^regex$. String input = \u0026#34;ab\u0026#34;; // Outputs false System.out.println(input.matches(\u0026#34;a\u0026#34;)); // Outputs true System.out.println(input.matches(\u0026#34;ab|a\u0026#34;)); // Outputs true System.out.println(input.matches(\u0026#34;a|ab\u0026#34;)); String replaceFirst(String regex, String replacement) replaces the best first match with the input replacement string: String input = \u0026#34;aba\u0026#34;; // Outputs \u0026#34;ba\u0026#34; System.out.println(input.replaceFirst(\u0026#34;ab|a\u0026#34;, \u0026#34;b\u0026#34;)); // Outputs \u0026#34;bba\u0026#34; System.out.println(input.replaceFirst(\u0026#34;a|ab\u0026#34;, \u0026#34;b\u0026#34;)); String replaceAll(String regex, String replacement) replaces all (successive) best first matches with the input replacement string: String input = \u0026#34;aba\u0026#34;; // Outputs \u0026#34;bb\u0026#34; System.out.println(input.replaceAll(\u0026#34;ab|a\u0026#34;, \u0026#34;b\u0026#34;)); // Outputs \u0026#34;bbb\u0026#34; System.out.println(input.replaceAll(\u0026#34;a|ab\u0026#34;, \u0026#34;b\u0026#34;)); For both replaceFirst and replaceAll, the replacement string can use a reference to a group, written $$n$, where $n$ is the group number:\nString input = \u0026#34;The windows are open. The apples are green.\u0026#34;; String output = input.replaceAll(\u0026#34;(\\\\w+)s\\\\s+are\u0026#34;, \u0026#34;$1 is\u0026#34;); // Outputs \u0026#34;The window is open. The apple is green.\u0026#34; System.out.println(output); Reminder. Strings in Java are immutable. So when the methods replaceFirst and replaceAll successfully \u0026ldquo;modify\u0026rdquo; the string, they return a different object.\nString[] split() splits the input string around the (successive) best first matches: String input = \u0026#34;This is weird.\\n\u0026#34;+ \u0026#34;Or not.\u0026#34; // Contains [ \u0026#34;This\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;weird.\u0026#34;, \u0026#34;Or\u0026#34;, \u0026#34;not.\u0026#34; ] String[] output = input.split(\u0026#34;\\\\s+\u0026#34;); java.util.regex # The native package java.util.regex contains among other the following classes:\nPattern # A Pattern is a regex.\nA Pattern can be created with the static method Pattern Pattern.compile(Sring regex).\nMatcher # A Matcher is a \u0026ldquo;regex engine\u0026rdquo; for a specific regex and a specific string.\nA Matcher can be created out of a Pattern, with the instance method Matcher matcher(String inputString) of the class Pattern.\nPattern pattern = Pattern.compile(\u0026#34;\\\\d+[a-z]*\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;Alice787@unibz\u0026#34;); Among others, the class Matcher provides the following instance methods:\nboolean matches(), String replaceFirst() and String replaceAll() behave analogously to their counterpart for the class String, described above.\nboolean find() tries to match the next best first match. If this method succeeds, then information can be retrieved about the matched segment (see below). The next call to find() will find the following best first match (if any).\nPattern pattern = Pattern.compile(\u0026#34;[A-Z][a-z]*\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;Alice and Bob are exhausted.\u0026#34;); // Outputs true and matches the segment with word \u0026#34;Alice\u0026#34; System.out.println(matcher.find()); // Outputs true and matches the segment with word \u0026#34;Bob\u0026#34; System.out.println(matcher.find()); // Outputs false System.out.println(matcher.find()); String group(int i) returns the substring captured by Group $i$ in the latest match. Group 0 stands for the whole regex.\nString group() is equivalent to group(0).\nint start() returns the start index (included) of the latest matched segment.\nint end() returns the end index (excluded) of the latest matched segment.\nPattern pattern = Pattern.compile(\u0026#34;([A-Z])[a-z]*\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;Alice and Bob are exhausted.\u0026#34;); //Find the best first match matcher.find(); // Outputs \u0026#34;Alice\u0026#34; System.out.println(matcher.group()); // Outputs \u0026#34;A\u0026#34; System.out.println(matcher.group(1)); // Outputs 0 System.out.println(matcher.start()); // Outputs 5 System.out.println(matcher.end()); //Find the next best first match matcher.find(); // Outputs \u0026#34;Bob\u0026#34; System.out.println(matcher.group()); // Outputs \u0026#34;B\u0026#34; System.out.println(matcher.group(1)); public Sream\u0026lt;MatchResult\u0026gt; results() returns all (successive) best first matches. Pattern pattern = Pattern.compile(\u0026#34;[A-Z][a-z]*\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;Alice and Bob are exhausted.\u0026#34;); // Contains two match results: // - one for the segment with word \u0026#34;Alice\u0026#34;, // - one for the segment with word \u0026#34;Bob\u0026#34; List\u0026lt;MatchResult\u0026gt; matches = matcher.results().toList(); MatchResult # A MatchResult is a matched segment.\nThe class MatchResult provides (among others) the instance methods String group(int i), String group(), int start() and int end(), which behave analogously to their counterparts in the class Matcher.\nPattern pattern = Pattern.compile(\u0026#34;[A-Z][a-z]*\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;Alice and Bob are exhausted.\u0026#34;); // Get all best first matches List\u0026lt;MatchResult\u0026gt; matches = matcher.results().toList(); // Outputs \u0026#34;Alice\u0026#34; System.out.println(matches.get(0).group()); // Outputs \u0026#34;Bob\u0026#34; System.out.println(matches.get(1).group()); "},{"id":32,"href":"/docs/input/sections/property/","title":"Configuration files","section":"I/O and serialization","content":" Configuration files # It is common practice for an application to store parameters (e.g. user-specific settings) in configuration files.\nA configuration file may be edited manually and/or via a graphical interface.\nConfiguration files may use different serialization formats. Some popular formats are INI, JSON, TOML, YAML or XML.\nin Java # Java provides native support for at least two configuration file serialization formats: XML and the so-called \u0026ldquo;property file\u0026rdquo; format.\nWe introduce here the latter.\nA property file usually:\nhas extension .properties, may have commented line (starting with # or !), contains one key=value pair per (non-commented) line. Example. In our game, the file config.properties has two key=value pairs:\nanimationDuration=1 resolution=1920x1080 More details about the syntax of property files (escaped characters, spaces, etc.) can be found here.\nReading a property file # The content of a property file can be loaded in memory and modified as an associative array , instance of the class Properties (which extends Map).\nFor instance, the content of a property file can be loaded as follows:\nProperties properties = new Properties(); try { properties.load(new FileInputStream(\u0026#34;path/to/config.properties\u0026#34;)); } catch (IOException e) { throw new RuntimeException(e); } Then a value can be read with the method getProperty (among other possibilities), as follows:\nString resolution = properties.getProperty(\u0026#34;resolution\u0026#34;); float duration = Float.parseFloat(properties.getProperty(\u0026#34;animationDuration\u0026#34;)); Writing to a property file # The content of a property file can be modified with the methods setProperty and store (among other possibilities), as follows:\nString path = \u0026#34;path/to/config.properties\u0026#34;; Properties properties = new Properties(); try { // load the file as an associative array properties.load(new FileInputStream(path)); // modify the associative array properties.setProperty(\u0026#34;animationDuration\u0026#34;, Float.toString(0.5f)); // replace the content of the property file with the // content of the associative array properties.store(new FileOutputStream(path)); } catch (IOException e) { throw new RuntimeException(e); } "},{"id":33,"href":"/docs/intro/sections/content/","title":"Content","section":"This course","content":" Content of the course # This is a beginner\u0026rsquo;s course on imperative and (class-based) object oriented programming, with an emphasis on practice and collaboration.\nThe course relies on Java as main programming language. However, many concepts seen in this course are relevant to other (imperative and/or object-oriented) programming languages: C/C++, C#, Javascript, Go, Kotlin, Lua, Perl, PHP, Python, Rust, Ruby, Typescript, Visual Basic, etc.\nPrerequisites # Students are expected to have completed the Computer Programming course (INF/01 76203).\nTherefore the following topics are not covered in this course:\nvariables, assignments, variable scope, basic data types (int, char, boolean, etc.). conditional statements (\u0026ldquo;if/then/else\u0026rdquo;) and loops, expression evaluation, methods/functions, arrays, etc. Students are also expected to have played the board game used as a running example throughout the lectures.\nOutcomes # After completing this course, students should be able to:\ndevelop a prototype application in Java, write structured, documented and easily maintainable code, collaborate with other developers. Focus # Foundations # Most lectures put an emphasis on problem solving, rather than providing syntax or (mechanical) recipes.\nFor conciseness, pseudocode may be used in some sections rather than Java code.\nSome lectures also focus on more abstract (albeit simple) notions. These includes elementary mathematical objects or structures: set, tuple, map, relation, preorder, graph, tree, etc.\nThe purpose is twofold:\ngeneralize techniques seen in this course to programming languages other than Java, provide a widely accepted vocabulary to document/explain your code. Collaboration # The course introduces basic coding practices to ease development within a team. In particular:\nstructuring a project (components, interfaces, encapsulation, etc.), factorizing code (inheritance, reuse of methods, etc.), test-driven development, collaboration via git. Note. What is considered good communication in computer science may differ from other disciplines. Emphasis is put on clarity, precision and conciseness.\nExercise Here is a (caricature of) a poorly documented method. Can you improve the method\u0026rsquo;s description and/or signature?\n/** The algorithm looks at the first collection, and is only guaranteed to * work if no number is present twice in this collection, in which case it * loops over the numbers contained in this collection (in no specific order) * and checks for each number whether it is also present in the second * collection (which is also expected to have distinct numbers). The code * written in this loop adds the current number (from the first collection) * to the output collection if this number is also present in the second * collection, and does nothing with this number otherwise. */ Collection\u0026lt;Integer\u0026gt; filterNumbersThatAreShared(Collection\u0026lt;Integer\u0026gt; c1, Collection\u0026lt;Integer\u0026gt; c2); Solution A simpler signature and description could be:\n/** * Returns the intersection of sets s1 and s2. */ Set\u0026lt;Integer\u0026gt; intersection(Set\u0026lt;Integer\u0026gt; s1, Set\u0026lt;Integer\u0026gt; s2); However, the following topics are beyond the scope of this course:\ncontinuous integration, project management (agile methodology, bug tracking, etc.), advanced git workflows, advanced design patterns, dependency injection, etc. Quizzes # Some lectures will include quizzes. These are anonymous, and therefore are not part of your evaluation. The purpose is to:\nmake lectures more interactive, and adapt the pace of the lectures based on students\u0026rsquo; answers. It is in your own interest to answer them without external resources (web, chatbots, IDE, etc.).\nHere is a link to the first quiz: https://forms.gle/7Y2MpzE7v5xzUJFy7.\nTopics covered # Due to limited time, many notions (such as asymptotic cost, regular languages, hash tables or multi-threading) are only briefly introduced in this course. However, some of them will be further discussed in other courses of the bachelor.\nProgramming techniques # An important part of the lectures is dedicated to the following core topics:\nobjects, classes and interfaces (inheritance, encapsulation, value vs reference, comparing objects, cloning objects, etc.), abstract data types (set, list, associative array, queue, etc.) and data structures (array, linked list, hash table, etc.), recursion. In addition, the following will be (briefly) introduced:\ngenerics, mutability, pure functions, lambda expressions and streams, multi-threading. Note. Some of these topics pertain to functional programming, but have been incorporated (in some form) to several imperative languages over the years.\nSoftware engineering # unit tests, exceptions, code factorization. Java # compilation/interpretation, bytecode, JVM and JDK, input/output, object serialization, JSON/XML serialization. Tools and tutorials # git, build automation (Maven and Gradle), using an IDE, using a terminal efficiently (introduction), etc. "},{"id":34,"href":"/docs/objects/sections/methods/","title":"Instance methods","section":"Objects and classes","content":" Instance methods # In most object-oriented languages (like Java), methods are implemented within class declarations.\nAn instance method can only be called using an instance of the class where it is declared.\nFor instance, in Java, an instance method declared in MyClass can be called by appending . to a variable of type MyClass. The object referenced by the variable is accessible in the method, as well as its attributes.\nThis intuitively allows us to write methods with one less argument. For instance, consider the following method, which is not and instance method. It verifies whether two instance of MobileUnit have the same color:\npublic boolean sameColor(MobileUnit u1, MobileUnit u2){ return u1.color.equals(u2.color); } This method may be called as follows:\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); Butterfly myButterfly = new Butterfly(\u0026#34;green\u0026#34;); boolean sameColor = sameColor(myUnicorn, myButterfly); Instead, one may write an equivalent method, as an instance method of our class MobileUnit, with one less argument:\npublic abstract class MobileUnit extends Unit { String color; ... public boolean sameColorAs(MobileUnit otherUnit){ return color.equals(otherUnit.color); } } and we can call this method as follows:\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); Butterfly myButterfly = new Butterfly(\u0026#34;green\u0026#34;); boolean sameColor = myUnicorn.sameColorAs(myButterfly); } Overriding # A same instance method can be declared in a class C and a subclass S or C. In this case, we say that S overrides the method.\nWhen such a method is called, the most specific applicable version is executed.\nFor instance, let us extend our example from the previous section with a method regen, declared in both Unit and MobileUnit, as follows:\npublic abstract class Unit { int health; ... public void regen(){ if(health \u0026lt; 10){ health += 1; } } } public abstract class MobileUnit extends Unit { ... public void regen(){ if(health \u0026lt; 10){ health += 1; } health += 1; } } Now consider this program.\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); myUnicorn.regen(); This program increases the health of (the object referenced by) myUnicorn by 2, because Unicorn is a subclass of MobileUnit. However, the following program increases the health of (the object referenced by) myWall by 1, because Wall is a subclass of Unit, but not a subclass of MobileUnit.\nWall myWall = new Wall(); myWall.regen(); Hint. In Java, you can use the annotation @Override to indicate that a method overrides another, as follows:\npublic abstract class MobileUnit extends Unit { ... @Override public void regen(){ if(health \u0026lt; 10){ health += 1; } health += 1; } } This is not necessary. The benefit is that the program will not compile if the overridden and overriding methods have different signatures.\nMore generally, syntactic mistakes (a.k.a. compile time errors) are easier to fix than bugs (a.k.a. runtime errors). So when possible, it is good practice to use features of a language that prevent compilation if incorrect programs. This is why debugging in an untyped language (like Python, Javascript, Lua, etc.) can be more difficult than in a typed one (such as Java, C#, Typescript, etc.).\nDynamic dispatch (a.k.a. runtime polymorphism) # Dynamic dispatch consists in determining which version of a method must be called when a program is executed (a.k.a. \u0026ldquo;at run time\u0026rdquo;), when this cannot be determined by analyzing the program alone. This is a feature of most (class-based) object-oriented languages.\nFor instance, in our example, assume a method generateRandomUnits that generates a random array of units (butterflies, unicorns or walls). And let us call the method regen for each unit in this array:\nUnit[] ramdomUnits = generateRandomUnits(); for (Unit unit: randomUnits){ unit.regen(); } The most specific applicable version of the method regen will be executed for each unit, based on its type, even though this type cannot be determined at compile time. For instance, if there is an instance of Unicorn in this array, then the method MobileUnit.regen() will be executed for this instance (rather than the method Unit.regen()).\nCode factorization # An overriding method often extends the functionality of the overridden one. This is a possible source of duplicate code. For instance, in the example above, both implementations of regen() contain:\nif(health \u0026lt; 10){ health += 1; } A common way to factorize this consists in calling the overridden method inside the overriding one. In Java, the keyword super allows us to distinguish the two methods (since they have the same name). For instance, in the above example, the overriding method may be better written as follows:\npublic abstract class MobileUnit extends Unit { ... public void regen() { super.regen(); health += 1; } } Exercise In this example, what would be the effect of replacing super.regen() with regen()?\nSolution The method would not terminate.\nExercise Consider the method encounter of the previous section. Add it as an instance method to our example, so that:\nthe method now distinguishes the attacker from the defender, a wall cannot attack, a unicorn gets a regen if it defends. Possible solution The trick here consists in viewing an encounter from the point of view of the defender:\npublic abstract class Unit { int health; ... public void defend(MobileUnit attacker) { // save the initial value of the first unit\u0026#39;s health int copy = health; health -= attacker.health; attacker.health -= copy; } } public class Unicorn extends Unit { ... public void defend(MobileUnit attacker) { regen(); super.defend(attacker); } } "},{"id":35,"href":"/docs/multithreading/sections/race/","title":"Race condition","section":"Multithreading","content":" Race condition # Definition. A race condition occurs when the outcome of a program may vary depending on the order in which two threads access a resource.\nIllustrations # Example. The following program (in pseudocode) apparently increments variable i twice. However, it may output either 1 or 2, depending on the execution environment:\nint i = 0 spawn i++ i++ sync print(i) The reason is that a core does not increment the value of a variable as an atomic operation. Instead, an increment is a sequence of three instructions:\nread the value of i and fetch it to one of the core\u0026rsquo;s registers increment the value of this register write the register\u0026rsquo;s value back to memory If a context switch occurs during the execution of these three operations, or if the two threads are executed in parallel (i.e. on different cores), then the outcome may be unexpected. Among other possibilities, the following may happen:\nthe current thread executes step 1, copying the value 0 from memory to a register, then the child thread executes step 1 as well, copying the value 0 to another register, then the current thread executes steps 2 and 3, writing the value 1 back to memory, then the child thread executes step 2 and 3, writing the value 1 back again to memory. However, the following sequence of actions would (for instance) produce the expected result:\nthe current thread executes steps 1, 2 and 3, then the child thread executes steps 1, 2 and 3. Note. A race condition can only occur if:\ntwo threads access a same resource, and at least one of them modifies it. Example. The following algorithm performs a matrix by vector multiplication with a \u0026ldquo;parallel\u0026rdquo; loop, and is free of race conditions:\nproduct(int[][] M, int[] v){ int[] w = new int[M.length] for parallel (int i = 0; i \u0026lt; M.length; i++){ for (int j = 0; j \u0026lt; v.length; j++){ w[i] += M[i][j] * v[j] } } return w } However, adding the keyword parallel to the inner loop may yield an incorrect output.\nproduct(int[][] M, int[] v){ int[] w = new int[M.length] for parallel (int i = 0; i \u0026lt; M.length; i++){ for parallel (int j = 0; j \u0026lt; v.length; j++){ w[i] += M[i][j] * v[j] } } return w } The reason is that two threads may now modify the value of w[i] concurrently, for the same i (but different values of j).\nNon determinism # Warning. In general, a bug caused by a race condition cannot be consistently reproduced, even on the same hardware.\nThis is why race conditions are notoriously difficult to identify and/or debug, even for programs that has been extensively tested (a famous example of a race condition with a dramatic impact is the Northeastern United States blackout of 2003).\nCaution # Multithreading is a good example (together for instance with caching the results of a computation) of an error-prone optimization technique, which may impact on code readability and correctness.\nA common mistake made by less experienced developers is to use multithreading \u0026ldquo;because we can\u0026rdquo;.\nInstead, it is often recommended to use multithreading cautiously, and only if some bottleneck has been identified in an application (e.g. with a profiler): unacceptable processing time, non-responsive GUI, etc.\nWe reproduce here three (loosely) related citations made in Effective Java (Item 67, \u0026ldquo;Optimize judiciously\u0026rdquo;):\nMore computing sins are committed in the name of efficiency (without necessarily achieving it) than for any other single reason—including blind stupidity.\nWilliam A. Wulf, 1972\nWe should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.\nDonald Knuth, 1974\nWe follow two rules in the matter of optimization: Rule 1. Don’t do it. Rule 2 (for experts only). Don’t do it yet — that is, not until you have a perfectly clear and unoptimized solution.\nM. A. Jackson, 1975\n"},{"id":36,"href":"/docs/multithreading/sections/synchronization/","title":"Synchronization","section":"Multithreading","content":" Synchronization # The behavior of a program that runs multiple threads can be hard to predict. In particular, two threads may compete to access a same resource (e.g. the value of some object\u0026rsquo;s attribute), without guarantee on the order in which they access it. This may lead (among other things) to a race condition\nProgramming languages that support multithreading also allow expressing constraints on the order of execution of some instructions. For instance, we saw earlier that a thread can be forced to wait for a child thread to terminate before resuming its execution.\nIn this section, we review two additional mechanisms (mutual exclusion and condition variables) that allow synchronizing the behaviors of threads.\nFor a more exhaustive overview of the possibilities offered by Java in that regard, we refer to the Javadoc of the package java.util.concurrent, which summarizes the situations where a Java statement must be executed before another (in Java\u0026rsquo;s terminology, this binary relation over statements is called the \u0026ldquo;happens before\u0026rdquo; relation).\nMutual exclusion # Mutual exclusion prevents two threads to access a same resource concurrently. This is generally achieved via some kind of lock (sometimes called a mutex or semaphore).\nMost programming languages that support concurrency provide mechanisms for mutual exclusion. These languages include C/C++, C#, Go, Java, PHP, Python, or Rust.\nin Java # Java associates to each object a so-called intrinsic lock (also called monitor lock or simply monitor).\nIf a thread $t_1$ acquires the intrinsic lock of an object, then a different thread $t_2$ cannot acquire this lock until $t_1$ has released it (however, a thread can reacquire a lock that it already owns).\nThe Java keyword synchronized enforces mutual exclusion via an intrinsic lock. In can be used in two ways:\nSynchronized statement # A synchronized statement associates an object $o$ to a block of code (called a synchronized block).\nA thread that enters this block acquires the intrinsic lock of $o$, and releases it when exits the block.\nThe syntax is the following:\nsynchronized(\u0026lt;object\u0026gt;){ \u0026lt;code block\u0026gt; } Example. Consider the two following classes:\npublic class Counter { int value; public Counter(int value){ this.value = value; } } public class Lock { } The method increment below uses an instance of Lock to ensure that a counter is only incremented by one thread at a time:\nvoid increment(Counter counter, Lock lock){ synchronized(lock){ counter.value++; } } As a result, the following program is free of race condition:\nCounter counter = new Counter(0); Lock lock = new Lock(); Thread t1 = new Thread( () -\u0026gt; { increment(counter, lock); } ); Thread t2 = new Thread( () -\u0026gt; { increment(counter, lock); } ); t1.start(); t2.start(); Observe that in the example above, any object could be used as a lock. In particular, the object counter itself. So the program below is equivalent:\nvoid increment(Counter counter){ synchronized(counter){ counter.value++; } } Counter counter = new Counter(0); Thread t1 = new Thread( () -\u0026gt; { increment(counter); } ); Thread t2 = new Thread( () -\u0026gt; { increment(counter); } ); t1.start(); t2.start(); Synchronized method # A synchronized instance method uses the intrinsic lock of the object for which this method is called.\nThe syntax is the following:\npublic synchronized int myMethod() { ... } In other words, the two following classes are equivalent:\npublic class MyClass { synchronized void myMethod(){ \u0026lt;method body\u0026gt; } } public class MyClass { void myMethod(){ synchronized(this){ \u0026lt;method body\u0026gt; } } } Warning. A constructor cannot be synchronized (the program will not compile).\nObservation. Let $m$ be a synchronized instance method, let $o$ be an object, let $t_1$ and $t_2$ be two different threads, and let us assume that $t_1$ executes $o.m$ (i.e. $t_1$ executes the method $m$ for the object $o$).\nThen $t_2$ cannot execute any synchronized method for $o$ before the termination of $o.m$\nObservation. For the same object, a synchronized method can call another, as long as they are executed by the same thread.\nExercise What are the possible outputs of the following program?\npublic class Counter { int value; public Counter(int value){ this.value = value; } synchronized void inc(int delta){ value += delta; } synchronized void doubleDec(int delta){ value -= delta; value -= delta; } int getValue(){ return value; } } Counter counter = new Counter(0); Thread t1 = new Thread( () -\u0026gt; { counter.inc(5); } ); t1.start(); Thread t2 = new Thread( () -\u0026gt; { counter.doubleDec(2); } ); t2.start(); System.out.println(counter.getValue()); try { t1.join(); t2.join(); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(counter.getValue()); Solution Because the two methods inc and doubleDec are synchronized (and are called on the same object), their executions cannot interleave. This guarantees that the second print statement must output 1.\nAs for the first print statement, observe that:\nthere is no guarantee on the order of execution of counter.inc(5), counter.doubleDec(2) and the first call to counter.getvalue(). the method getValue() is not synchronized, so the first call to counter.getvalue() this method may be executed during the execution of counter.inc(5) or counter.doubleDec(2). So the possible output values here are 0, 5, 3, 1, -2 and -4.\nA synchronized static method uses the intrinsic lock of the object that represents the class itself (this object is an instance of Class).\nIn other words, the two following classes are equivalent:\npublic class MyClass { static synchronized void myMethod(){ \u0026lt;method body\u0026gt; } } public class MyClass { static void myMethod(){ synchronized(Class.forName(\u0026#34;my.project.name.MyClass\u0026#34;)){ \u0026lt;method body\u0026gt; } } } Condition variables # We saw earlier that a thread $t_1$ can wait for another thread $t_2$ to terminate (e.g. with the pseudocode keyword sync, or with the Java instance method Thread.join).\nIn this case, when it terminates, $t_2$ wakes up $t_1$, which can resume its execution.\nA similar but more flexible mechanism is the notion of condition variable. Intuitively, it allows putting a thread to sleep, and waking it up when a certain condition is verified.\nA variety of programming languages support condition variables. These include C++, C#, Go, Java, Python or Rust.\nThe producer/consumer pattern # A prototypical application of condition variables is the so-called producer/consumer pattern. In this scenario, two pools of threads (usually with fixed sizes) communicate via a queue.\nA pool of producer threads, which create elements and add (a.k.a. enqueue) them to the queue, A pool of consumer threads, which receive (a.k.a dequeue) these elements and process them. Two situations may occur where threads should be put to sleep:\nthe queue is empty (e.g. because the process just started, or because elements have been consumed faster than they were produced): consumers should be put to sleep until a new element is produced. the queue is full (e.g. because elements have been produced faster than they were consumed): producers should be put to sleep until an element is consumed. in Java # Reminder. As discussed above, a thread can acquire the intrinsic lock of an object by:\nentering a synchronized block that has this object as lock, or executing a synchronized method for this object. A condition variable in Java can be simulated thanks to he method Object.wait, together with the method Object.notify (or Object.notifyAll).\nwait # The instance method Object.wait can only be called by a thread that acquired the intrinsic lock of the object. It has the effect of releasing this lock, and putting the current thread to sleep, until another thread executes the method notify (or notifyAll) for this same object.\nnotify # Similarly to Object.wait, the instance method Object.notify can only be called by a thread that acquired the intrinsic lock of the object. It has the effect of attempting to wake up one thread (if any) that is waiting for the lock of this object. The awakened thread will only proceed (i.e. actually wake up) after the notifying thread releases the lock of the object.\nnotifyAll # The instance method Object.notifyAll is identical to Object.notify, but attempts to wake up all threads that are waiting for the lock of this object.\nExample. For simplicity, we will use a queue with a capacity of 1. The example is borrowed from the Oracle tutorials.\npulic class MyQueue\u0026lt;T\u0026gt; { T item; boolean isEmpty = true; synchronized void enqueue(T item){ while(!isEmpty){ try { wait(); } catch (InterruptedException e) {} } isEmpty = false; this.item = item; notifyAll(); } } When a producer thread $p$ executes the method enqueue, it acquires the intrinsic lock of the queue (because the method is synchronized). If the queue is full, it releases the lock and waits for a consumer thread to wake it up. If this happens, thread $p$:\nadds the produced item to the queue, indicates that the queue should now be considered full, wakes up a consumer thread (if any) waiting for the queue to be empty, releases the intrinsic lock on the queue (by exiting the synchronized method). The method dequeue is symmetric:\npublic class MyQueue\u0026lt;T\u0026gt; { ... synchronized T dequeue(){ while(isEmpty){ try { wait(); } catch (InterruptedException e) {} } isEmpty = true; notifyAll(); return item; } } Producer threads could be implemented as follows:\npublic class Producer implements Runnable { private MyQueue\u0026lt;Item\u0026gt; queue; public Producer(MyQueue\u0026lt;Item\u0026gt; queue){ this.queue = queue; } @Override public void run() { while(true){ queue.enqueue(produceItem()); } } Item produceItem(){ ... } } And consumer threads could be implemented as follows:\npublic class Consumer implements Runnable { private MyQueue\u0026lt;Item\u0026gt; queue; public Consumer(MyQueue\u0026lt;Item\u0026gt; queue){ this.queue = queue; } @Override public void run() { while(true){ consumeItem(queue.dequeue()); } } void consumeItem(Item item){ ... } } Finally, the main thread may for instance spawn one producer and two consumers:\nMyQueue\u0026lt;Item\u0026gt; queue = new MyQueue\u0026lt;\u0026gt;(); Thread p1 = new Thread(new Producer(queue)); Thread c1 = new Thread(new Consumer(queue)); Thread c2 = new Thread(new Consumer(queue)); p1.start(); c1.start(); c2.start(); Spurious wakeup # In the example above, the loop while(!isEmpty) (in the method enqueue) seems unnecessary, in the sense that it could be replaced with the conditional statements if(!isEmpty). And similarly for the loop in the method dequeue.\nThe purpose of this loop is to handle the abnormal case where a consumer (resp. producer) is awaken while the condition variable isEmpty has value false (resp. true). Such a situation is called a spurious wakeup, and may have a variety of causes (including a race condition).\nThis is the reason why it is customary to write:\nwhile(\u0026lt;conditionVariable\u0026gt;){ wait(); } rather than:\nif(\u0026lt;conditionVariable\u0026gt;){ wait(); } "},{"id":37,"href":"/docs/stream/sections/terminal/","title":"Terminal operation","section":"Streams in Java","content":" Terminal operation # A stream pipeline contains one terminal operation.\nThis operation may for instance:\nexecute a method for each element of the stream (e.g. print the value of each of them), or collect these elements (e.g. into a list), or inspect these elements (check whether all of them satisfy a certain condition), or aggregate these elements (e.g. sum the values of a stream of integers). Stream.forEach # This instance method is similar to Stream.map, in the sense that it also applies a callback method to each element of the stream. However, in this case, the callback method is not a function (i.e. it has no return value).\nIn other words, if the stream has type Stream\u0026lt;$\\mathit{T}$\u0026gt;, then foreach takes as argument a callback method of type\n$\\qquad \\mathit{T} \\to$ void\n(equivalently, in Java\u0026rsquo;s terminology, the callback method must implement the native functional interface Consumer\u0026lt;$\\mathit{T}$\u0026gt;, seen earlier).\nExample.\nList\u0026lt;Integer\u0026gt;list = List.of(4, 1, 3, 2, 4); // outputs `4, `2` and `4` list.stream() .filter(x -\u0026gt; x % 2 == 0) .forEach(System.out::println); Hint. In the absence of intermediate operation, the instance method Collection.forEach can be used instead, with the same effect:\nList\u0026lt;Integer\u0026gt;list = List.of(4, 1, 3, 2, 4); // ouputs `4`, `1`, `3`, `2`, and `4` list.forEach(System.out::println); Collecting a stream # Stream.toList # This instance method outputs a final list with the elements of the stream.\nExample. We already used this method in several of our examples. For instance\nList\u0026lt;Integer\u0026gt;list = List.of(2, 1, 3, 1, 2); // Contains [1, 1, 2, 2, 3] List\u0026lt;Integer\u0026gt; ouputList = list.stream() .sorted() .toList(); Stream.collect # This instance method takes as argument a so-called Collector, which is in charge of collecting the elements of the stream into a Collection (e.g. List or Set, or a Map, or a String, etc.\nThe utility class Collectors provides a variety of static methods that return a collector.\nCollectors.joining # This static method returns a collector that concatenates a stream of strings. joining (optionally) take a string as argument, which is used to separate the concatenated elements in the output string.\nExample\nCity ancona = new City(\u0026#34;Ancona\u0026#34;, 60100); City bologna = new City(\u0026#34;Bologna\u0026#34;, 40100); City matera = new City(\u0026#34;Matera\u0026#34;, 75100); List\u0026lt;City\u0026gt; cities = List.of(ancona, bologna, matera); // Contains the string `Ancona:Bologna:Matera` String concat = cities.stream() .map(c -\u0026gt; c.name) .collect(Collectors.joining(\u0026#34;:\u0026#34;)); Exercise The method Files.list(path) takes as argument a path to a directory, and returns an instance of Stream\u0026lt;Path\u0026gt;, whose elements are the entries in the directory.\nWhat does the method mysteriousMethod below return?\nString mysteriousMethod(Path path) throws IOException { if(!Files.isDirectory(path)) { return \u0026#34;\u0026#34;; } return Files.list(path) .filter(p -\u0026gt; path.toString().endsWith(\u0026#34;.txt\u0026#34;)) .flatMap(p -\u0026gt; readLines(p)) .filter(l -\u0026gt; l.contains(\u0026#34;foo\u0026#34;)) .collect(Collectors.joining(System.lineSeparator())); } Stream\u0026lt;String\u0026gt; readLines(Path path){ try { return Files.lines(path); } catch (IOException e) { throw new RuntimeException(e); } } Solution A string that consists of all lines that contain the string foo in any .txt file of the directory.\nCollectors.toCollection # This static method takes as argument the constructor of a Java collection (e.g. HashSet::new, TreeSet::new, ArrayList::new, etc.), and returns a collector for this type of collection.\nList\u0026lt;Integer\u0026gt;list = List.of(2, 1, 3, 1, 2); // This is the TreeSet {1, 2, 3} Set\u0026lt;Integer\u0026gt; ouputSet = list.stream() .collect(Collectors.toCollection(TreeSet::new)); Collectors.toSet # As we saw in our initial pipeline example, this static method takes no argument, and returns a collector that produces a Java Set.\nThe Java specification does not require a specific implementation. So this set could for instance be a HashSetor a TreeSet, depending on the Java Virtual Machine that executes the program.\nList\u0026lt;Integer\u0026gt;list = List.of(2, 1, 3, 1, 2); // Contains {1, 2, 3} Set\u0026lt;Integer\u0026gt; ouputSet = list.stream() .collect(Collectors.toSet()); Collectors.toList # This static method is analogous to Collectors.toSet, but the collector that it returns produces a Java List. Again, there is no requirement on the specific implementation of this list.\nCollectors.toMap # This static method is analogous to Collectors.toSet and Collectors.toList, but the collector that it returns produces a Java Map.\nIf the stream has type Stream\u0026lt;$\\mathit{T}$\u0026gt;, then toMap takes as argument two callback functions, of type\n$\\qquad \\mathit{T} \\to K$\nand\n$\\qquad \\mathit{T} \\to V$\nrespectively, where $K$ and $V$ are arbitrary types.\nThe first callback method defines the keys of the map, and the second defines the values.\nExample. The following method takes a list of cities, and returns a map from city name to city.\nMap\u0026lt;String, City\u0026gt; buildMap(List\u0026lt;City\u0026gt; cities){ return cities.stream() .collect(Collectors.toMap( c -\u0026gt; c.name, c -\u0026gt; c )); } Warning. This method may throw an exception at runtime, in case of conflicting keys (in other words, if the first callback function is not injective). To make it robust, it is possible to pass it a third callback method, in charge of solving conflicts.\nCollectors.groupingBy # This static method returns a collector that groups the elements of the stream, based on some input grouping criterion. The grouping criterion is specified as a callback function.\nExample. The following method take a list of units as argument, and returns a map from a color to a list of units that share this color:\nMap\u0026lt;String, List\u0026lt;Unit\u0026gt;\u0026gt; groupByColor(List\u0026lt;Unit\u0026gt; units){ return units.stream() .collect(Collectors.groupingBy(u -\u0026gt; u.color)); } If the stream has type Stream\u0026lt;$\\mathit{T}$\u0026gt;, then Collectors.groupingBy takes as argument a callback function of type\n$\\qquad \\mathit{T} \\to K$\nwhere $K$ is an arbitrary type. This callback function computes a key for each element of the stream.\ngroupingBy returns a map with type Map\u0026lt;$K$, List\u0026lt;$T$\u0026gt;\u0026gt; that maps each key to the list of elements that share this key.\nAlternatively, groupingBy may be called with a Collector as second argument, which aggregates the elements of each list.\nExample. The following method take a list of units as argument, and returns a map from color to number of units that share this color.\nMap\u0026lt;String, Long\u0026gt; groupByColor(List\u0026lt;Unit\u0026gt; units) { return units.stream() .collect(Collectors.groupingBy( u -\u0026gt; u.color, Collectors.counting() )); } Boolean checks # Stream.anyMatch # This instance method checks whether at least one element in the stream satisfies a certain Boolean condition.\nSimilarly to the method filter, if the stream has type Stream\u0026lt;$\\mathit{T}$\u0026gt;, then anyMatch takes as argument a callback function of type\n$\\qquad \\mathit{T} \\to$ Boolean\nwhich specifies the Boolean condition.\nWarning. anyMatch is a short-circuiting operation, meaning that the stream is interrupted after the first match (if any).\nExample. The following two programs are equivalent:\nList\u0026lt;Integer\u0026gt; integers = getIntegers(); boolean containsEvenNumber = integers.stream() .anyMatch(x -\u0026gt; x % 2 == 0); $\\qquad$\nList\u0026lt;Integer\u0026gt; integers = getIntegers(); boolean containsEvenNumber = false; for(int x : integers){ if(x % 2 == 0){ containsEvenNumber = true; break; } } Coding style. Programs with multiple break statements can be difficult to read and/or debug. A stream with a short-circuiting operation (like anyMatch) can be a way to avoid them.\nExercise What does the method mysteriousMethod below return?\nList\u0026lt;Path\u0026gt; mysteriousMethod(Path path) throws IOException { if (!Files.isDirectory(path)) { return List.of(); } return Files.list(path) .filter(p -\u0026gt; path.toString().endsWith(\u0026#34;.txt\u0026#34;)) .filter(p -\u0026gt; readLines(p).anyMatch(l -\u0026gt; l.contains(\u0026#34;foo\u0026#34;))) .toList(); } Stream\u0026lt;String\u0026gt; readLines(Path path){ try { return Files.lines(path); } catch (IOException e) { throw new RuntimeException(e); } } Solution The list of all .txt files in the input directory that contain the string foo.\nStream.allMatch # This instance method is analogous to Stream.anyMatch, but checks whether all elements in the stream satisfy the Boolean condition.\nThis is also a short-circuiting operation (if an element does not satisfy the criterion).\nAggregation # Stream.findFirst # This instance method returns the first element in the stream.\nThis is a short-circuiting operation.\nIn combination with Stream.filter, it can simulate Stream.anyMatch.\nExample The following two programs are equivalent:\nList\u0026lt;Integer\u0026gt; integers = getIntegers(); Optional\u0026lt;Integer\u0026gt; firstEvenNumber = integers.stream() .filter(x -\u0026gt; x % 2 == 0) .findFirst(); $\\qquad$\nList\u0026lt;Integer\u0026gt; integers = getIntegers(); Optional\u0026lt;Integer\u0026gt; firstEvenNumber = Optional.empty(); for(int x : integers){ if(x % 2 == 0){ firstEvenNumber = Optional.of(x); break; } } Stream.count # This instance method returns the size of the stream.\nExample.\nList\u0026lt;Integer\u0026gt;list = List.of(2, 1, 3, 1, 2); // has value 2 int size = list.stream() .filter(x -\u0026gt; x % 2 == 0) .count(); Stream.max # This instance method takes as argument a Comparator, and returns (one of the) maximal element(s) in the stream w.r.t. this comparator (if any).\nExample.\nCity ancona = new City(\u0026#34;Ancona\u0026#34;, 60100);, City bologna = new City(\u0026#34;Bologna\u0026#34;, 40100);, City matera = new City(\u0026#34;Matera\u0026#34;, 75100);, List\u0026lt;City\u0026gt; cities = List.of(ancona, bologna, matera); // Contains matera Optional\u0026lt;City\u0026gt; selectedCity = cities.stream() .max((c1, c2) -\u0026gt; c1.zipCode - c2.zipCode); Stream.reduce # This instance method aggregates the elements of the stream based on a binary operator $\\circ$.\nFor instance, $\\circ$ could be + or * for a stream of numbers, or concatenation for a stream of strings.\nAs an illustration, if the stream has elements\n$\\qquad (a, b, c, d)$\nthen the method reduce returns\n$\\qquad (((a \\circ b) \\circ c) \\circ d)$\nLet us assume that the stream has type Stream\u0026lt;$\\mathit{T}$\u0026gt;. The method reduce takes two arguments:\na neutral element for the operator $\\circ$, i.e. a value $a$ such that $a \\circ x = x$ for any $x \\in T$. For instance,\n$0$ is the neutral element for $+$, $1$ is the neutral element for $*$, \u0026quot;\u0026quot; is the neutral element for string concatenation, etc. the binary operator $\\circ$, specified as a callback function.\nExercise What is the type of this callback function?\nSolution $\\qquad T \\times T \\to T$\nExample.\nList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3); // Has value 24 int product = numbers.stream() .reduce(1, (subtotal, element) -\u0026gt; subtotal * element); "},{"id":38,"href":"/docs/intro/sections/board_game/","title":"Board game","section":"This course","content":" Board game # In order to follow this course, you will need to play one of the two following video games:\nMight \u0026amp; Magic: Clash of Heroes, or Legend of Solgard. These two games have nearly identical mechanics. So by default, we will refer to them as a unique game (e.g. when we write \u0026ldquo;this game\u0026rdquo; or \u0026ldquo;our board game\u0026rdquo;).\nWhy this game # Turn-based board games (like chess, go, checkers, etc.) are traditionally a good playground to learn the basics of algorithmic thinking.\n**_Disclaimer._** This course is _not_ about video game development, but general-purpose programming. This game will only serve as _didactic support_. Precisely, this game will serve two purposes:\nwe will use it as a running example throughout the lectures, and students can choose to implement (their own version of) this game as their group project. By default, we will focus on the two player variant, where both players play by the same rules. These two players may be humans and/or bots.\nHow long to play # Students only need to play long enough to understand the basic mechanics of the game.\n1.5 to 2 hours should be sufficient.\n**_Warning._** In both games, mechanics are introduced gradually, so it is difficult to get a full overview by playing less than an hour. Which game to choose # Might and Magic clash of heroes (MMCoH) # This game was initially released in 2009 for Nintendo DS. It has then been ported to PC and several consoles, as well as Android and iOS.\nA free demo was available on Steam until July 2023. The game has been re-released since, by another editor. As a result, the demo is not available on Steam anymore.\nThe Android and iOS versions have also been removed from the Google Play store and App store respectively.\n**_Advantages._** - The mechanics of this game may be easier to understand (in a short amount of time). - The default mode is the (symmetric) 2 player mode (player vs bot or player vs player) that we will work on. **_Drawbacks._** - The touch-screen interface on Android and iOS is arguably dated. Legend of Solgard # This game was released in 2016 for Android and iOS. It is still available on the Google Play store and the App store.\nIt is free to play, with optional microtransactions (via so-called loot boxes).\n**_Warning._** For this course, _no_ transaction is needed. **_Advantages._** - Animations can be sped up. - The touch-screen interface is more modern than the one of MMCoH for Android and iOS. **_Drawbacks._** - Progression is based on a (complex) system of virtual currencies, which adds noise to the interface. - The game can only be played (for free) a limited amount of time per day (approximately 45 min). - The default mode is _not_ the (symmetric) 2 players mode that we will work on (it requires more playtime to be unlocked). So an extra effort of imagination may be needed. "},{"id":39,"href":"/docs/objects/sections/tostring/","title":"Displaying objects","section":"Objects and classes","content":" Displaying objects # The class Object # Java has a native class called Object with 11 instance methods. Every Java class implicitly extends Object, including user-defined classes. Therefore any Java class inherits these methods.\nThe method toString # toString is one of the methods of the class Object. Here is (part of) its specification:\n/** Returns a string representation of the object. * In general, the toString method returns a string that * \u0026#34;textually represents\u0026#34; this object. */ public String toString(); This is the preferred way to display information about an object. For instance, the debugger of your IDE probably relies on this method to display a string that represents an object.\nThis method is also called by many (native or not) methods and operators. For instance, the following program\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); System.out.println(myUnicorn); String message = \u0026#34;Hello \u0026#34; + myUnicorn; is equivalent to\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); System.out.println(myUnicorn.toString()); String message = \u0026#34;Hello \u0026#34; + myUnicorn.toString(); Overriding toString # The default implementation of toString (in the class Object) displays very little information about the object:\npublic String toString() { return getClass().getName() + \u0026#34;@\u0026#34; + Integer.toHexString(hashCode()); } Warning. The output of hashCode() in this example is not the reference (a.k.a. \u0026ldquo;memory address\u0026rdquo;) of the object.\nSo a common practice consists in overriding toString. For instance, here is a possible implementation of the method toString within a class Unicorn:\npublic class Unicorn { String color; int health; @Override public String toString() { return \u0026#34;Unicorn{\u0026#34; + \u0026#34;color=\u0026#34; + color + \u0026#34;, \u0026#34; + \u0026#34;health=\u0026#34; + health + \u0026#34;}\u0026#34;; } } Hint. Your IDE can generate such a method.\nRecursion # A naive implementation of toString (e.g. generated by an IDE) may have unexpected effects.\nExercise Consider an implementation of our game where units (on each side of the board) are grouped by column. This implementation may use a class Column to represent a column and the adjacent one(s), as follows:\npublic class Column { Unit[] units; // null if this is the left-most column Column leftAdjacentColumn; // null if this is the right-most column Column rightAdjacentColumn; public Column(Unit[] units){ this.units = units; } @Override public String toString() { return \u0026#34;Column{\u0026#34; + \u0026#34;left=\u0026#34; + leftAdjacentColumn +\u0026#34;, \u0026#34; + \u0026#34;right=\u0026#34; + rightAdjacentColumn +\u0026#34;, \u0026#34; + \u0026#34;units=\u0026#34; + units + \u0026#34;}\u0026#34;; } } Then a board may be created as follows:\nUnit[] a1 = new Unit[]{ new Unicorn(\u0026#34;green\u0026#34;) }; Column c1 = new Column(a1); Unit[] a2 = new Unit[]{ new Butterfly(\u0026#34;yellow\u0026#34;) }; Column c2 = new Column(a2); c1.rightAdjacentColumn = c2; c2.leftAdjacentColumn = c1; System.out.println(c1); There is an issue with this program. Can you identify it?\nSolution The program does not terminate, because toString is (implicitly) recursive, and each of the two columns refers to the other.\n"},{"id":40,"href":"/docs/unittests/sections/junit/","title":"in Java","section":"Unit tests","content":" Unit tests in Java # Several frameworks are available in Java for unit tests. Popular frameworks include:\nJUnit 4 JUnit 5 TestNG Spock In this section, we focus on Junit 5.\nInstall Junit 5 with Maven # Junit 5 can be used in a Maven project by declaring the following dependency and plugin\n\u0026lt;dependencies\u0026gt; ... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.10.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; ... \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; ... \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-surefire-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.5\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; ... \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; For the latest versions, search Maven Central.\nDirectory layout # Maven # Recall that in a Maven project, by default:\nsource code for unit tests is located in the directory src/test/java, resources for unit tests (e.g. data) are located in the directory src/test/resources. Note. You can create sub-directories (in these directories) to organize your tests and resources.\nGradle # Junit 5 can be used with Gradle in a similar way, but the directories for unit tests and related resources and (usually) specified manually.\nHint. If you chose the board game as your project, then you can write JUnit 5 tests under core/src/test/java. You will also find (dummy) unit tests in the directory core/src/test/java/dummy.\nWriting unit tests # With Maven, any (public or protected) Java class in src/test/java (or a subdirectory) can contain JUnit tests.\nA Junit 5 test is a (public or protected) instance method :\nwith void return type, annotated with org.junit.jupiter.api.Test. In addition, the method usually contains one or several calls to static methods of JUnit\u0026rsquo;s Assertions class, like assertEquals or assertThrows. The test succeeds iff all these calls return true.\nFor instance, the following class contains a single (successful) test:\nimport org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class MyTests { @Test void myTest(){ String myString = \u0026#34;foo\u0026#34;; assertEquals(true, myString.contains(\u0026#34;oo\u0026#34;)); } } Warning. The method assertEquals takes the expected value as first argument, and the actual one as second argument. This has an incidence on logs in case of test failure (\u0026ldquo;expected\u0026rdquo; : XXX, \u0026ldquo;actual: \u0026ldquo;YYY\u0026rdquo;);\nHint. A string can be passed to assertEquals as third argument, in order to display an additional message in case of failure.\nHint. Most methods of the class Assertions are syntactic sugar (thus not strictly necessary). For instance\nassertTrue(\u0026lt;myExpression\u0026gt;) is a shortcut for\nassertEquals(true, \u0026lt;myExpression\u0026gt;) Warning. By default, the execution of a test method is interrupted as soon as an assertion fails. So following instructions (for instance other assertions) will not be executed.\nChecking exceptions # The assertion assertThrows allows checking whether the execution of a piece of code method throws an exception of a given type. For instance the following unit test succeeds:\n@Test void testException(){ assertThrows( ArithmeticException.class, () -\u0026gt; { int x = 2 / 0; } ); } Prior and/or subsequent code # The annotation @BeforeAll (resp. @AfterAll) can be used to indicate that a (static) method must be executed (only once) before (resp. after) all unit tests in the class, regardless of test successes or failures. This can be used for costly operations, or for opening (resp. closing) a resource, like an connection or an input (resp. output) stream. For instance\nimport org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.Test; import java.sql.Connection; public class SQLTests { Connection myConnection; @BeforeAll static void openConnection(){ ... } @Test void test1(){ ... } @Test void test2(){ ... } @AfterAll static void closeConnection(){ ... } } Similarly the annotation @BeforeEach (resp. @AfterEach) can be used to indicate that a method must be executed before (resp. after) each unit test in the class. This can be convenient to avoid copy-pasting code. For instance\nimport org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; public class BoardgameTests { Snapshot testSnapshot; @BeforeEach void createTestSnapshot(){ testSnapshot = new DummySnapshot(); } @Test void test1(){ ... } @Test void test2(){ ... } } Disabling tests # A unit test can be disabled with the annotation @Disabled. As a result, it will be ignored by Maven, Gradle, and (to some extent) your IDE. For instance:\nimport org.junit.jupiter.api.Disabled; import org.junit.jupiter.api.Test; public class MyTests { @Test @Disabled void test1(){ ... } @Test void test2(){ ... } } Running unit tests # from the command line # For a Maven project, the command\nmvn test executes all phases that precede the test phase (e.g. compile and test-compile) in Maven\u0026rsquo;s default lifecycle, and then executes all unit tests under src/test/java.\nNote. The source code of unit tests (and related resources) is by default excluded form the output of the package phase (e.g. from the jar produced by Maven).\nNote. A unit test failure will prevent execution of Maven phases that are posterior to test. For instance\nmvn package does not produce the expected jar if a test fails.\nHowever, if needed, it is possible to execute a posterior Maven phase while skipping the unit tests, with the option -DskipTests. For instance:\nmvn package -DskipTests within an IDE # IDEs provide several ways to run unit tests, either:\nin isolation, or all tests within a class, or all tests within a package (including subpackages). For instance, with IntelliJ:\nclick on the green arrow to run a single unit test, click on the double green arrow to run all unit tests defined in the current class, right click on a folder and select \u0026ldquo;Run Tests\u0026rdquo; to run all tests in this package. Note. Within an IDE, a unit test can (and most often should) be run in debug mode. For instance, with IntelliJ, right-click on the green arrow and select \u0026lsquo;Debug\u0026rsquo;.\n"},{"id":41,"href":"/docs/stream/sections/numeric/","title":"Numeric stream","section":"Streams in Java","content":" Numeric stream # In addition to the interface Stream, Java 8 introduced the interface IntStream (resp. DoubleStream, LongStream) that represents a stream of (unboxed) int (resp. long, double).\nIt provides operations that are not available in Stream\u0026lt;Integer\u0026gt; (resp. Streanm\u0026lt;Double\u0026gt;, Stream\u0026lt;Long\u0026gt;).\nWarning. The interface IntStream (resp. DoubleStream, LongStream) does not extend the interface Stream.\nConversion # A instance of Stream\u0026lt;$T$\u0026gt; can be converted to an instance of IntStream (resp. DoubleStream, LongStream) with the instance method Stream.mapToInt.\nThis method takes as argument a callback method of type\n$\\qquad T \\to$ int\nthat converts each element of the stream to an int.\nExample.\nThe following method converts a list of cities into an IntStream that contains their zip codes.\nIntStream extractZipCodes(List\u0026lt;City\u0026gt; cities){ return cities.stream() .mapToInt(c -\u0026gt; c.zipCode); } Operations # Numeric streams provide operations that are not available in standard streams, such as sum and average.\n"},{"id":42,"href":"/docs/lambda/sections/type/","title":"Type of a method","section":"Callback methods and lambda expressions","content":" Type of a method # Terminology. The type (a.k.a. signature) of a method consists of:\nthe type(s) of its argument(s), and its return type. Notation. The type of a method is sometimes described analogously to the type of a mathematical function. For instance, consider the following Java method square:\nint square(int x){ return x * x; } This method takes as input an int, and returns an int.\nIn other words, this is a function with domain int and codomain int. This is written:\n$\\qquad$square$\\colon$ int $\\to$ int\nAnd the type of this function is\n$\\qquad$ int $\\to$ int\nSimilarly, we may use:\nint $\\times$ int $\\to$ int if the method takes two int and returns another, Unit $\\times$ int $\\to$ Unit if the method takes a Unit and an int (in that order) and returns a Unit, Unit[] $\\to$ void if the method takes an array of Units[] and returns nothing, etc. in Java # Syntactically, Java does not provide a method typing system like the one above. Instead, Java uses (abuses?) interfaces for this purpose.\nFunctional interface # A method type in Java is described with a so-called functional interface.\nSyntax. A Java functional interface is an interface with a single (standard) method.\nNote. In this definition, \u0026ldquo;standard\u0026rdquo; method stands for a method that does not have the default qualifier (\u0026ldquo;standard\u0026rdquo; interface methods are also called \u0026ldquo;abstract\u0026rdquo;).\nExample. The following is a functional interface, which describes the type Unit $\\times$ Integer $\\to$ Unit.\nAny method with type Unit $\\times$ Integer $\\to$ Unit implements this interface.\ninterface UnitPerIntegerToUnit { Unit myMethod(Unit unit, Integer x); } The name of a functional interface is irrelevant, as well as the name of its method (and the arguments of this method).\nExample. The following functional interface also describes the type Unit $\\times$ Integer $\\to$ Unit.\ninterface Just { Unit because(Unit we, Integer can); } A functional interface can be annotated with @FunctionalInterface. This will for instance cause a compilation error if the interface has more than one (non-default) method.\nExample.\n@FunctionalInterface interface UnitPerIntegerToUnit { Unit myMethod(Unit unit, Integer x); } Native functional interfaces # Java provides native (parameterized) functional interfaces for some frequent method types.\nWe highlight here a few of them:\nFunction # The functional interface Function\u0026lt;InputType, OutputType\u0026gt; stands for the type InputType $\\to$ OutputType. Its method is called apply.\nExamples.\na method with type Unit $\\to$ Integer implements the functional interface Function\u0026lt;Unit, Integer\u0026gt; a method with type Unit $\\to$ Unit implements the functional interface Function\u0026lt;Unit, Unit\u0026gt; Consumer # The functional interface Consumer\u0026lt;InputType\u0026gt; stands for the type InputType $\\to$ void. Its method is called accept.\nExamples.\na method with type Integer $\\to$ void implements the functional interface Consumer\u0026lt;Integer\u0026gt; a method with type Unit $\\to$ void implements the functional interface Consumer\u0026lt;Unit\u0026gt; Supplier # The functional interface Supplier\u0026lt;OutputType\u0026gt; stands for the type void $\\to$ OutputType. Its method is called get.\nExamples.\na method with type void $\\to$ Integer implements the functional interface Supplier\u0026lt;Integer\u0026gt; a method with type void $\\to$ Unit implements the functional interface Supplier\u0026lt;Integer\u0026gt; Comparator # The interface Comparator\u0026lt;T\u0026gt; (already seen in the section dedicated to sorting) is functional. Its method is called compare, and has type T $\\times$ T $\\to$ int.\n"},{"id":43,"href":"/docs/intro/sections/bibliography/","title":"Additional resources","section":"This course","content":" Additional resources # You can use additional resource to solve the assignments or develop your project: web sites, IDE generated code, Copilot, et. However, make sure that you understand the code that you submit.\nJava\u0026rsquo;s syntax # This website contains Java code snippets that illustrate how to perform certain operations. However, this documentation is far from exhaustive (on purpose).\nWhen it comes to syntax, the first two sources of complementary material for this course are:\nthe Javadoc of the libraries (standard and auxiliary) used in projects and assignments. An IDE is often the fastest way to navigate through it, the web. Books # An (optional) reading list for this course is available in the catalogue of the Unibz\u0026rsquo;s library. All books can be accessed via the library (either physically or digitally).\nAmong these books, we highlight the following three:\nIntroductory textbooks # Java : the complete reference (11th edition) by Herbert Schildt McGraw-Hill Education, 2019\nThis is a general introductory book to Java and object oriented programming. It covers most of the topics seen in this course (and a lot more).\nHead First Java (3rd edition) by Kathy Sierra, Bert Bates and Trisha Gee O\u0026rsquo;Reilly Media, 2022\nThis is an alternative introductory book, less comprehensive, but with a larger emphasis on problem solving (rather than syntax).\nGood practices (intermediate level) # Effective Java (3rd edition)\nby Joshua Bloch\nAddison-Wesley Professional, 2017\nThis is a reference book for best practices and common pitfalls when programming in Java.\n"},{"id":44,"href":"/docs/lambda/sections/callback/","title":"Callback method","section":"Callback methods and lambda expressions","content":" Callback method # When a method takes another method as argument, the latter is a callback method.\nAnonymous methods are often used as callback methods.\nin Java # Running example # Example. The two following Java methods have the same structure: both modify each unit in the input list.\nvoid boostUnits(List\u0026lt;Unit\u0026gt; units){ for(Unit unit: units){ unit.health++; } } void penalizeGreenUnits(List\u0026lt;Unit\u0026gt; units){ for(Unit unit: units){ if(unit.color.equals(\u0026#34;green\u0026#34;)){ unit.health--; } } } In each case, let us isolate the modification that is applied to a single unit, with a dedicated method (called boost and penalizeGreen respectively).\nvoid boost(Unit unit){ unit.health++; } void penalizeGreen(Unit unit){ if(unit.color.equals(\u0026#34;green\u0026#34;)){ unit.health--; } } Both methods have type Unit $\\to$ void, so they are instances of the functional interface Consumer\u0026lt;Unit\u0026gt;.\nThis allows us to factorize our code with a method transform that takes as input:\nan array of units, a callback method with type Consumer\u0026lt;Unit\u0026gt;, and applies the callback method to each unit in the input array.\nvoid transform(List\u0026lt;Unit\u0026gt; units, Consumer\u0026lt;Unit\u0026gt; method){ for (Unit unit: units){ method.accept(unit); } } Passing a callback method # A callback method in Java can be:\na method reference, or a lambda expression. Method reference as a callback method # Syntax. A Java method reference is written:\nClassName::methodName for a static method, objectVariable::methodName for an instance method, ClassName::new for a constructor. Example (continued).\nLet us assume that our methods boost and penalizeGreen above are static methods of some class called UnitTransformer:\npublic class UnitTransformer{ static void boost(Unit unit){ unit.health++; } static void penalizeGreen(Unit unit){ if(unit.color.equals(\u0026#34;green\u0026#34;)){ unit.health--; } } } We can call our method transform with boost as callback method:\nList\u0026lt;Unit\u0026gt; units = getUnits(); transform( units, UnitTransformer::boost ); And similarly with penalizeGreen:\nList\u0026lt;Unit\u0026gt; units = getUnits(); transform( units, UnitTransformer::penalizeGreen ); Lambda expression as a callback method # Alternatively, instead of declaring a method boost, we can directly use a lambda expression:\nExample (continued).\nList\u0026lt;Unit\u0026gt; units = getUnits(); transform( units, unit -\u0026gt; unit.health++ ); And similarly, instead of declaring a method penalizeGreen, we can use the following lambda expression:\nList\u0026lt;Unit\u0026gt; units = getUnits(); transform( units, unit -\u0026gt; { if(unit.color.equals(\u0026#34;green\u0026#34;)){ unit.health-- ; } ); Native support # Programming languages that support anonymous methods (like Java, Python, C#, C++, JavaScript, etc.) often provide concise syntaxes to use them as callback methods.\nExample(continued).\nIn Java, the above method transform is not necessary. Instead, we can use the native method forEach, available (among others) for any Java Collection. This method takes a Consumer method as input, and applies this method to each element of the collection.\nSo the following program:\ngetUnits().forEach(unit -\u0026gt; unit.health++); is equivalent to:\ntransform( getUnits(), unit -\u0026gt; unit.health++ ); void transform(List\u0026lt;Unit\u0026gt; units, Consumer\u0026lt;Unit\u0026gt; method){ for (Unit unit: units){ method.accept(unit); } } "},{"id":45,"href":"/docs/objects/sections/comparing/","title":"Cast and equality","section":"Objects and classes","content":" Cast and Equality # Cast # Java (as well as C# and C++) provides mechanisms to change the type associated with an object o, using either a supertype of o (this is an upcast), or a subtype of o (this is a downcast).\nUpcast # Explicit upcasts are uncommon, but may still be useful in some scenarios, e.g. to disambiguate two method calls.\nImplicit upcasts on the other hand are very frequent, when the type of an object cannot be determined at compile time.\nExample. Consider the following classes:\nNow consider the following program, where the method getUnits produces an array of units that depends on the player\u0026rsquo;s input. The type of objects in this array (Unicorn or Butterfly) cannot be determined at compile time. Thanks to the implicit upcast, they can nonetheless be treated as (underspecified) units.\nUnit[] units = getUnits(); for (Unit unit: units){ System.out.println(unit.health); } Downcast # Downcasting in Java is frequent for objects whose type cannot be determined at compile time. However, this may not be safe. For instance, in the above example, downcasting a unit from Unit to Unicorn may cause a ClassCastException (at runtime), because this unit is a instance of Butterfly. This is why downcasting is often used in combination with the instanceof operator. For instance the above example can be modifed as follows:\nUnit[] units = getUnits(); for (Unit unit: units){ if(unit instanceof Unicorn){ ((Unicorn) unit).regen(); } } Here the operation (Unicorn) unit is a downcast. The output of this operation has type Unicorn, thus allowing the call to the method regen.\nObject equality # As we saw in a previous chapter, a constructor in Java creates an object in memory and returns a (fresh) reference to that object. Since two objects have different locations in memory, their respective references must differ, even if the objects are identical.\nExample. Consider (a simplified version of) the class City that we saw earlier.\npublic class City { String name; int zipCode; public City(String name, int zipCode){ this.name = name; this.zipCode = zipcode; } } The following program will output false:\nCity city1 = new City(\u0026#34;Florence\u0026#34;, 50100); City city2 = new City(\u0026#34;Florence\u0026#34;, 50100); System.out.println(city1 == city2); However, in some scenarios, it may be useful to compare the objects themselves, rather than their references. Java provides a native method called equals for this purpose.\nLike the method toString that we saw earlier, the equals is an instance method of the native Java class Object, which is an (implicit) superclass of every other class. So every (user-defined of native) class inherits equals.\nHere is the source code of Object.equals:\npublic boolean equals(Object obj) { return (this == obj); } In other words, by default, this method behaves like the == operator. In order to use this method to check whether two objects are equal, it has to be overriden.\nFor instance, here is a prototypical implementation of the method equals within our class City:\n@Override public boolean equals(Object o) { if (this == o) { // same reference return true; } if (o == null || getClass() != o.getClass()) return false; // o is null or has a different type } City downcastObject = (City) o; return zipCode == downcastObject.zipCode \u0026amp;\u0026amp; name.equals(downcastObject.name); } Hint. Your IDE can generate such a method.\nNote in this example:\nthe (safe) downcast from Object to City, and the recursive call to equals (because String is not a primitive type). Recursion # Warning. Similarly to what we saw with the method toString, beware of naive (recursive) implementations of equals if your program can create an object that refers to itself (directly or indirectly).\nBuilt-in implementations # Several native Java classes have their own implementation of equals. We will encounter several of them during this course, notably for the class String and for the implementations of the interface Set.\nThe method hashCode # The method equals is usually overridden together with another method of the class Object, called hashCode. In particular, this is needed for the method equals of the class HashSet to behave correctly. We will explore this topic later in this course, when we introduce the notion of a hash table.\n"},{"id":46,"href":"/docs/stream/sections/order/","title":"Multithreading and order","section":"Streams in Java","content":" Multithreading and order # Multithreading # We can allow a whole stream pipeline to be executed in a concurrent or parallel fashion, for instance with the instance method Stream.parallel, as follows:\nExample.\nList\u0026lt;Integer\u0026gt;list = List.of(1, 2, 3); // Contains [3,4,5] List\u0026lt;Integer\u0026gt; ouputList = list.stream() .parallel() .map(i -\u0026gt; i + 2) .toList(); This allows the JVM to take advantage of available resources to execute operations (like the map operation in this example) in several threads, concurrently.\nOrder # From the Javadoc of the package java.util.stream, if the source of a stream is ordered (e.g. a List), then the effect of an operation on the stream is usually predictable.\nIndeed, most operations are constrained to operate on the elements in their \u0026ldquo;encounter order\u0026rdquo;. For instance, if the source of a stream is a List containing [1, 2, 3], then the result of executing map(x -\u0026gt; x * 2) must be [2, 4, 6].\nHowever, in some cases, the terminal operation forEach may ignore the encounter order. If the stream is executed sequentially (which is the case by default), then this usually has no effect on execution. But if the stream is executed in parallel, then this is likely to affect the output.\nIn such a case, the terminal operation forEachOrdered may be used instead of forEach, in order to force this operation to respect the encounter order.\nExample.\nList\u0026lt;Integer\u0026gt;list = List.of(1, 2, 3); // Must output `2` `4` and `6, in this order. list.stream() .parallel() .map(x -\u0026gt; x * 2) .forEachOrdered(System.out::println); Besides, it is possible to relax the ordering constraint with the instance method Stream.unordered(). This may improve performance for pipelines with costly operations, in scenarios where the order of processing is irrelevant.\nExample. In this example, the order in which the elements of the stream are processed is irrelevant because:\nthe map applies a pure function, and the stream is collected as a set. This is why calling the unordered method is safe.\nList\u0026lt;MyClass\u0026gt;list = getList(); list.stream() .parallel() .unordered() .map(o -\u0026gt; expensivePureFunction(o)) .collect(Collectors.toSet()); "},{"id":47,"href":"/docs/input/sections/serialize/","title":"Serialization","section":"I/O and serialization","content":" Serialization # Serializing an object (resp. data structure) means converting it into a form that can be stored or transmitted, and such that the object (resp. data structure) can be later reconstructed (a.k.a. deserialized).\nin Java # Java provides a native mechanism to serialize an object (including information about the type of the object). The serialization format is not (meant to be) human-readable.\nThe process is JVM independent, meaning that an object can be serialized on one platform and deserialized on another.\nTransient # In Java, an instance attribute can be marked with the keyword transient (a.k.a. \u0026ldquo;volatile\u0026rdquo;). For instance:\npublic class MyClass { String serializedAttribute; transient int transientAttribute; ... } Transient attributes are excluded from the serialization process (meaning that a serialized object contains no value for its transient attribute).\nWarning. When an object is deserialized (i.e. converted back to an object), default values are assigned to each of its transient attributes: null for a reference, 0 for an int, false for a boolean, etc.\nSerializable # In Java:\na value with primitive type (e.g. int) is serializable, an array is serializable if its elements are serializable, an object is serializable if: its class implements the interface Serializable, and each of its attributes is serializable or marked as transient. Note. Implementing the interface Serializable does not require implementing any method.\nExample. Instances of the following class are not serializable, because Country does not implement Serializable.\npublic class Country { String name; public Country(String name) { this.name = name; } } Instances of the following class are not serializable either, because the attribute country has type Country, which does not implement Serializable.\npublic class City implements Serializable { String name; int zipCode; Country country; public City(String name, int zipCode, Country country) { this.name = name; this.zipCode = zipCode; this.country = country; } } However, if we replace\nCountry country; with\ntransient Country country; then instances of the class City become serializable, because:\nthe attribute name has type String, which implements Serializable, and the attribute zipCode has a primitive type, and the attribute country is now declared as transient. Note. Most native implementations of the Java interfaces Collection (ArrayList, LinkedList, HashSet, TreeSet, etc.) and Map (HashMap, TreeMap, etc.) also implement Serializable.\nserialVersionUID # If a class implements the interface Serializable, it is recommended to add a field: private static final long serialVersionUID (annotated with @Serial) and initialize it. For instance:\npublic class City implements Serializable { @Serial private static final long serialVersionUID = 0; ... } The value is irrelevant, but is meant to be updated if the (instance) attributes of the class are modified.\nFor an explanation, we refer to this page.\nSerialization (and deserialization) methods # The class ObjectOutputStream allows serializing an object, with the method:\nvoid writeObject(Object x) throws IOException Similarly, the class ObjectInputStream allows deserializing an object (i.e. loading it back into memory), with the method:\nObject readObject() throws IOException, ClassNotFoundException Note. The return type of readObject is Object, so the returned object needs to be cast to its appropriate data type.\nExample. Let us continue with the example above (assuming that the attribute City.country is marked as transient).\nA instance of City can be serialized to a file as follows:\nString path = \u0026#34;path/to/file.ser\u0026#34;; Country italy = new Country(\u0026#34;Italy\u0026#34;); City bologna = new City(\u0026#34;Bologna\u0026#34;, 40100, italy); try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(path))) { out.writeObject(bologna); } catch (IOException e) { throw new RuntimeException(e); } And deserialized as follows:\nCity deserializedBologna; try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(path))) { deserializedBologna = (City) in.readObject(); } catch (IOException | ClassNotFoundException e ) { throw new RuntimeException(e); } // Ouputs \u0026#39;Deserialized city: { name: Bologna, zipCode: 40100, country: null }\u0026#39; System.out.printf( \u0026#34;Deserialized city: { name: %s, zipCode: %d, country: %s }\u0026#34;, deserializedBologna.name, deserializedBologna.zipCode, deserializedBologna.country ); Observe that the attribute country after deserialization has value null (because it is marked as transient).\n"},{"id":48,"href":"/docs/lambda/sections/captured/","title":"Captured variables","section":"Callback methods and lambda expressions","content":" Captured variables # In practice, lambda expressions are often used to represent pure functions.\nSome languages (like Java, JavaScript, C++, etc) restrict (or allow the user to restrict) the usage of lambda expressions, so that they lean towards pure functions.\nTerminology. Some programming languages allow a lambda expression to use variables that:\nare declared outside of the lambda expression\u0026rsquo;s body, and are not arguments of the lambda expression. In this case, the expression is called a capturing lambda expression, and these variable are said to be captured.\nExample. In the following Java program, the lambda expression x -\u0026gt; x == a is a capturing lambda, because it uses the variable a, which is defined outside of the lambda expression.\nboolean myMethod() { int a = 2; return execute( 3, x -\u0026gt; x == a ); } boolean execute(Integer x, Function\u0026lt;Integer, Boolean\u0026gt; function) { return function.apply(x); } Captured variables in Java # Restriction. A capture variable in Java must be effectively final, meaning that it cannot be modified after its initialization.\nExamples. The following Java program is nearly identical to the previous one, but does not compile, because the captured variable a is not effectively final.\nboolean myMethod() { int a = 2; a = a + 1; return execute( 3, x -\u0026gt; x == a ); } boolean execute(Integer x, Function\u0026lt;Integer, Boolean\u0026gt; function) { return function.apply(x); } The following program does not compile either, for the same reason.\nboolean myMethod() { int a = 2; return execute( 3, x -\u0026gt; { a = a + 1; return x == a; } ); } boolean execute(Integer x, Function\u0026lt;Integer, Boolean\u0026gt; function) { return function.apply(x); } Exception. An exception to the rule above is captured variables that are allocated on the heap, i.e (class or instance) attributes.\nFor instance, the following program is nearly identical to the (first) program above that does not compile. However, this new program compiles, because the captured variable a is now an instance attribute.\npublic class EnclosingClass { int a = 2; boolean myMethod() { a = a + 1; return execute( 3, x -\u0026gt; x == a ); } boolean execute(Integer x, Function\u0026lt;Integer, Boolean\u0026gt; function) { return function.apply(x); } } "},{"id":49,"href":"/docs/objects/sections/classesasobjects/","title":"Classes as objects","section":"Objects and classes","content":" Classes as objects # Some object-oriented languages (like Java, C# or C++) provide ways to access or manipulate classes (almost) as if they were objects.\nStatic attributes and methods # Static attributes # Java (as well as C# and C++) supports attributes that do not depend on a specific object, but on a class instead. These are often called static attributes (or sometimes class attributes or class variables), as opposed to the attributes that we have seen so far, called instance attributes (or member variables).\nStatic attributes are marked with the keyword static.\nExample. Consider a version of our game where characteristics for each unit type (e.g. default health, etc.) can be declared manually, in a text file. The path to this file could be stored as a static attribute, as follows:\npublic class Unicorn { static String configFile = \u0026#34;units/unicorn.txt\u0026#34;; int health; public Unicorn(){ health = getHealthFromConfigFile(configFile); } public regen(){ health++; } } Each instance of Unicorn carries its own value for the attribute health. But the value of configFile is unique.\nFor instance, the following program creates in memory a unique string for configFile, which is carried by the class.\nUnicorn u1 = new Unicorn(); Unicorn u2 = new Unicorn(); Static methods # Similarly to a static attribute, a static method does not depend on a specific object, as opposed to an instance method.\nExample (continued).\nWe can add to our class Unicorn a static method that checks whether the configuration file exists:\npublic class Unicorn{ ... static boolean configFileExists() { return Files.exists(Paths.get(configFile)); } } (note that the method getHealthFromConfigFile also may also be static, if its execution is identical for all instances of Unicorn).\nRemember that an instance method can be called outside of the class where it is declared, using an instance of the class followed by .:\nUnicorn myUnicorn = new Unicorn(); myUnicorn.regen(); A static method can (syntactically) be called in the same way, for instance:\nUnicorn myUnicorn = new Unicorn(); boolean valid = myUnicorn.configFileExists(); However, this is often discouraged, because this syntax can be misleading (in this example, configFileExists can be mistaken for an instance method).\nAlternatively, since the method depends on the class (rather than an instance), the call can be prefixed with the class name. This syntax is often preferred, because it leaves no ambiguity. For instance:\nboolean valid = Unicorn.configFileExists(); Note that there may be several instances of a same class in memory during the execution of a program, or no instance at all. This is why a static method cannot reference an instance method or attribute. For instance, adding the following static method to our class would cause a compilation error, because health is an instance attribute.\npublic class Unicorn { static void reduceHealth(){ health--; } } Inheritance # Two static methods with the same name and signature can be declared in a class and a superclass. In Java\u0026rsquo;s terminology, this is not called method overriding, but instead method hiding. An important difference is that dynamic dispatch (a.k.a. runtime polymorphism) does not apply to this case (the method to be called is determined at compile time, rather than run time).\nExample (continued).\nLet us extend our example with a subclass of Unicorn that hides the static method configFileExists.\npublic class EvilUnicorn extends Unicorn { static boolean configFileExists(){ return false; } } Now consider the following program, where the method getUnicorns produces an array of unicorns that depend on the player\u0026rsquo;s input. The specific type of objects in this array (Unicorn or EvilUnicorn) cannot be determined at compile time.\nUnicorn[] unicorns = getUnicorns(); for (Unicorn unicorn: unicorns){ System.out.println(unicorn.configFileExists()); } } In this example, the method of the superclass (i.e. Unicorn.configFileExists) will be executed for each object in the array, regardless of its type.\nThis is another reason why calling a static method via an instance (rather than via a class name) is often discouraged. In this example, writing Unicorn.configFileExists() would make it clear that this loop serves no purpose (the same method is executed unicorns.length times).\nReflection # Java (as well as C#) offers a mechanism called reflection to intuitively treat classes analogously to objects. Precisely, each class of a program (e.g. the class Unicorn) is associated with an object that represents it. This object is itself an instance of the Java class called Class. It can be accessed either:\nvia an instance of the class: Unicorn myUnicorn = new Unicorn(); Class unicornClass = myUnicorn.getClass(); or via the qualified name of the class (assuming for instance that the file Unicorn.java is in the folder \u0026lt;workingDirectory\u0026gt;/src/main/java/org/units): Class unicornClass = Class.forName(\u0026#34;org.units.Unicorn\u0026#34;); The instance methods of the class Class are listed here. Among others, they allow:\nlisting the attributes of the class, retrieving its immediate superclass, or the interfaces that it implements, creating a new instance of this class, etc. Reflection is a powerful feature. It is rarely used in everyday code, but can be helpful in specific situations. Notably, it is used (internally) by numerous Java frameworks such as Spring, Jackson or JUnit.\n"},{"id":50,"href":"/docs/stream/sections/optional/","title":"Optional","section":"Streams in Java","content":" Optional # The class Optional was introduced in Java 8. An Optional is a container object that may or may not contain a value. Its main purpose is to indicate that the object returned by a function may be null.\nExample. In our game, the interface Board provides a method getUnit(int rowIndex, int columnIndex), that returns the unit standing on the tile with these coordinates, if any.\nThis could be implemented with a method\n$\\qquad$ Unit getUnit(int rowIndex, int columnIndex)\nthat returns null if there is no unit on this tile (and returns the unit otherwise).\nHowever, from the signature of this method, it is not immediately clear that the returned unit may be null. This may cause a NullPointerException at runtime, if the method is called by some program that does not check whether this unit is null.\nInstead, we can use\n$\\qquad$ Optional\u0026lt;Unit\u0026gt; getUnit(int rowIndex, columnIndex)\nto clearly indicate that the return value may not be present.\nSyntax # Declaring an empty Optional # An empty Optional can be initialized with the static method Optional.empty().\nExample.\nOptional\u0026lt;Unit\u0026gt; unit = Optional.empty(); Setting an Optional\u0026rsquo;s value # The value of an Optional can be set with the static method Optional.of.\nExample.\nOptional\u0026lt;Unit\u0026gt; unicorn = Optional.of(new Unicorn(\u0026#34;green\u0026#34;)); Getting an Optional\u0026rsquo;s value # Whether an Optional has a value can be checked with the instance method Optional.isPresent(), and the value (if present) can be retrieved with the instance method Optional.get().\nExample.\nOptional\u0026lt;Unit\u0026gt; unit = board.getUnit(rowIndex, columnIndex); if(unit.isPresent()){ unit.get().boost(); } The instance method Optional.ifPresent can be used (as an alternative) for the same purpose.\nIf the optional object has type Optional\u0026lt;$T$\u0026gt;, then ifPresent takes as argument a callback method with type\n$\\qquad T \\to$ void\n(a.k.a. a Java Consumer) that is executed iff the Optional is nonempty.\nExample.\nOptional\u0026lt;Unit\u0026gt; unit = board.getUnit(rowIndex, columnIndex); unit.ifPresent(u -\u0026gt; u.boost()); Primitive types # Java 8 also introduced the container OptionalInt (resp. OptionalLong, OptionalDouble), which behaves analogously to Optional\u0026lt;Integer\u0026gt; (resp. Optional\u0026lt;Long\u0026gt;, Optional\u0026lt;Double\u0026gt;), but contains an int (resp. long, double). It is mostly used in combination with IntStream (resp. LongStream, DoubleStream).\nOptional and streams # Some methods of the interface Stream\u0026lt;$T$\u0026gt; (resp. IntStream, LongStream, DoubleStream) return an Optional\u0026lt;$T$\u0026gt; (resp.OptionalInt, OptionalLong, OptionalDouble).\nIn particular:\nfindFirst average, max and min etc. "},{"id":51,"href":"/docs/multithreading/sections/troubleshooting/","title":"Troubleshooting","section":"Multithreading","content":" Troubleshooting # Alongside race conditions, there are several reasons why a program that uses multithreading may not behave as intended.\nTwo common ones are deadlocks and (to a lesser extent) starvation.\nDeadlock # Terminology. A deadlock occurs when two threads wait for each other to release a lock.\nThis notion also generalizes to cyclic deadlocks involving more than two threads.\nIn Java, this may be caused by synchronized methods or statements. A simple illustration can be found here.\nStarvation # A thread is starving if it does not get regular access to a shared resource, and as a result cannot progress in its execution.\nThis situation can often be avoided with a queue.\n"},{"id":52,"href":"/docs/multithreading/sections/abstractions/","title":"Abstractions","section":"Multithreading","content":" Abstractions # We review here some higher-level utilities available in Java to use multithreading, while reducing the risk of unwanted behaviors.\nThread safety # Terminology. A method is said to be tread-safe if it can be accessed by concurrently by several threads without \u0026ldquo;unexpected\u0026rdquo; consequences.\nThread safety is a vague term, which may for instance refers to implementations that are free of race conditions.\nMost high-level libraries or frameworks that exploit concurrency provide methods with some from of thread safety. In particular, this is the case of most Graphical User Interface frameworks (such as JavaFX or Swing for Java).\nBy default, it is highly recommended to rely on such methods when using concurrency. For instance, Effective Java (Item 81) recommends using \u0026ldquo;thread safe\u0026rdquo; concurrency utilities when possible, rather than Java\u0026rsquo;s (error prone) wait, notify and notifyAll methods.\nAtomic operation # Terminology. An operation performed by a thread is atomic if no operation performed by a concurrent or parallel thread can affect its execution.\nWe saw earlier that the operation\ni++; is not atomic, but corresponds to a sequence of instructions (fetch, increment and write).\nThe package java.util.concurrent.atomic provides classes like AtomicInteger, AtomicBoolean or AtomicReference that support atomic operations.\nExample. The program\nAtomicInteger i = new AtomicInteger(0); int j = i.getAndIncrement(); is analogous to\nint i = 0; int j = i++; but the operation i.getAndIncrement() is atomic, whereas i++ is not.\nAssociative array # ConcurrentMap # The interface ConcurrentMap is a sub-interface of Map (which stands for an associative array) with additional atomicity and thread-safety guarantees.\nIt has two native implementations, one as a hash table, the other as a so-called skip list. The latter maintains the order of insertion, analogously to what we saw for a LinkedHashMap.\nConcurrentNavigableMap # The interface ConcurrentNavigableMap is a sub-interface of SortedMap (like TreeMap, that we saw in the dedicated section), with additional atomicity and thread-safety guarantees. It has one native implementations, as a so-called skip list.\nQueue # The Java interface BlockingQueue is a sub-interface of Queue (which stands for the abstract data type queue). In addition to the traditional operations supported by a queue (dequeue and enqueue), a blocking queue provides variants of these operations to:\nwait for the queue to become non-empty (when dequeuing), or wait for space to be freed in the queue (when enqueueing). These allow implementing the producer/consumer pattern seen earlier, without relying on Java\u0026rsquo;s wait, notify and notifyAll methods.\nBlockingQueue has several native implementations (e.g. as a doubly linked list or as a dynamic array).\nThread pool # A thread pool is a (of fixed or flexible) set of threads that can be reused for different tasks.\nThe factory class Executors provides a series of static methods that return a thread pool. In particular:\nExecutors.newFixedThreadPool returns a pool (instance of ExecutorService) with a fixed number of threads (specified as argument), Executors.newCachedThreadPool returns a pool (also instance of ExecutorService), but with flexible size. In both cases, tasks submitted to the pool will reuse existing threads if available.\nAn introduction to Java thread pools can be found here.\n"},{"id":53,"href":"/docs/objects/sections/clone/","title":"Duplicating objects","section":"Objects and classes","content":" Duplicating objects # In some scenarios, it may be useful to duplicate an object.\nIn Java, as we saw earlier, copying the value of a variable with reference type does not copy the object that it references. For instance, the following program outputs \u0026ldquo;yellow\u0026rdquo;:\nUnicorn unicorn = new Unicorn(\u0026#34;green\u0026#34;); Unicorn shallowCopy = unicorn; unicorn.color = \u0026#34;yellow\u0026#34;; System.out.println(shallowCopy.color); The need to duplicate objects may notably appear in a program that rely on concurrency.\nExercise In our game, the \u0026ldquo;view\u0026rdquo; component is in charge of rendering the game visually.\nThis component exposes a method called drawSnapshot that takes as input a game snapshot and draws this snapshot on screen. The backend calls this method whenever a snapshot must be drawn. However, the backend may send these snapshots faster than they can be displayed (due to the duration of on-screen animations).\nTo deal with this scenario, the \u0026ldquo;view\u0026rdquo; buffers the snapshots that it receives (displaying a new snapshot only after all previously submitted ones have been displayed). For the sake of this exercise, you can think of this buffer as an array with type Snapshot[].\nNow consider the following method deleteUnit(int x, int y), executed by our backend each time it receives the instruction to delete a unit:\npublic class Backend implements EventHandler { Snapshot currentSnapshot; ... public void deleteUnit(int x, int y){ if(\u0026lt;\u0026#34;there is a unit on the tile x, y\u0026#34;\u0026gt;){ removeUnitFromTile(x, y); drawSnapshot(currentSnapshot); shiftUnitsInColumn(x); drawSnapshot(currentSnapshot); performUnitMerges(); drawSnapshot(currentSnapshot); ... } } } where the auxiliary methods removeUnitFromTile, shiftUnitsInColumn and performUnitMerges may modify the object currentSnapshot.\nObserve that the method deleteUnit calls drawSnapshot three times.\nNow let us assume that the buffer of the \u0026ldquo;view\u0026rdquo; is nonempty when this method is executed, so that the 3 snapshots are added to the buffer, before any of them can be rendered on screen.\nHow many of these 3 snapshots will be drawn on screen?\nSolution Only the third snapshot will be drawn (three times), because the buffer contains three references to the same object.\nShallow, deep and hybrid copy # Copying a reference to an object can be viewed as the shallowest possible form of copy. As we saw already, this is what happens in Java when a variable with reference type is passed as argument.\nAt the other end of the spectrum is a so-called deep copy, where all attributes of the copied object are duplicated, recursively. In this case, the copy or any object that it references (recursively) can be modified without affecting their original counterparts.\nBetween these two extremes:\na shallow copy creates a new object (with fresh attributes), but does not copy referenced objects recursively, a hybrid copy is anything between a shallow copy and a deep copy. in Java # Copy constructor # A copy can be performed in Java with a so-called copy constructor. This is an additional constructor that takes an instance of the class as input, and returns a copy of this instance.\nFor example:\npublic class Hero { int health; // standard constructor public Hero(){ this.health = 10; } // copy constructor public Hero(Hero original){ this.health = original.health; } } In order to perform a deep(er) copy, a copy constructor may call another copy constructor. For example:\npublic class Snapshot { Hero firstHero; Hero secondHero; Board board; int remainingActions; // standard constructor public Snapshot(Hero firstHero, Hero secondHero, Board board, int remainingActions){ // some code here ... } // copy constructor public Snapshot(Snapshot original){ this.firstHero = new Hero(original.firstHero); this.secondHero = new Hero(original.secondHero); this.board = new Board(original.board); this.remainingActions = original.remainingActions; } } Warning. Similarly to what we saw with the methods toString or equals, beware of recursive implementations of copy constructors, if your program can create an object that refers to itself (directly or indirectly).\nThe method clone # Java also provides a native method called clone to duplicate objects. Like the methods toString and equals that we saw earlier, clone is an instance method of the native Java class Object, which is an (implicit) superclass of every other class.\nOverriding clone can be more concise than using a copy constructor (especially for a class with a large number of attributes).\nWarning. Overriding clone can be error-prone, especially in presence of a class hierarchy (see Effective Java, Item 13 for further insight). Notably, the overriding class must implement the Cloneable interface, and an implementation of clone usually calls super.clone recursively (even for a class whose only superclass is Object). For these reasons, overriding clone is sometimes discouraged, in favor of conceptually simpler solutions (like copy constructors).\n"},{"id":54,"href":"/docs/objects/sections/quasi-objects/","title":"Quasi-objects","section":"Objects and classes","content":" Quasi-objects # Enumerated types # Most imperative languages allow the creation of so-called enumerated types.\nAn enumerated type is a datatype for a finite set or enumerated values. For instance, if our game only allows \u0026ldquo;blue\u0026rdquo;, \u0026ldquo;green\u0026rdquo; and \u0026ldquo;red\u0026rdquo; as unit colors, then we may create a dedicated type that only allows these three values.\nIn Java # An enumerated type in Java is a set of constants. These constants are effectively static, meaning that they depends on the class or interface where the enumerated type is declared (similarly to a static attribute). The name of an enumerated type can generally be used like a regular reference type. For instance\npublic class Unit { enum UnitColor {BLUE, GREEN, RED} int health; UnitColor color; public Unit(int health, UnitColor color){ this.health = health; this.color = color; } ... } Note. In the above example, the enumerated type UnitColor could equivalently be represented with an integer. For instance, 0 for blue, 1 for green and 2 for red. However, with such an encoding, a conditional statement (e.g. if or switch) that checks the color of a unit would also need to handle the case of values \u0026lt; 0 or \u0026gt; 2. So (besides readability), a benefit of the enumerated type in this case is that it restricts possible inputs to valid ones.\nHint. Enumerated types in Java are significantly more expressive than their counterparts in some other languages. Notably, a Java enum can have its own constructor and methods.\nRecords # A record is an object whose attributes cannot be modified.\nin Java # Records were introduced in Java 14 (2020). They are a convenient way to avoid boilerplate code. Records provide a concise syntax for \u0026ldquo;lightweight\u0026rdquo; classes that are only meant to hold data.\nFor instance, here is the full implementation of a record City:\npublic record City(String name, int zipCode) {} This record has an implicit constructor, and implements equals, hashcode and toString in the expected way. For instance:\nCity florence = new City(\u0026#34;Florence\u0026#34;, 50100); City florenceAgain = new City(\u0026#34;Florence\u0026#34;, 50100); // Outputs true. System.out.println(florence.equals(florenceAgain)); The attributes of a record cannot be modified. For instance, the following program does not compile:\nCity florence = new City(\u0026#34;Florence\u0026#34;, 50100); florence.zipCode = 50121; A record is often declared inside a class or interface. For instance, in our game:\npublic class Board { public record TileCoordinates(int X, int Y){}; ... } Records are convenient for methods that need to return more than one value. For instance:\nTileCoordinates getOngoingMove(); Strings # Interning # Many modern languages (such as Java, C#, Python, Ruby, JavaScript, Go, etc.) support a technique called interning, in order to manage strings in memory. This consists in storing only one copy of each distinct string created during the execution of a program. These strings are stored in a shared pool, and each of them is an immutable object (meaning that it cannot be modified).\nSome benefits are faster string comparisons, lower memory footprint, etc.\nin Java # In Java, a string is an object. Like for regular objects, comparing two variables of type String with == compares their references:\nString myString = new String(\u0026#34;foo\u0026#34;); String sameString = new String(\u0026#34;foo\u0026#34;); // Outputs false, because the two variables hold different references. System.out.println(myString == sameString); A string can be explicitly interned (i.e. added to the shared pool) with the (instance) method intern. This method:\ntries to add the string to the pool, and then returns a reference to the (only) version of the string contained in the pool. For instance, consider the following program:\n// Creates a string \u0026#34;foo\u0026#34;, String myString = new String(\u0026#34;foo\u0026#34;) // adds it to the pool, myString = myString.intern(); // Creates another string \u0026#34;foo\u0026#34;, String sameString = new String(\u0026#34;foo\u0026#34;); // Outputs false. System.out.println(myString == sameString); // Tries to add \u0026#34;foo\u0026#34; to the pool once again. // Because the pool already contains a version of \u0026#34;foo\u0026#34;, returns a reference to it. sameString = sameString.intern(); // Outputs true, because the two variables now hold the same reference. System.out.println(myString == sameString); A string that is initialized without constructor (i.e. directly with \u0026quot; \u0026ldquo;) is interned. For instance\nString myString = \u0026#34;foo\u0026#34;; String sameString = \u0026#34;foo\u0026#34;; // Outputs true, because of (implicit) interning System.out.println(myString == sameString); In order to support interning, string in Java are immutable.\nIn particular, the instance methods of the class String (like substring, etc.) do not modify a string. Instead, some of them may return (a reference to) a different object. For instance:\nString foo = new String(\u0026#34;foo\u0026#34;); String copy = foo; // Outputs true, because the two variables hold the same object reference. System.out.println(copy == foo); foo = foo.replace(\u0026#39;o\u0026#39;,\u0026#39;O\u0026#39;); // Outputs false, because the method \u0026#39;replace\u0026#39; returns a reference // to another object. System.out.println(copy == foo); The class String overrides the method equals so that it implements string comparison in the expected way. For instance:\nString myString = new String(\u0026#34;foo\u0026#34;); String sameString = new String(\u0026#34;foo\u0026#34;); // Outputs false. System.out.println(myString == sameString); // Outputs true. System.out.println(myString.equals(sameString)); Hint. By default, you can always use equals to compare the values of two strings. This is less error-prone than == (albeit less efficient if the two strings differ).\nJava boxed types # Java has 8 primitive types: byte, short, int, long, float, double, boolean and char.\nFor each primitive type, Java has a so-called boxed or (wrapper) type: Byte, Short, Integer, Long, Float, Double, Boolean and Character.\nThese types can be used in Java collections (Set, List, etc.), whereas primitive types cannot. Some boxed types also offer additional functionalities, via instance methods (e.g. an Integer can represent a positive numbers up to $2^{32} - 1$.\nConstructors for boxed types are deprecated. Instead, instances can be created via so-called autoboxing, for instance:\nInteger myInteger = 2; Character myCharacter = \u0026#39;a\u0026#39;; Several Java operators (like +, ==, \u0026lt;=, etc.) are also overloaded so that they behave with boxed types as they would with primitive types. For instance:\nInteger i = 1; i += 1; Integer j = 2; // Outputs true System.out.println(i == j); Like strings, instances of boxed types are immutable. This can affect performance. For instance:\nfor (Integer i = 0; i \u0026lt; 1000000 ; i++){ ... } may create up to 1 million objects in memory. This is one of the reasons why it is usually recommended to use primitive types whenever possible (see for instance Effective Java, Item 61). Some boxed types are (partially) interned, analogously to strings.\n"},{"id":55,"href":"/docs/objects/sections/encapsulation/","title":"Encapsulation","section":"Objects and classes","content":" Encapsulation # Encapsulation is a (vague) principle in object-oriented programming that refers to \u0026ldquo;bundling\u0026rdquo; data with the code that operates on it, and restrict visibility of this code and data to other components of a system.\nFrom Wikipedia: \u0026ldquo;Essentially, encapsulation prevents external code from being concerned [\u0026hellip;]\u0026rdquo;\nEach component hides its internal logic by exposing only data and methods that other components may need.\nExample. As we saw earlier, in our game, the \u0026ldquo;view\u0026rdquo; component (which is in charge of rendering the game on screen) may buffer the game snapshots that it receives from the backend, if these snapshots are received faster than they can be displayed.\nAs a buffer, this component uses a structure called a queue. This queue is not exposed to other components, because they do not need to see it, and (most importantly) should not modify it. In other words, this queue is an implementation detail, internal to the \u0026ldquo;view\u0026rdquo; component.\nEncapsulation can have many benefits. Among others:\nEasier debugging. If our queue is internal to the \u0026ldquo;view\u0026rdquo; component, then we know that it cannot be responsible for the malfunction of another component. Easier collaboration. Alice may refactor the implementation of the \u0026ldquo;view\u0026rdquo; component, knowing that this will not affect Bob, who is currently working on the backend. This is why a common practice in object-oriented programming consists in hiding all attributes and methods of a new class by default, and make accessible only the ones that need to be (in particular, this is likely to be the default behaviour of your IDE).\nEncapsulation also largely dictates how libraries are structured. For instance, when you create a String in Java, you do not have access to the internal representation of the string object.\nin Java # Each attribute or method of a class can have an access modifier, which specifies which other classes can access it. For instance, the keywords private and protected below are access modifiers.\nprivate int myAttribute; protected int myMethod(){ return 1; } Definition. There are four levels of access in Java:\nprivate restricts access to the current class, \u0026ldquo;package-private\u0026rdquo; relaxes private by also allowing access from the folder of the current class (in Java, a folder for source code is called a package), excluding subfolders, protected relaxes \u0026ldquo;package-private\u0026rdquo; by also allowing access from the subclasses of the current class, public does not restrict access. Warning. There is no keyword for the \u0026ldquo;package-private\u0026rdquo; level. Instead, this is the default level for an attribute or method without access modifier. For instance, in the example below, the attribute myAttribute is package-private:\nint myAttribute; Here is a recap table from the Oracle tutorials:\nkeyword class package subclasses world private yes no no no none yes yes no no protected yes yes yes no public yes yes yes yes Warning. A method declared in an interface is (implicitly) public.\nWarning. If a method m1 overrides (or implements) a method m2, then m1 must be at least as accessible as m2.\nExercise The following program does not compile. Can you see why, and how to fix this?\n├── Run.java └── units ├── Unit.java └── impl └── Unicorn.java public abstract class Unit { static String configFolder = \u0026#34;path/to/config\u0026#34;; } public class Unicorn extends Unit { String name; public Unicorn (String name){ this.name = name; } public static String getConfigFilePath (){ return configFolder + \u0026#34;/unicorn.properties\u0026#34;; } } public class Run { void testUnicorn(){ Unicorn myUnicorn = new Unicorn(\u0026#34;Storm\u0026#34;); myUnicorn.name = \u0026#34;Tornado\u0026#34;; } } Solution Unicorn.getConfigFilePath tries to access the package-private attribute Unit.configFolder (it should be made protected of public), Run.getConfigFilePath, tries to access the package-private attribute name of myUnicorn (it should be made public). Hint. Your IDE may suggest how to fix such compilation errors.\nTo improve encapsulation, it is good practice to restrict access whenever possible (i.e. without compromising compilation).\nHint. As a rule of thumb, in Java:\nuse private by default for all attributes and methods that you create, and if the program does not compile, then use your IDE to relax access. Exercise Encapsulation in this program can be improved. Can you see how?\n├── Run.java └── units ├── Unit.java └── impl └── Unicorn.java public abstract class Unit { public int health; public Unit(int health) { this.health = health; } public void attack(Unit defender){ int copy = health; health -= defender.health; defender.health -= copy; } } public class Unicorn extends Unit { public Unicorn (){ super(1); } @Override public void attack(Unit defender){ regen(); super.attack(defender); } public void regen(){ health += 1; } } public class Run { void testUnicorn(){ Unicorn u1 = new Unicorn(); Unicorn u2 = new Unicorn(); u1.attack(u2); } } Solution Unit.health can be made protected, the constructor of Unit can be made protected, Unit.attack can be made protected, Unicorn.regen can be made private. Note. The constructor of an abstract class can always be made protected (since it can only be called in the constructor of a subclass).\nGetters and setters # For attributes, the notion of \u0026ldquo;access\u0026rdquo; can be refined. An attribute may be:\nneither visible nor modifiable, or only visible, or only modifiable, or both visible and modifiable. This can be achieved with private attributes and so-called \u0026ldquo;getter\u0026rdquo; and \u0026ldquo;setter\u0026rdquo; methods. For instance, in the following class, the attribute health has public visibility but is not modifiable.\npublic class Unicorn { private int health; public int getHealth(){ return health; } } Conversely, in the following class, the attribute health can be modified but is not visible.\npublic class Butterfly { private int health; public void setHealth(int health){ this.health = health; } } Hint. Getter and setter methods can be automatically generated by your IDE.\nTo go further: inheritance violates encapsulation # Composition # Example (from Effective Java, Item 18).\nConsider a class MyHashSet that extends Java\u0026rsquo;s Hashset functionality by keeping track of the number of objects added to the set (as opposed to the output of HashSet.size(), which returns the numer of elements remaining in the set).\nThis class myHashSet may have an attribute int counter (initialized to 0) that keeps track of the number of elements added to the set so far. And it may be implemented by overriding add and addAll in the expected way, i.e.:\n@Override public boolean add(E e){ counter++; return super.add(e); } @Override public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c){ counter += c.size(); return super.addAll(c); } However, this implementation of addAll would count every insertion twice, because the implementation of HashSet.addAll calls HashSet.add.\nA design pattern called composition can be used to avoid such unintended effects. Intuitively, instead of extending the original class, use an instance Hashset set of it as a (private) attribute of the new class. However, this requires re-implementing all methods of the original class (albeit in a straightforward way), for instance:\npublic boolean isEmpty(){ return set.isempty(); } Prevent overriding or inheritance # As show by the example above, in order to improve encapsulation, one may want in some scenarios to forbid overriding a method or extending a class. In Java, this can be enforced with the keyword final, for instance:\npublic final class NonExtensibleClass { ... } public class MyClass{ public final void nonOverridableMethod(){ ... } } "},{"id":56,"href":"/docs/objects/sections/mutability/","title":"Mutability","section":"Objects and classes","content":" Mutability # Illustration # Exercise The Java method createUsers below is incorrect.\nCan you see why, and how to fix this?\npublic class User { int id; String name; } /* Input: - ids: a nonempty array of user identifiers - names: an array of the same length as \u0026#39;ids\u0026#39; that contains user names Ouput: an array of users of the same lenght as \u0026#39;ids\u0026#39;, such as the i-th user has identifier ids[i] and name names[i] */ User[] createUsers(int[] ids, String[] names){ User[] users = new User[names.length]; User currentUser = new User(); for(int i = 0; i \u0026lt; ids.length; i++){ currentUser.id = ids[i]; currentUser.name = names[i]; users[i] = currentUser; } return users; } Possible solution The output array contains $i$ times the same user (with the last id and name from the input arrays).\nOne way to fix this is:\nadd an explicit constructor to the class User: public class User { int id; String name; public User(int id, String name){ this.id = id; this.name = name; } } call this constructor for each new user: public User[] createUsers(int[] ids, String[] names) { User[] users = new User[names.length]; for(int i = 0; i \u0026lt; ids.length; i++){ users[i] = new User(ids[i], names[i]); } return users; } In this example, an instance of the class User is a mutable object, meaning that its attributes (id and name) can be modified after the object is created. However, these two values (or at least the value of the attribute id) are unlikely to change.\nIn Java (or C#, C++, etc.), it is possible to forbid these two values to be modified. This would have prevented compilation of the incorrect program above.\nImmutable object # Informally, an object is mutable if it can be modified after its creation.\nImmutability has many known benefits (but also drawbacks):\nBenefits # Easier debugging: as illustrated above, forcing an object to be immutable may prevent an incorrect program to compile. Compile-time errors are usually easier to fix that bugs. Readability: code that modifies or reuses objects can be harder to understand (and reason about) than code that creates (fresh) immutable objects. Thread-safety: multiple threads can access an immutable object concurrently without race condition. Easier collaboration and maintenance: Alice can safely pass an immutable object to Bob (i.e. make the object visible to Bob\u0026rsquo;s code). This will not affect the correctness of Alice\u0026rsquo;s code (because Bob\u0026rsquo;s code cannot modify this object). Reference. For a more in-depth analysis of the benefits of immutability, we refer to Effective Java, item 17:\n\u0026ldquo;Classes should be immutable unless there\u0026rsquo;s a very good reason to make them mutable.\u0026rdquo;\nObservation. Some programming language (like Haskell or Rust), enforce (a form of) immutability by default.\nDrawbacks # Performance: on a large scale (e.g. thousands of objects), reusing existing object may be more efficient that creating (fresh) immutable ones. Terminology # The term \u0026ldquo;immutable object\u0026rdquo; (or \u0026ldquo;immutable class\u0026rdquo;) is used with slightly different meanings. In particular:\na weaker notion of immutability only requires the attributes of an object to be non-modifiable, a stronger notion also requires the objects that are referred to (transitively) to be non-modifiable. By convention, we will use in what follows the term \u0026ldquo;final\u0026rdquo; for the weaker requirement, and \u0026ldquo;immutable\u0026rdquo; for the stronger requirement. More precisely:\nDefinition. An object is final if its attributes cannot be modified after the object\u0026rsquo;s creation.\nDefinition. An object is immutable if it is final and the objects that it references are immutable.\nin Java # final # The Java keyword final ensures that a variable cannot change value after its initialization.\nExample. The following Java program does not compile.\nfinal int a = 2; a = 3; Warning. This meaning of the keyword final is different from that we already saw in the section on encapsulation.\nWhen the variable is an instance attribute, this also forces the attributes to be explicitly instantiated before the execution of the constructor terminates.\nExample. The following Java program does not compile.\npublic class User { final int id; final String name; public User(int id){ this.id = id; } } Example. The following Java program compiles, and the instances of User are immutable (because strings in Java are themselves immutable).\npublic class User { final int id; final String name; public User(int id){ this.id = id; this.name = name; } } Note. Alternatively, a final instance attribute can be instantiated immediately after it is declared (because this instruction is executed before the constructor). For instance, the following program compiles.\npublic class User { public final int id; public final String name = \u0026#34;Alice\u0026#34;; public User(int id){ this.id = id; } } In practice. Your IDE is likely to create final (and private) instance attributes by default.\nfinal vs immutable # Warning. The final keyword may not be sufficient to enforce immutability (at least as it is defined above), in particular when a final attribute refers to a mutable object.\nExample. Instances of the class User below are final, but not immutable, because instances of Address are not immutable.\npublic class User { final int id; final Address address; public User(int id, Address address){ this.id = id; this.address = address; } } public class Address { int streetNumber; String street; int zipCode; public Address(int streetNumber, String street, int zipCode){ this.streetNumber = streetNumber; this.street = street; this.zipCode = zipCode; } } For instance, the following code compiles.\nAddress myAddress = new Address(14, \u0026#34;via Goethe\u0026#34;, 39100); User myUser = new User(1, myAddress); myAddress.streetNumber = 12; Final and immutable types # We already encountered several types of Java object and quasi-objects that are:\nfinal: records, sets (resp. lists, maps) that are declared with Set.of() (resp. List.of(), Map.of()), immutable: strings, boxed types (like Integer or Boolean). Record # A record is final.\nExamples. Because strings are immutable, the following records are immutable:\nrecord User(int id, String name){}; However, the following records are only final (unless instance of Address are immutable):\nrecord User(int id, String name, Address address){}; Set, List, Map # If a set (resp. list, map) is created with Set.of() (resp. List.of(), Map.of()), then its content is final.\nExample. The following Java program throws an UnsupportedOperation exception.\nSet\u0026lt;Integer\u0026gt; mySet = Set.of(2, 3); mySet.add(5); However, if the set (resp. list, map) contains references, then the objects that are referred to may be mutable.\nExample. The following program compiles (assuming that the attribute streetNumber of the class Address does not have the final keyword).\nAddress myAddress = new Address(14, \u0026#34;via Goethe\u0026#34;, 39100); Set\u0026lt;Address\u0026gt; mySet = Set.of(myAddress); myAddress.streetNumber = 12; By design, most other implementations of List, Set and Map are not final (this is expected, for performance reasons).\nHowever, in some scenarios, a program may create a (small) list (resp. set, map) that is not meant to be modified. For instance, the list of all files in a folder. In this case, the list (resp. set, map) can be made final. A common way to achieve this is the class ImmutableList (resp. ImmutableSet, ImmutableMap) of the Guava library.\nTo use Guava in a Maven project, declare this dependency:\n\u0026lt;dependencies\u0026gt; ... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.guava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;guava\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;33.1.0-jre\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; ... \u0026lt;/dependencies\u0026gt; or in a Gradle project:\nimplementation group: \u0026#39;com.google.guava\u0026#39;, name: \u0026#39;guava\u0026#39;, version: \u0026#39;33.1.0-jre\u0026#39; String # Java\u0026rsquo;s strings are immutable.\nHowever, the class StringBuilder implements a mutable string. It provides instance methods like append, insert, delete (a substring), etc.\nBoxed types # Java\u0026rsquo;s boxed types (like Integer or Boolean) are immutable.\nHowever, each boxed types has a mutable \u0026ldquo;atomic\u0026rdquo; counterpart, e.g. AtomicInteger for Integer and AtomicBoolean for Boolean.\nThe main purpose of these classes is to offer build-in thread safety for common sequences of operations. For instance, AtomicInteger provides a method equivalent to i++, but thread-safe (note that i++ is a shortcut for three operations: read the value, increment it and write it back).\nExercise What does the following program output?\nBoolean b = true; // Create an atomic boolean with value true AtomicBoolean ab = new AtomicBoolean(true); List\u0026lt;Boolean\u0026gt; booleans = new LinkedList\u0026lt;\u0026gt;(); List\u0026lt;AtomicBoolean\u0026gt; aBooleans = new LinkedList\u0026lt;\u0026gt;(); booleans.add(b); aBooleans.add(ab); b = false; // Set the value of the atomic boolean to false ab.set(false); booleans.add(b); aBooleans.add(ab); System.out.println(booleans); System.out.println(aBooleans); Solution [true, false] [false, false] "},{"id":57,"href":"/docs/objects/sections/quiz/","title":"Quiz","section":"Objects and classes","content":" Quiz # To answer the quiz (and check your answers), click here or scan this code:\nBoxed type # public class City { int population; public City (int population){ this.population = population; } } int myInteger = 1; Integer myBoxedInteger = 1; Integer myBoxedCopy = myInteger; City myCity = new City(5000); myMethod(myInteger, myBoxedInteger, myBoxedCopy, myCity); System.out.println( myInteger + \u0026#34;, \u0026#34;+ myBoxedInteger + \u0026#34;, \u0026#34;+ myBoxedCopy + \u0026#34;,\u0026#34; + myCity.population); void myMethod(int integer, Integer boxedInteger, Integer boxedCopy, City city) { integer += 1; boxedInteger += 1; boxedCopy += 1; city.population += 1; } This Java program outputs:\n1, 1, 1, 5000 1, 1, 1, 5001 1, 2, 1, 5000 1, 2, 1, 5001 1, 2, 2, 5000 1, 2, 2, 5001 2, 2, 2, 5000 2, 2, 2, 5001 I do not know the answer Objects and references # public class City { String name; Country country; public City(String name, Country country) { this.name = name; this.country = country; } } public class Country { String name; City capital; public Country(String name, City capital) { this.name = name; this.capital = capital; } } Country italy = new Country(\u0026#34;Italy\u0026#34;, null); City florence = new City(\u0026#34;Florence\u0026#34;, italy); City rome = new City(\u0026#34;Rome\u0026#34;, italy); italy.capital = rome; System.out.print(italy.capital.name + \u0026#34;, \u0026#34;); System.out.print(florence.country.capital.name + \u0026#34;, \u0026#34;); System.out.print(rome.country.capital.name + \u0026#34;, \u0026#34;); System.out.print(rome.country.capital.country.capital.name); This Java program:\ndoes not terminate outputs null, null, null, null outputs null, null, Rome, null outputs null, null, Rome, Rome outputs Rome, null, null, null outputs Rome, null, Rome, null outputs Rome, null, Rome, Rome outputs Rome, Rome, Rome, Rome I do not know the answer Copy constructor # public class City { String name; Country country; public City(String name, Country country) { this.name = name; this.country = country; } public City (City original) { this.name = original.name; this.country = original.country; } } public class Country { String name; City capital; public Country(String name, City capital) { this.name = name; this.capital = capital; } public Country(Country original){ this.name = original.name; this.capital = new City(original.capital); } } Country italy = new Country(\u0026#34;Italy\u0026#34;, null); City rome = new City(\u0026#34;Rome\u0026#34;, italy); italy.capital = rome; Country littleItaly = new Country(italy); littleItaly.name = \u0026#34;littleItaly\u0026#34;; littleItaly.capital.name = \u0026#34;littleRome\u0026#34;; System.out.print(littleItaly.capital.name+ \u0026#34;, \u0026#34;); System.out.print(littleItaly.capital.country.name+ \u0026#34;, \u0026#34;); System.out.print(littleItaly.capital.country.capital.name); This Java program:\ndoes not terminate outputs Rome, Italy, Rome outputs Rome, littleItaly, Rome outputs littleRome, Italy, Rome outputs littleRome, littleItaly, Rome outputs littleRome, littleItaly, littleRome I do not know the answer toString # public class City { String name; Country country; public City(String name, Country country) { this.name = name; this.country = country; } @Override public String toString() { return \u0026#34;City{\u0026#34;+ \u0026#34;name=\u0026#34; + name + \u0026#34;, \u0026#34;+ \u0026#34;country=\u0026#34; + country + \u0026#34;}\u0026#34;; } } public class Country { String name; City capital; public Country(String name, City capital) { this.name = name; this.capital = capital; } @Override public String toString() { return \u0026#34;Country{\u0026#34;+ \u0026#34;name=\u0026#34; + name + \u0026#34;, \u0026#34;+ \u0026#34;capital=\u0026#34; + capital + \u0026#34;}\u0026#34;; } } In this program, the method City.toString():\ncan output the empty string always outputs the empty string never outputs the empty string is recursive is not recursive may not terminate always terminates never terminates Static attribute # public class MyClass { static int value; boolean flag; public MyClass(int value, boolean flag){ this.value = value; this.flag = flag; } void print(){ System.out.print(\u0026#34;[\u0026#34;+value+\u0026#34; \u0026#34;+flag+\u0026#34;]\u0026#34;); } void incrementValue(){ value++; } void setFlag(boolean flag){ this.flag = flag; } } MyClass o1 = new MyClass(2, true); MyClass o2 = new MyClass(3, false); o1.print(); myMethod(o1); o1.print(); void myMethod(MyClass object) { object.setFlag(false); object.incrementValue(); object.print(); } This (strange) Java program outputs:\n[2 true][3 false ][3 false] [3 true][4 false ][4 false] [2 true][3 false ][2 true] [3 true][4 false ][3 true] [2 false][3 false ][3 false] [3 false][4 false ][4 false] [2 false][3 false ][2 true] [3 false][4 false ][3 true] I do not know the answer. "}]