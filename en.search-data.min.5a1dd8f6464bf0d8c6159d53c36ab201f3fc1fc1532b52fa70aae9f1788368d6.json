[{"id":0,"href":"/docs/errors/sections/callstack/","title":"Call stack","section":"Errors","content":" Call stack # A **call stack** is a [stack]() that keeps track of the methods that are active during the execution of a program. By \"active\", we mean that an execution of the method has started and has not terminated yet. When the execution of a method starts, it is \"added\" to the stack. When it terminates, the method is \"removed\" from the stack, and control is passed back to the method that called it. A debugger provides a representation of the successive states of a call stack, with references to the source code. This gives the illusion of source code being interpreted verbatim.\n**_Example._** In our game, consider the following implementation of the method `callReinforcement`: ```java {linenos=true} public class Backend implements EventHandler { Snapshot currentSnapshot; ... @Override public void callReinforcement() { Player activePlayer = currentSnapshot.getActivePlayer(); int unitsToInsert = currentSnapshot.getSizeOfReinforcement(activePlayer); while (unitsToInsert \u003e 0){ Unit unit = generateRandomUnit(); TileCoordinates coordinates = findInsertionSpot(unit); if(coordinates != null) { addUnit(coordinates, unit); unitsToInsert--; } } } private Unit generateRandomUnit() { ... } private TileCoordinates findInsertionSpot(Unit unit) { ... } private void addUnit(TileCoordinates coordinates, Unit unit) { currentSnapshot.getBoard().addUnit(coordinates.rowIndex(), coordinates.columnIndex(), unit); performUnitMerges(); } private void performUnitMerges() { ... } } ``` When the method callReinforcement is called, it is added (a.k.a. pushed) on top of the call stack. This is rendered by a debugger as:\ncallReinforcement \u0026lt;bottom of the stack\u0026gt; If execution \u0026ldquo;reaches\u0026rdquo; Line 11, then the method generateRandomUnit is called and added to the stack:\ngenerateRandomUnit callReinforcement: 11 \u0026lt;bottom of the stack\u0026gt; When the method generateRandomUnit terminates, it passes control (as well as a Unit) back to the method that called it, namely callReinforcement, which can resume its execution:\ncallReinforcement \u0026lt;bottom of the stack\u0026gt; Similarly, when execution \u0026ldquo;reaches\u0026rdquo; Line 12, findInsertionSpot is added to the stack, executed, and then removed from the stack, passing control back to callReinforcement.\nThen if execution \u0026ldquo;reaches\u0026rdquo; Line 14, addUnit is executed, which in turn calls performUnitMerges:\nperformUnitMerges addUnit: 28 callReinforcement: 14 \u0026lt;bottom of the stack\u0026gt; etc.\n**_Note._** If a method is recursive (i.e. if it calls itself, _directly or indirectly_), then it may appear multiple times in the call stack. E.g.: ``` method1 method2: 16 method1: 8 ``` **_Definition._** A **stack overflow** occurs when the size of the call stack exceeds the capacity allowed by the execution environment. This is generally due to a non-terminating recursive method. "},{"id":1,"href":"/docs/abstractdatatypes/sections/list/","title":"List","section":"Abstract data types","content":" List # The abstract data type **list** simulates a [tuple](). Accordingly, a list may contain duplicates.\nA list may expose the following methods:\nisEmpty is self-explanatory, append adds an element at the end of the list, prepend adds an element at the beginning of the list, tail returns the sub-list identical to the current one, but without its first element, etc. **_Note._** The _size_ of a list is often unbounded (as opposed to the size of an array for instance). This can be implemented in different ways, for instance with a [dynamic array]() or a [linked list](). in Java # Java has an interface List with 8 native implementations (i.e. 8 different classes that implement this interface). The most commonly used are ArrayList and LinkedList.\nThe interface List extends the interface Collection.\nSyntax # Here are code snippets for a few operations specified in the interface List.\nCreate a List and populate it: City milan = new City(\u0026#34;milan\u0026#34;, 20100); City florence = new City(\u0026#34;Florence\u0026#34;, 50100); // Creates an empty list of cities List\u0026lt;City\u0026gt; myList = new ArrayList(); // Appends Milan to the list myList.add(milan); // Appends Florence to the list myList.add(florence); // Appends Milan again to the list myList.add(milan); // Creates a list identical to the previous one, but which cannot be modified List\u0026lt;City\u0026gt; myOtherList = List.of(milan, florence, milan); City[] myArray = new City[]{milan, florence,}; // Creates a fixed-lenght \u0026#34;wrapper\u0026#34; list around the array. // No data is duplicated. List\u0026lt;City\u0026gt; yetAnotherList = Arrays.asList(myArray); Retrieve the size of a list: // Outputs 3 System.out.println(myList.size()); Retrieve the element at index i (the first index being 0, like in an array): // Contains (a reference to) Florence City secondCity = myList.get(1); Insert an element at index i (shift the position of all subsequent elements by 1). City trento = new City(\u0026#34;Trento\u0026#34;, 38100); myList.add(1, trento); // Now contains (a reference to) Trento secondCity = myList.get(1); // contains (a reference to) Florence City thirdCity = myList.get(2); Remove the element a index i (shift the position of all subsequent elements by -1), and return it myList.remove(1); // Outputs 3 Sysetm.out.println(myList.size()); // Now contains (a reference to) Florence secondCity = myList.get(1); Remove the first occurrence of an object in the list (shift the position of all subsequent elements by -1): myList.remove(milan); // contains (a reference to) Florence City firstCity = myList.get(0); For more operations, consult the Javadoc of the interface List.\n"},{"id":2,"href":"/docs/objects/sections/objects/","title":"Objects","section":"Objects and classes","content":" Objects # An object is a way to group data in a meaningful way.\nA simple example: JSON objects # Here is a JSON object (in Javascript syntax) that describes the city of Florence:\n{ name: \u0026#34;Florence\u0026#34;, zipcode: 50100 } A JSON object may contain other objects, as well as arrays (of values, objects or arrays). For instance:\n{ name: \u0026#34;Alice\u0026#34;, age: 26, birthPlace: { name: \u0026#34;Florence\u0026#34;, zipcode: 50100 }, jobs: [ { employer: \u0026#34;Kolping\u0026#34;, start: 2021, end: 2022 }, { employer : \u0026#34;Eurac\u0026#34;, start: 2023 } ] } In JSON: - an **element** can be either: - a scalar (e.g. an integer), or - an array of elements, or - an object, - an **object** is a finite set of key-value pairs, where keys are distinct, and each value is an element. Equivalently, a JSON object can be viewed as a function (with finite domain) that maps keys to JSON elements.\nObjects and programming languages # JSON objects do not exactly correspond to the objects that can be created in Java (and many other programming languages). We highlight here two important differences.\nTypes # Exercise Find a JSON object that satisfies the above description but _cannot_ be represented as an object in a (strongly) _typed_ language such as Java, C/C++, C#, etc. Possible solution ```javascript { key: [1, \"a\"]; } ``` In a typed language (like Java), the elements of an array must be of the same type.\nThis is not required in Javascript, Python, etc.\nReferences # A Java (or Python, C#, etc.) object does not contain objects or arrays, but references to objects or arrays. For instance, the equivalent in Java of the above object may be pictured as follows (abusing notation):\n```javascript _1: { name: _2, age: 26, birthPlace: _3, jobs: _4, } _2: ['A','l','i','c','e'] _3: { name: _5, zipcode: 50100 } _4: [ _6, _7 ] _5: ['F','l','o','r','e','n','c','e'] ``` ```javascript _6: { employer: _8, start: 2021, end: 2022 } _7: { employer: _9, start: 2023 } _8: ['K','o','l','p','i','n','g'] _9: ['E','u','r','a','c'] ``` Each object or array has an ID (e.g. _1 in this example), which can be used to refer to it (you can think of this ID as an address in memory).\nAs a consequence, some objects can be created in Java that have no finite representation in JSON. Exercise Find one of these objects. Possible solution ```javascript _1: { name: _2, friends: _3 } _2: ['A','l','i','c','e'] _3: [ _4, _7 ] _4: { name: _5, friends: _6 } _5: ['B','o','b'] _6: [ _1, _8 ] ``` If we try to represent this object in JSON, we get (assuming that we start with Alice): ```javascript { name: \"Alice\", friends: [ { name: \"Bob\", friends: [ { name: \"Alice\", friends: [ ... ]}]}]} ``` \u003e Cyclic references (like in this exercise) naturally occur in object-oriented code. Identifying them may be essential to debug a program that does not terminate or runs out of memory (stack overflow, \u0026hellip;).\n"},{"id":3,"href":"/docs/input/sections/files/","title":"Paths and files in Java","section":"I/O and serialization","content":" Paths and files in Java # Java\u0026rsquo;s initial package for input/output (I/O) is called java.io. A central class in this package is File.\nOver the years, programmers realized that this package had limitations: limited error handling, limited support for file metadata (owner, access rights, etc.), and some performance issues.\nWith Java 7 (2011), A new I/O package called NIO2 was released, with additional features (and in some cases a more concise syntax). A central interface (resp. utility class) in this package is Path (resp. Files).\nHowever, the package java.io is still part of the latest Java release (it has not been deprecated), in part for backward compatibility reasons.\nIn this chapter, we will focus whenever possible on NIO2\u0026rsquo;s classes and methods, rather than java.io. In particular, we will use the Path when possible rather than File.\nNote also that some external libraries (notably Apache commons.io and Guava) provide additional methods for I/O, sometimes with a more concise syntax.\n**_Warning._** Many native Java methods that involve path or file manipulation may throw a [checked exception]() (generally an `IOException`). For instance, among the methods below, this is the case of: - `Path.toRealPath`, - `Files.size`, - `Files.walk`, - etc. As a reminder, when such a method is used, checked exceptions must be either [caught]() or [explicitly rethrown](), otherwise the program will not compile. Paths # An instance of Path represents a path in the hierarchical file system.\nAn instance of Path can be created in multiple ways. For instance:\nPath myPath = Path.of(\u0026#34;path/to/file.txt\u0026#34;); Path samePath = Path.of(\u0026#34;path\u0026#34;, \u0026#34;to\u0026#34;, \u0026#34;file.txt\u0026#34;); // Extend a path Path folder = Path.of(\u0026#34;path/to\u0026#34;); // identical to myPath Path myPathAgain = folder.resolve(\u0026#34;file.txt\u0026#34;); Path names # **_Note._** If the string `path/to/file.txt` is used to create a Java `Path` (or a Java `File`), then the `/` symbol is interpreted (at runtime) as the path separator _of the operating system_ (OS) that executes the program. So you can safely use this syntax, _regardless of your OS_. Precisely: - if the program is executed on macOS, Linux, Android, etc., then this string will be interpreted as is, - if the program is executed on Windows, then this string will be interpreted as `path\\to\\file.txt`. **_Warning._** If the string `path\\to\\file.txt` is used to create a Java `Path`, then this string will be interpreted _as is_. So the program may run on Windows, but fail on other systems. **_Warning._** Paths are _case sensitive_ on Linux, Android, etc., but _case insensitive_ on Windows and macOS. For maximal compatibility, make sure that path names in your code respect the case of your file and directory names. **_Warning._** Do _not_ use [absolute paths]() in your code (e.g. `/home/Alice/workspace/javaProject/myFile.txt`, or `C:\\Users\\Alice\\workspace\\javaProject\\myFile.txt`). Your program may run on your own computer, but will fail on others. Working directory # **_Warning._** When a Java program is executed, relative paths are understood as paths _from_ the current [working directory]() (WD). If you need to know the WD, you can use the following (among other possibilities):\nPaths.get(\u0026#34;\u0026#34;).toAbsolutePath(); This instruction returns an absolute Path to the WD.\nFor instance,\nSystem.out.println(Paths.get(\u0026#34;\u0026#34;).toAbsolutePath()); may output on Windows:\nC:\\Users\\Alice\\workspace\\javaProject or on macOS:\n/Users/Alice/workspace/javaProject or on Linux:\n/home/Alice/workspace/javaProject The Path interface # Here are examples of outputs for some methods of the Path interface (assuming that the WD is /home/Alice/workspace/javaProject):\nPath path = Path.of(\u0026#34;src/main/../main/resources/myFile.txt\u0026#34;); // Outputs \u0026#39;/home/Alice/workspace/javaProject/src/main/../main/resources/myFile.txt\u0026#39; System.out.println(path.toAbsolutePath()); // Outputs \u0026#39;/home/Alice/workspace/javaProject/src/main/resources/myFile.txt\u0026#39; System.out.println(path.toRealPath()); // Outputs \u0026#39;myFile.txt\u0026#39; System.out.println(path.getFileName()); // Outputs \u0026#39;false\u0026#39; System.out.println(path.isAbsolute()); **_Hint._** The method `String.endsWith` can be used to check whether a file has a certain extension. E.g. ```java // Outputs 'true' path.toString().endsWith(\".txt\"); ``` Existence and metadata # Static methods of the class Files can be used to check whether a file or directory exists, and retrieve metadata about it:\nPath path = Path.of(\u0026#34;src/main/resources/myFile.txt\u0026#34;); System.out.println(\u0026#34;Exists = \u0026#34; + Files.exists(path)); System.out.println(\u0026#34;Is directory = \u0026#34; + Files.isDirectory(path)); System.out.println(\u0026#34;Is file = \u0026#34; + Files.isRegularFile(path)); System.out.println(\u0026#34;Is hidden = \u0026#34; + Files.isHidden(path)); System.out.println(\u0026#34;Size = \u0026#34; + Files.size(path) + \u0026#34; bytes\u0026#34;); System.out.println(\u0026#34;Last modified = \u0026#34; + Files.getLastModifiedTime(path)); Navigation # Path path = Path.of(\u0026#34;src/main/resources/myFile.txt\u0026#34;); // Get the parent directory \u0026#39;src/main/resources\u0026#39; Path dir = path.getParent(); // Contains all files and folders in \u0026#39;src/main/resources\u0026#39; List\u0026lt;Path\u0026gt; children = Files.list(dir).toList(); // Contains all files and folders that have \u0026#39;src/main/resources\u0026#39; // as ancestor, including \u0026#39;src/main/resources\u0026#39; itself. List\u0026lt;Path\u0026gt; descendents = Files.walk(dir).toList(); Manipulation # // Create a directory Path folder = Path.of(\u0026#34;myFolder\u0026#34;); Files.createDirectory(folder); // Create nested directories Path subfolder = Path.of(\u0026#34;myFolder/sub1/sub2\u0026#34;); Files.createDirectories(subfolder); // Create a file Path file = Path.of(\u0026#34;myFolder/hello.txt\u0026#34;); Files.createFile(file); // Move/rename a file Path destination = Path.of(\u0026#34;myFolder/sub1/bye.txt\u0026#34;); Files.move(file, destination); // Copy a file Path copy = Path.of(\u0026#34;myFolder/sub1/sub2/bybye.txt\u0026#34;); Files.copy(renamedFile, copy); // Delete a file. Files.delete(copy); // Delete a directory. // The directory must be empty. Files.delete(subfolder); "},{"id":4,"href":"/docs/lambda/sections/pure/","title":"Pure function","section":"Callback methods and lambda expressions","content":" Pure function # Side effects # **_Definition._** A method has **side effects** if it modifies resources (variable, object, array, etc.) that are accessible outside of its scope. Definition # A pure function is a method that intuitively behaves like a mathematical function. More precisely:\n**_Definition._** A **pure function** is a method that: 1. returns a value, 2. returns the _same_ value if called twice with the same arguments, and 3. has no side-effect. Example # Exercise The Java method `createUsers` below violates each of the three properties that define a pure function. Can you see why? How would you rewrite it into a pure function? ```java int[] ids = parseIds(); String[] names = parseNames(); User[] users = new User[ids.length]; createUsers(ids, names, users); void createUsers(int[] ids, String[] names, User[] users) { for(int i = 0; i \u003c ids.length; i++){ users[i] = new User(ids[i], names[i]); } } ``` Possible solution ```java int[] ids = parseIds(); String[] names = parseNames(); User[] users = createUsers(ids, names); User[] createUsers(int[] ids, String[] names) { User[] users = new User[ids.length]; for(int i = 0; i \u003c ids.length; i++){ users[i] = new User(ids[i], names[i]); } return users; } ``` Benefits # Easier debugging # Because it has no side effect, a pure function may cause of a bug only if it returns an incorrect value. Because it only depend on its arguments, the behavior of a pure function is easier to predict. Readability # The behavior of a pure function can be fully documented by describing its signature (arguments and return value).\nEasier parallelization # Consider two pure functions $f$ and $g$. If the input of $f$ (resp. $g$) does not depend on the output of $g$ (resp. $f$), then they can be executed in any order (therefore also in parallel).\n**_Example._** If $f$ and $g$ are pure functions, the two programs below (written in pseudocode) are equivalent: ```perl x = f(a) y = g(b) result = x + y ``` ```perl y = g(b) x = f(a) result = x + y ``` "},{"id":5,"href":"/docs/intro/","title":"This course","section":"Docs","content":" Structure and organization of the course # This chapter explains how the course is structured and briefly summarizes its content.\n"},{"id":6,"href":"/docs/lambda/sections/anonymous/","title":"Anonymous method","section":"Callback methods and lambda expressions","content":" Anonymous method # An **anonymous** method is a method without a name. Illustration # The two following Java methods only differ by their name:\n```java int square(int x){ return x * x; } ``` ```java int toThePowerOfTwo(int x){ return x * x; } ``` So in a sense, these two methods are the same method.\nAn anonymous method simply abstracts away from the name of the method. For instance, in Java, the two methods above could be described with the following lambda expression:\n(int x) -\u0026gt; { return x * x; } Or (with a more concise syntax):\nx -\u0026gt; x * x "},{"id":7,"href":"/docs/objects/sections/classes/","title":"Class and instance","section":"Objects and classes","content":" Class and instance # A class can be viewed as a blueprint for a set of similar objects.\nFor instance, consider the two objects:\n```javascript { name: \"Florence\", zipCode: 50100, region: \"Tuscany\" } ``` ```javascript { name: \"Rome\", zipCode: 00100, region: \"Lazio\" } ``` Each of these objects describes a city, and they share the same keys (name, zipCode and region). A possible class for these two objects may enforce this structure, and it could be named City. An object that follows this blueprint is called an instance of this class.\nDeclaration # In a typed language (like Java), a class must specifies not only the \u0026ldquo;keys\u0026rdquo; of its instances, but also their types. For instance, the class City could be declared as follows in Java:\npublic class City { String name; int zipCode; String region; ... } In Java, a class is often declared in a dedicated file. This file must have the _same name_ as the class (e.g. `City.java` in this example). The three variables (name, zipCode and region) are called attributes (or sometimes member variables).\nConstructor # A class also needs a special method called a constructor.\nThe constructor is in charge of creating a (fresh) instance of the class.\nIn Java (as in Python, C#, etc.), the constructor does not return the instance itself, but a reference (sometimes called \u0026ldquo;pointer\u0026rdquo;) to this instance.\n**_Note._** A class may have several constructors (with different signatures). Writing a constructor in Java # The constructor of a Java class must have the _same name_ as the class. For instance:\npublic class City { String name; int zipCode; String region; public City(String n, int z, String r){ name = n; zipCode = z; region = r; } ... } **_Note._** In this example, the variable names `n`, `z` and `r` are not very explicit. However, using `name`, `zipCode` and `region` would be ambiguous (because these names are already used for the attributes of the class). In Java, we can use the prefix `this.` to refer to attribute names, thus eliminating the ambiguity. For instance: ```java public class City { String name; int zipCode; String region; public City(String name, int zipCode, String region){ this.name = name; this.zipCode = zipcode; this.region = region; } ... } ``` Calling a constructor in Java # A Java constructor is called with the keyword new. For instance:\nCity myCity = new City(\u0026#34;Florence\u0026#34;, 50100, \u0026#34;Tuscany\u0026#34;); City yourCity = new City(\u0026#34;Rome\u0026#34;, 00100, \u0026#34;Lazio\u0026#34;); **_Note._** The object that is created in memory contains extra information, in particular a reference to its class. This allows type checking, casts, etc. (more on this later). Accessing an object in Java # The attributes of an object can be accessed like regular variables, using ., followed by the name of the attribute. For instance,\nCity thatCity = new City(\u0026#34;Siena\u0026#34;, 53100, \u0026#34;Lazio\u0026#34;); System.out.println(\u0026#34;Wrong region: \u0026#34; + thatCity.region); thatCity.region = \u0026#34;Tuscany\u0026#34;; System.out.println(\u0026#34;Better now: \u0026#34; + thatCity.region); will output\nWrong region: Lazio Better now: Tuscany Reference type vs primitive type # Recall that a Java constructor returns a reference to the object that it creates. So in the example above, the value of each variable (myCity and yourCity) is a reference, not the object itself.\nThis also holds for:\nvariables of type String, variable with an array type (like int[] myArray). The types of these variables (e.g. City, String or int[]) are called reference types.\n**_Syntax._** In Java, types that start with a _capital letter_ (like `City` or `Array`) are usually reference types. Types that are not references types (like int or char) are called primitive types.\nThe value of a reference cannot be output (printed, displayed, etc.) by a program. But this value can be modified or compared to another.\nExercise What is the output of the following program? ```java City aCity = new City(\"Matera\", 75100, \"Basilicata\"); City theSameCity = new City(\"Matera\", 75100, \"Basilicata\"); System.out.println(aCity == theSameCity); System.out.println(aCity.zipCode == theSameCity.zipCode); System.out.println(aCity.name == theSameCity.name); ``` Solution ```java false true false ``` Exercise What is the output of the following program? ```java City anotherCity = new City(\"Bologna\", 40100, \"Emilia-Romagna\"); City yetAnotherCity = new City(\"Mantua\", 46100, \"Emilia-Romagna\"); yetAnotherCity.name = anotherCity.name; System.out.println(yetAnotherCity.name); anotherCity = yetAnotherCity; System.out.println(anotherCity.zipCode); System.out.println(anotherCity == yetAnotherCity); ``` Solution \u003e Exercise 2. \u003e \u003e ```java \u003e \"Bologna\" \u003e 46100 \u003e true \u003e ``` Passing by value or by reference # Programming languages differ in the way arguments are passed to methods. Two common strategies are:\npassing by value: the method receives as input a copy of each argument, passing by reference: the method receives as input a reference to each argument. Consider for instance the following program (in pseudocode):\nint myInteger = 0 myMethod(myInteger) print(myInteger) void myMethod(int argument){ argument += 1 } If the argument is passed by value, then the program will print 0. If the argument is passed by reference, then the program will print 1. Java passes by value # In Java (and many other programming languages, like C, Python, Javascript, etc.), arguments are passed by value. So the above program translated in Java will print 0.\n**_Warning._** Consider a method with a [reference type](#refType) argument. Because Java passes by value, this method will receive a copy of this argument. But this is a copy _of the reference_, not a copy of the object itself. Exercise What does the following Java program print? ```java int myInteger = 0; City myFirstCity = new City(\"Florence\", 50100, \"Tuscany\"); City mySecondCity = new City(\"Mantua\", 46100, \"Emilia-Romagna\"); myMethod(myInteger, myFirstCity, mySecondCity); System.out.println(myInteger); System.out.println(myFirstCity.zipCode); System.out.println(mySecondCity.zipCode); public void myMethod(int integer, City firstCity, City secondCity){ integer += 1; System.out.println(integer); firstCity.zipCode = 20590; System.out.println(firstCity.zipCode); secondCity = new City(\"Rome\", 00100, \"Lazio\"); System.out.println(secondCity.zipCode); } ``` Solution ```java 1 20590 00100 0 20590 46100 ``` "},{"id":8,"href":"/docs/datastructures/sections/hash/","title":"Hash table","section":"Data structures","content":" Hash table # A hash table is a data structure often used to implement an associative array (like a Java Map).\nAssociative array # **_Reminder._** An **associative array** (or **map**) is a finite set of key-value pairs, where keys are distinct. **_Terminology._** A key-value pair in associative array is also called an **entry**. **_Running example._** The following associative array has 5 entries. $\\qquad$ 1 $\\mapsto$ `Alice` $\\qquad$ 3 $\\mapsto$ `Bob` $\\qquad$ 4 $\\mapsto$ `Carol` $\\qquad$ 9 $\\mapsto$ `Dan` $\\qquad$ 12 $\\mapsto$ `Eve` In this associative array, keys are integers, and values are strings. **_Notation._** We will use $K$ for the type of the keys (integers in this example), and $V$ for the type of the values (strings in this example). Structure # A hash table is an array $A$, whose entries are called **slots** (or **buckets**). Hash tables come in two varieties:\nchaining hash tables and hash tables with open indexing. In a **chaining hash table**, each slot is a pointer to a data structure (typically a linked list). These data structures store the entries (a.k.a. key-value pairs) of the associative array. **_Example (continued)._** The following is a chaining hash table, which stores our associative array. ![](/img/hashTable/ex/hashTable.svg) The array has 4 slots, each of which points to a (possibly empty) linked list. In a hash table with **open indexing**, each slot stores one entry of the associative array. We will discuss open indexing later in this section (and focus for now on chaining hash tables).\nHash function # In a hash table, whether a certain entry is assigned to a certain slot is determined by a so-called hash function.\n**_Definition._** A **hash function** maps each key in $K$ to an index in $A$. **_Example (continued)._** In the above example, we used $\\qquad h(k) = k \\mod 4$ as our hash function. For instance, $\\qquad h(9) = 9 \\mod 4 = 1$ which explains why the entry $\\qquad$ $9 \\mapsto$ `Dan` is assigned to slot $1$. Collision # The size of the set $K$ of possible keys is often (much) larger than the size of the hash table $A$.\n**_Example (continued)._** In our example, $K$ is the set of integers. In Java, this set has size $2^{32}$ (i.e. more than 4 billion), which is unrealistic for the size of $A$. As a consequence, hashing functions are usually not injective.\n**_Terminology._** A **collision** occurs when two entries of an associative array are assigned to the same slot. In other words, a collision occurs if the associative array contains two entries ${k_1 \\mapsto v_1}$ and ${k_2 \\mapsto v_1}$ such that $h(k_1) = h(k_2)$. **_Example (continued)._** In the example above, 1 $\\mapsto$ `Alice` and 9 $\\mapsto$ `Dan` are assigned to the same slot, because $$ h(1) = h(9) = 1 $$ Collisions are often unavoidable (this is a consequence of what is sometimes called the birthday paradox).\n**_Example._** Let us assume that our hashing function $h$ partitions $K$ evenly across slots (like the function $h(x) = x \\mod 4$ used above). - If $A$ has $16$ slots (which is the default size of a hash table in Java), then the probability of a collision is $\\ge 0.5$ for $5$ entries already - If $A$ has $1000$ slots, then the probability of a collision is $\\ge 0.5$ for $38$ entries already, and $\\ge 0.9$ for $69$ entries already. Performance # **_Reminder._** An associative array exposes (at least) the following methods: - **lookup** (or **get**) takes a key as input, and returns the value for this key (if any). - **insert** (or **put** ) inserts a pair _(key, value)_. If an entry for this key was already present, then overwrites its value. - **remove** (or **delete**) deletes the entry for a given key (if any). Worst case # In a chained hash table, in order to check whether the structure contains an entry for an input key $k$, we need to:\ncompute $h(k)$ search for an entry with key $k$ in the data structure that $A[h(k)]$ refers to (if any). Exercise Consider a associative array with $n$ entries, stored as a chained hash table with linked lists (as above). What is the worst case asymptotic running time of the lookup operation? Instead, what would be the best possible scenario? Solution A worst possible input (of size $n$) for the lookup operation consists of an input key $k$ and an input hash table $A$ with hash function $h$ such that, for each pair $k' \\mapsto v$ stored in $A$: - $k' \\neq k$ and - $h(k') = h(k)$. In this case, any algorithm for lookup would need to inspect the whole list $A[h(k)]$. So the worst-case running time of such an algorithm is in $\\Theta(n)$. A best possible input consists of an input key $k$ and an input hash table $A$ with hash function $h$ such that $h(k') \\neq h(k)$ for each pair $k' \\mapsto v$ stored in $A$. A standard algorithm for lookup in this case would have constant running time (expressed as function of $n$). Load factor and rehashing # **_Definition._** Let $n$ be the number of entries in the associative array, and let $m$ be the size of $A$. The ratio $\\alpha = \\frac{n}{m}$ is called the **load factor** of the hash table. A high load factor increases the chances of collision, thus affecting performance.\nWhen the load factor becomes too high, the hash table is typically rehashed, meaning that a larger hash table is created (thus with a different hashing function), in which entries are re-inserted.\nFrom Wikipedia, for a chaining hash table, the maximal acceptable load factor is between 1 and 3.\nAverage running time # A good hash function is usually expected to distribute keys evenly across slots.\nIn a chaining hash table, this means that all lists should have length close to the load factor $\\alpha$.\nUniversal hashing refers to using not one, but a collection of hash functions that satisfies certain properties, and randomly selecting one of these functions at runtime.\nThis guarantees that for a fixed set $S \\subset K$ of keys with size $n$, and for a fixed $k \\in S$, the average length of the slot for $k$ is the load factor $\\alpha$.\nIn other words, the average running time of lookup, insertion and deletion is $\\alpha = \\frac{n}{m}$.\nIf we assume that the size $m$ of $A$ is always reasonable for the number $n$ of entries of the associate array, then $\\alpha$ is independent of $n$. So under this assumption, the average running time of lookup, insertion and deletion is constant (i.e. is in $\\Theta(1)$.\nOpen indexing # In a hash table with **open indexing**, each slot stores at most _one_ entry of the associative array. In case of collision between two entries, one of them is assigned to a free slot. This is achieved via a so-called probing function (from indices to indices), which defines an order over indices. More precisely:\nInsert. When inserting an entry with key $k$, if the slot $A[h(k)]$ is already occupied, then the \u0026ldquo;next\u0026rdquo; free slot is used instead (where \u0026ldquo;next\u0026rdquo; depends on the probing function). Lookup. When searching for the entry with key $k$, the first investigated slot is $A[h(k)]$, then its successor $s$ (according to the probing function), then the successor of $s$, etc., until we reach the entry with key $k$ (if present) or an empty slot. Delete. When deleting a entry, the slot that it was occupying cannot be deleted, because the resulting empty slot may break future searches. Instead, the slot is marked as a so called tombstone, which does not interrupt a search, but can still be used for future insertions. Performance # The (average and worst case) asymptotic costs of these operations are identical to the ones for chained hash tables.\nOpen addressing can be more efficient in practice than chaining, because it is more likely to benefit from caching (since the whole hash table it an array, it is likely to be contiguous in memory).\nA downside is the maximal acceptable load factor, which is (necessarily) $\\le 1$ (from Wikipedia still, between 0.6 and 0.75).\nin Java # Implementation # Java uses chained hash tables internally, with 16 slots by default.\nEach slot points to a linked list by default.\nIf the maximal acceptable load factor is exceeded, then the hash table is rehashed (as expected).\nIn addition, Java uses a maximal load threshold for an individual slot. If this value is exceeded (but the maximal load factor is not), then the linked list for this slot is converted to a red-black tree.\nAssociative array # As we saw in the dedicated section, the interface java.util.Map represents an associative array.\nThe class java.util.HashMap implements the interface as a hash table.\nThe class java.util.LinkedHashMap also implements this interface as a hash table. However, in addition, each entry contains two pointers to its processor and successor (if any) in the order of insertion, thus forming a double linked list, independent of the hash table itself. This allows iterating over the entries of a map in a predictable order (precisely, their insertion order), which is not possible with a HashMap.\n**_Warning._** In a `LinkedHashMap`, overwriting the value of an entry (with the method `Map.put`) does _not_ affect the order of insertion. Set # As we saw in the dedicated section, the interface java.util.Set represents a set.\nThe class java.util.Hashset implements this interface as a hash table, where keys are the elements of the set, and an \u0026ldquo;entry\u0026rdquo; consists of a key only (i.e. has no value).\nThe class java.util.LinkedHashSet also implements this interface as a hash table. It is analogous to LinkedHashMap, i.e. it guarantees that iteration preserves the order of insertion.\nhashCode # In Java, the keys of a `Map` and the entries of a `Set` are _objects_. So a Java hash function must map an _object_ to a hash table slot. Technically, this function is the composition of: - the function `hashCode`, which maps an object to an `int`, and - a proper hash function $h$ that maps this `int` to a hash table slot. The function hashCode is an instance method of the class Object, thus it is inherited by default by all objects. This function behaves like a pure function, in the sense that it must return twice the same int if it is called twice for the same object. This property must be preserved if the method is overridden.\nThe hash function $h$ is also a function in the mathematical sense. Therefore the composition of these two functions has this property. As a consequence, a same key is always mapped to the same slot.\nhashCode and equals # **_Warning._** In a Java hash table, two keys $o_1$ and $o_2$ are considered equal iff $\\qquad o_1$.`equals(`$o_2$`)` returns `true`. Exercise Consider the following Java class `City`, which overrides the method [equals](http://localhost:1313/docs/objects/sections/comparing/#equals), so that two cities are considered equal iff they have the same name and zip code. ```java public class City(){ String name; int zipCode; public City(String name, int zipCode){ this.name = name; this.zipCode = zipCode; } @Override public boolean equals(Object o) { if (this == o) { // same reference return true; } if (o == null || getClass() != o.getClass()) return false; // o is null or has a different type } City downcastObject = (City) o; return zipCode == downcastObject.zipCode \u0026\u0026 name.equals(downcastObject.name); } ``` What does the following program output? ```java City bologna = new City(\"Bologna\", 40100); City bolognaAgain = new City(\"Bologna\", 40100); Set cities = new HashSet(); cities.add(bologna); System.out.println(cities.contains(bolognaAgain)); ``` Solution The output is unpredictable. Observe that the variables `bologna` and `bolognaAgain` point to two different objects $o_1$ and $o_2$. In the hash table that stores the set `cities`: - the slot associated to $o_1$ is $i_1 = h$($o_1$.`hashCode()`), - the slot associated to $o_2$ is $i_2 = h$($o_2$.`hashCode()`). Since $o_1$ and $o_2$ are different objects, $i_1$ and $i_2$ _may of may not_ be identical. The instruction `cities.add(bologna)` adds a node with key $o_1$ to $A[i_1]$. Then the instruction `cities.contains(bolognaAgain)` searches for a node with a key equal to $o_2$ in $A[i_2]$. - If $i_1 = i_2$ (i.e. if we have a collision), since $o_1$`.equals(`$o_2$`)` evaluates to true, the method `contains` will return `true`. - If $i_1 \\neq i_2$, since the slot $A[i_2]$ is empty, the method `contains` will return `false`. **_Warning._** As show with this exercise, if a class overrides `equals` without overriding `hashCode`, then the behavior of the three basic operations on hash tables (insertion, lookup and deletion) may depend on [collisions](#collision). This makes the behavior of several methods implemented by HashMap, LinkedHashMap, HashSet and LinkedHashSet (among others) unpredictable.\nTo avoid this, whenever equals is override, hashCode should be overridden accordingly.\n**_Example(continued)._** `hashCode` could be implemented as follows: ```java public class City(){ ... @Override public int hashCode(){ return name.length + zipCode; } } ``` In the example above, any (pure) function that produces an int out of the values of name and zipCode could in theory be used to implement hashCode in the class City.\nHowever, the choice of this function may affect performance.\n**_Example(continued)._** The following implementation of `hashCode` also complies with the implementation of `equals` above. However, it has the effect of mapping all keys with type `City` to the same hash table slot. ```java public class City(){ ... @Override public int hashCode(){ return 1; } } ``` This is why a common practice consists in implementing hashCode in terms of the method hashCode of the selected attributes (and implement the method hashCode of these attributes similarly, in a recursive fashion).\n**_Note._** Most native Java classes (like `String`, `Integer`, `Boolean`, `ArrayList`, `HasSet`, etc.) already implement `hashCode` (in accordance with `equals`). The utility method Objects.hash takes any number of arguments, and wraps the ones that have primitive types (e.g. int into Integer). It returns an int whose value is a function of the outputs of the respective hashCode methods of the arguments.\n**_Example(continued)._** In our example, we can implement `hashCode` as follows: ```java public class City(){ ... @Override public int hashCode() { return Objects.hash(name, zipCode); } } ``` The returned value depends on the values of `name.hashCode()` and `Integer.valueOf(zipCode).hashCode()`. "},{"id":9,"href":"/docs/interfaces/sections/java_interfaces/","title":"Java interfaces","section":"Interfaces","content":" Java interfaces # A Java interface is a programming interface with additional (object-oriented) features.\nSyntactically, a Java interface is similar to a class. But (in its simplest form), it contains no code. Instead, it specifies the behavior of some methods (which are implemented in some classes).\nExamples # The implementation of our game contains an interface called Snapshot, which describes what a game snapshot is. This interface specifies (among others) a method called getSizeOfReinforcement, as follows:\npublic interface Snapshot { ... /** * Returns the number of units that will enter the board if reinforcement * is called for the input player. */ int getSizeOfReinforcement(Player player); ... } Note that this description contains no code.\nA Java interface acts not only as documentation, but also as a contract : any (non-abstract) class that implements this interface must implement all methods declared in the interface (otherwise the program will not compile).\nA Java interface can be used to specify how two components of a system communicate (before the interface is even implemented!). For instance, the Snapshot interface specifies which information must be provided by our backend to the component in charge of displaying the game on screen.\nThe name of an interface can be used as a reference type (similarly to the name of a class). For instance, the Snapshot interface also specifies a method\nBoard getBoard(); which must return an object of type Board. And Board is itself an interface, which specifies the information needed to draw the game board (units, position, etc).\nHere is for instance a fragment of the Board interface:\n/** * Board for an ongoing game. * This is a two-dimensional grid. * * Tile coordinates are natural numbers and start at 0. * The top left tile has coordinates (0,0). */ public interface Board { ... /** * Returns true if the input coordinates are within the board\u0026#39;s boundaries */ boolean areValidCoordinates(int rowIndex, int columnIndex); /** * Removes the unit standing at the input coordinates, and does nothing * if there is none. */ void removeUnit(int rowIndex, int columnIndex) throws CoordinatesOutOfBoardException; ... } Finally, the interface DisplayManager specifies a method that can be called (e.g. from the backend) to draw a Snapshot on screen (together with a message):\npublic interface DisplayManager { ... /** * Displays the input snapshot on screen, as well as the input message. */ void drawSnapshot(Snapshot snapshot, String message); ... } Observe that these interfaces only specify what classes should implement, not how. In other words, these interfaces specify how components can communicate without exposing unnecessary implementation details.\nWhen to use a Java interface? # Technically, Java interfaces are not needed in a project. But they can make collaboration within a team of developers significantly easier. In particular:\nAn interface is a convenient way to expose what is needed to interact with your code, while hiding the details of your implementation. For instance, the method drawSnapshot (mentioned above) can be called to draw a snapshot on screen, without knowing how this method is implemented.\nAs a contract, an interface allows two programmers to work independently, ensuring interoperability between the methods and/or components that they are respectively developing.\nInheritance # An interface in Java can extend another interface, like a class can extend another class, with the same keyword extends.\nHowever, Java interfaces support multiple inheritance (whereas java classes do not). This means that an interface A can extend two interfaces B and C even if B and C do not extend each other.\nImplementing an interface # In Java, the keyword implements is used to indicate that a class implements an interface. For instance:\npublic class SnapshotImpl implements Snapshot { ... } **_Note._** It is good practice to avoid a class and an interface with the same name (even if they describe the same objects). To differentiate them, you may for instance use the suffix `Impl`, as illustrated above. Consider a class _C_ that implements an interface _I_ : - if _C_ is abstract, then it **_can_** implement some of the methods declared in _I_ - if _C_ is not abstract, then each method declared in _I_ **_must_** be implemented in _C_ (or some superclass of _C_ ), otherwise the program will not compile. Exercise The program represented by the following diagram does not compile. Can you see why? ![](/img/diagrams/plantuml/abstract_inherit.svg) Solution The class `Butterfly` does not implement the method `sleep`. \u003e **_Note._** \u003e In this example, the class `Butterfly` inherits an implementation of `boost` (from `AbstractUnit`), and [overrides](http://localhost:1313/docs/objects/sections/methods/#overriding) it. \u003e This is _not_ an error. Since Java interfaces support multiple inheritance, a Java class can implement several interface that do not extend each other.\nFor instance, the class Unicorn could implement an interface Animal and another interface ImaginaryCreature, even though none of these two interfaces extends the other (not all animals are imaginary, and not all imaginary creatures are animals). This would be declared as follows:\npublic class Unicorn extends MobileUnit implements Animal, ImaginaryCreature { ... } Exercise The program represented by the following diagram does not compile. Can you see why? ![](/img/diagrams/plantuml/multiple_inherit.svg) Solution The class `Unicorn` does not implement the method `hide`. Interfaces vs abstract classes # In theory, Java\u0026rsquo;s interfaces and abstract classes serve different purposes:\nabstract classes are meant to factorize code (i.e. avoid redundant code), whereas interfaces are meant to document code and act as a contract. However, in practice, they have partially overlapping features, which may be confusing.\nIn particular:\nan abstract class can have abstract methods, which behave similarly to interface methods (with the additional constraint that an abstract method must be implemented by at least one subclass). Since Java 8 (2014), interfaces can carry code, in so-called default methods. This feature was introduced for backward compatibility reasons, but arguably contradicts the meaning of the term \u0026ldquo;interface\u0026rdquo;. A benefit of default methods (i.e. methods implemented in interfaces) is that they allow multiple inheritance of implemented methods (since interfaces allow multiple inheritance), which is not possible with classes. For this reason, some authors (like Joshua Bloch) recommend using default methods instead of abstract methods. However, a program where interfaces play the role of abstract classes may be confusing for less experienced Java developers.\nFor this course, we chose to present Java interfaces from a more traditional (pre-Java 8) perspective, because this perspective is arguably easier to understand, and because this is still the dominant usage of Java interfaces. However, for your project, feel free to deviate from this model if you think that this is appropriate (in particular if you need multiple inheritance).\n"},{"id":10,"href":"/docs/project/sections/board_game/","title":"Option 2: board game","section":"Project","content":" Option 2: board game # The second project option available to you consists in developing a video game with mechanics analogous to the ones of Might \u0026amp; Magic: Clash of Heroes or Legend of Solgard.\nStudents who choose this option you will be provided:\na basic graphical user interface (GUI) that they can reuse and/or customize, examples during lectures that they may adapt to their project. Requirements # The minimal requirement to submit this project is a player vs player game playable on a single machine.\nBut of course, you are free to go further and add your own features. Among other possibilities, you could for instance:\nimplement new mechanics (e.g. a rock-paper-scissor logic for unit encounters, events that may affect the board, etc.), make the game deterministic (i.e. eliminate randomness), create units with specific behaviors, implements scripted encounters (\u0026ldquo;boss fights\u0026rdquo;), implement a story, character progression, etc., develop a player vs bot mode, etc, **_Note._** If you choose the last options in the list above (player vs bot), then you may benefit from an algorithm seen in the chapter on [recursion](). Besides, if several groups choose this option, we may organize a competition between bots (provided that they play by the same rules). Guidelines # GUI # The source code for the GUI can be cloned from GitHub. The project is designed so that:\nyou can develop a fully functional game (player vs player or player vs bot) by focusing exclusively on the backend (i.e. the mechanics of the game), without modifying the GUI. backend and frontend are decoupled. Communication between frontend and backend is specified via Java interfaces. It revolves around the notion of a game snapshot, which contains all the information needed to describe a state of the game (equivalently, you can think of a snapshot as a save state). In particular, snapshots are independent of a specific GUI.\nFor instance, a method is available that allows you to pass a snapshot to the GUI component. When you call this method, the snapshot will be drawn on screen, replacing the previous one (if any).\nAs input, your code receives the next action of the active player (for instance, delete the unit present on a specific tile). These are again specified by an interface. Your code should react accordingly: modify the current snapshot, and then send it the GUI component for display.\nThe README.md file (at the root of the project) contains a description of the different components and interfaces, as well as building instructions, and explains where your code could fit. Read it carefully before you start working on your project!\n**_Note._** You are of course free to modify the interfaces that come with the project. But this may require modifying the implementation of the GUI. **_Disclaimer._** By design, the project compromises _performance_ for _simplicity_ and _modularity_. This is _not_ how a resource intensive game would be implemented. More generally, this exercise is not meant to teach game development, but general-purpose programming and problem solving. "},{"id":11,"href":"/docs/stream/sections/init/","title":"Source","section":"Streams in Java","content":" Source # Collection # A stream can be created out of a Java Collection with the instance method stream.\n**_Example._** ```java List units = getUnits(); units.stream(); ``` If the collection has a predictable order of iteration (e.g. if the collection is a List), then the elements will appear in this order in the stream.\nTo create a stream out of the entries of a map, we can use the instance method Map.entrySet (which returns a set).\n**_Example._** ```java Map map = getMap(); map.entrySet().stream(); ``` Array # A stream can be created out of a Java array with the static method Arrays.stream.\n**_Example._** ```java Unit[] units = getUnits(); Arrays.stream(units); ``` Generate a stream with indices # An IntStream is a stream of int (see the dedicated section on streams with primitive numeric types). An IntStream can for instance be created with the static method IntStream.range, as follows:\n**_Example._** ```java // Contains [0, 2] List evenIntegers = IntStream.range(0, 4) // produce the stream (0, 1, 2, 3) .filter(i -\u003e i % 2 == 0) // retain even numbers .toList(); ``` This can be used to iterate over a list or array while keeping track of the elements\u0026rsquo; positions.\n**_Example._** ```java Unit[] units = getUnits(); List evenUnits = IntStream.range(0, units.length) .filter(i -\u003e i % 2 == 0) .mapToObj(i -\u003e units[i]) .toList(); ``` However, for this usage, external libraries offer more natural options. For instance, the StreamEx library can create a map from index to entry in an array, and generate a stream out of the entries of this map (analogous to the set of entries produced by Map.entrySet).\nUnit[] units = getUnits(); List\u0026lt;Unit\u0026gt; evenUnits = EntryStream.of(units) .filterKeyValue((index, unit) -\u0026gt; index % 2 == 0) .values() .toList(); } To use StreamEx in a Maven project, declare this dependency:\n\u0026lt;dependencies\u0026gt; ... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;one.util\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;streamex\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.8.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; ... \u0026lt;/dependencies\u0026gt; or in a Gradle project:\nimplementation group: \u0026#39;one.util\u0026#39;, name: \u0026#39;streamex\u0026#39;, version: \u0026#39;0.8.2\u0026#39; "},{"id":12,"href":"/docs/env/sections/backup/","title":"Backup","section":"Development environment","content":" Backup # Make sure that your work does not depend on your laptop. You should be able to resume your work easily on another computer if your laptop gets lost, damaged, etc.\nYou should also be able to recover your data if you accidentally delete it from your hard drive.\nWhich information to back up # As a priority, make sure that there exist copies (outside of your hard drive) of:\nyour passwords (and possibly identifiers), and your own work (code, reports, slides, notes, CV, etc.). These copies may be stored on the cloud, an external disk, another computer, etc.\nOptionally, you may also back up:\nconfiguration files present in your home folder. For development purposes, you generally do not need to back up:\ngenerated content (back up the code that generates it instead), large datasets (these should not be present on your laptop to start with), programs (they can be reinstalled). How to back up # Password managers # For passwords, your password manager may provide an online backup option. Other password managers (like pass) may let you synchronize your passwords via git.\nGit # For your own work and/or configuration files, git can be an option.\nA git repository is (roughly speaking) a directory that can be synchronized across different machines (see the dedicated chapter of this course for an introduction to git). For instance, you may create a (private) git repository for each course that you follow and/or each project that you start. Several providers (GitHub, Gitlab, Bitbucket, etc.) can host copies of your (public or private) repositories on the cloud for free.\nThe benefits are:\nthe possibility to recover any previous state of your work (a git repository stores the whole history of modifications made to it), fine-grained control over your backup: for instance, you can use a \u0026quot;.gitignore\u0026quot; file to exclude files or subfolder that do not need to be backed up. **_Note._** If a git repository is a subfolder of another git repository, then the inner repository is not included in the history of the outer one. **_Limitation._** Git is _not suited_ to large volumes of data (more than 1 GB in the same repository). This is usually not an issue for your own work (code, notes, reports, etc.) as a student in computer science. However, git should _not_ be used to back up large collections of images, audio files, videos, etc. Other solutions # Numerous programs allow you to back up (part of) the content of your hard drive. One of them may be pre-installed on your operating system.\nYou can back up content on a device that you own (e.g. on an external hard drive), or on the cloud. In the latter case, some fee may apply (depending on the volume of data).\nRestore points # Programs such as System restore (Windows), macOS Recovery (macOS) or Timeshift (Linux) allow you to create snapshots of your system (typically for what lives outside of your home folder), and revert your system\u0026rsquo;s state to one of these snapshots.\nThis can be useful in case of a corrupted system. However, it may be difficult to determine at which point in time the system was \u0026ldquo;healthy\u0026rdquo;. Note also that in such scenarios, a fresh re-install may be a simpler to restart on a sane basis.\n"},{"id":13,"href":"/docs/simplify/sections/boolean/","title":"Boolean conditions","section":"Simplifying code","content":" Boolean conditions # A complex boolean sub-expression in the scope of a negation can be difficult to read and/or debug.\n**_Example._** The two following expressions are equivalent (but the latter is arguably easier to read): $$ \\neg(\\neg(a \\lor b) \\land \\neg (\\neg c \\lor d)) $$ $$ a \\lor b \\lor \\neg c \\lor d $$ Simplification # In a Boolean expression, negations can always be \"pushed\" inside parentheses, as follows: - base case: - $\\neg (x = y)$ becomes $x \\neq y$ - $\\neg (x \\le y)$ becomes $x \u003e y$ - $\\neg (x \u003e y)$ becomes $x \\le y$ - etc. - inductive case: - $\\neg (\\phi \\land \\psi)$ becomes $\\neg \\phi \\lor \\neg \\psi$ - $\\neg (\\phi \\lor \\psi)$ becomes $\\neg \\phi \\land \\neg \\psi$ Exercise Simplify the following Java condition: ```java !(x != y \u0026\u0026 ( !x.hasNext() || !y.hasNext() || x.next() != y.next())) ``` Solution The expression is of the form ```java !(x != y \u0026\u0026 ) ``` So we can transform it into ```java x == y || ! ``` Next observe that ```java ! ``` is ```java !( !x.hasNext() || !y.hasNext() || x.next() != y.next()) ``` which can be transformed into ```java x.hasNext() \u0026\u0026 y.hasNext() \u0026\u0026 x.next() == y.next() ``` So the whole expression becomes ```java x == y || ( x.hasNext() \u0026\u0026 y.hasNext() \u0026\u0026 x.next() == y.next() ) ``` "},{"id":14,"href":"/docs/recursion/sections/correctness/","title":"Correctness","section":"Recursion","content":" Correctness # To check whether a recursive method is correct, it is (usually) sufficient to check that the two following two properties hold: 1. **_(Base case(s))._** The method is correct for the smallest possible inputs. 2. **_(Inductive case)._** For an arbitrary $n$: $\\qquad\\qquad$ _if_ the method is correct for all inputs of size $\\leq n$, _then_ it is correct for all inputs of size $n+1$. **_Example._** Consider the algorithm seen [earlier](#binaryTrees) to compute the sum of all nodes in a binary tree, if nodes are instance of the following class: ![](/img/diagrams/plantuml/nodeWithIntLabel.svg) ```java {linenos=true} int sum(Node root){ // base case if (root == null){ return 0 } // inductive case return root.value + sum(root.leftChild) + sum(root.rightChild) } ``` For the size $n$ of the input, we can use in this example the height of the tree (i.e. the length of its longest branch). Let use verify that our two properties hold: 1. **_(Base case)._** The sum of all labels in an empty tree is 0, so the method is trivially correct. 2. **_(Inductive case)._** Consider any natural number $n$, and any tree of height $n+1$, with root $r$. And let us assume that the method `sum` is correct for all trees of height $\\le n$. We need to show that under this assumption, the method is correct for the tree rooted in $r$. - Observe that the subtrees rooted in `r.left` and `r.right` have height $\\le n$. - So from our assumption, the two recursive calls (Line 6) to the method `sum` are correct, meaning that they return the sum of all values in each of the two subtrees. - Next, observe that the sum of all labels in our tree must be equal to the sum of all values in these two subtrees, plus the label of $r$. Which is precisely what the method returns. These two properties (1 and 2 above) provide an immediate proof by induction that the method is correct for all inputs.\n**_Proof._** Partition the set of all possible inputs by size, i.e. (assuming that inputs in our base case have size 0): - the set $S_0$ of all inputs of size $0$, - the set $S_1$ of all inputs of size $1$, - the set $S_2$ of all inputs of size $2$, - etc. In order to show that the method is correct, it is sufficient to show that it is correct for each $S_i$ (where $i \\in \\mathbb{N}$). Now let us assume that properties 1 and 2 hold, i.e.: 1. **_(Base case)._** **The method is correct for** $S_0$. 2. **_(Inductive case)._** For any $n$, $\\qquad\\qquad$ _if_ the method is correct for $S_0 \\cup S_1 \\cup ... \\cup S_n$, then it is correct for $S_{n+1}$. - We know that Property 2 holds for an arbitrary $n$. In particular, it holds for $n= 0$. In other words (replacing $n$ with $0$): 3. If the method is correct for $S_0$, then it is correct for $S_1$. So from Properties 1 and 3, we can infer: 4. **The method is correct for** $S_1$. $\\qquad$ - Next, consider the case where $n = 1$. From Property 2 still, we know (replacing $n$ with $1$) that: 5. If the method is correct for $S_0 \\cup S_1$, then it is correct for $S_2$. So from Properties 1 and 4 and 5, we can infer: 6. **The method is correct for** $S_2$. $\\qquad$ - etc. "},{"id":15,"href":"/docs/objects/sections/inheritance/","title":"Inheritance","section":"Objects and classes","content":" Inheritance # Subclass # In most (class-based) object-oriented languages, a class _A_ can **extend** another class _B_. In this case, _A_ is called a **subclass** of _B_. The intuitive meaning is inclusion between their respective sets of instances, i.e. every instance of A is also an instance of B (but the converse may not hold).\nThis can be paraphrased in English by \u0026ldquo;every A is a B \u0026ldquo;. For instance:\nevery banana is a fruit every square is a rectangle every rectangle is a geometric shape, etc. Transitivity # The \"extend\" relation is **transitive**, meaning that if _A_ extends _B_ and _B_ extends _C_, then _A_ extends _C_ (for any classes _A_, _B_ and _C_ ). For instance, from the above examples, one can infer that \u0026ldquo;every square is a geometric shape\u0026rdquo;.\nInheritance # Naturally, if _A_ is a subclass of _B_ then it **inherits** the properties of _B_. For instance, a rectangle has four right angles. Since every square is a rectangle, a square has four right angles as well.\nFactorizing code with a (possibly abstract) superclass # Inheritance can be used to avoid redundant code.\nDirect inheritance: illustration # Let us model the units of our game as objects.\nEach unit has:\na type (e.g. mage, unicorn, etc.), a color (at least in the original game), and a certain amount of health. The behavior and stats of a unit (e.g number of turns before attacking when combined, default health, etc.) are dictated by its type. So it makes sense to group units by type.\nFor instance, one can create a class Unicorn whose instances are all units of type unicorn. In Java:\npublic class Unicorn { String color; int health; int attackCountdown; public Unicorn(String color) { this.color = color; health = 1; attackCountdown = -1; } } **_Note._** We used the keyword `attackCountdown` in this example to indicate the number of turns before the unit attacks (and a special value of `-1` when it is not set to attack). But there are of course other ways to model this. **_Note._** In this example, we used the prefix `this.` for the attribute `color` only, because there is no ambiguity for the three other attributes. We can also create a class Butterfly on the same model\npublic class Butterfly { String color; int health; int attackCountdown; public Butterfly(String color) { this.color = color; health = 2; int attackCountdown = -1; } } Now consider a method encounter that manages an encounter between two units. Without inheritance, one would need to implement four versions of this method:\nunicorn vs unicorn, unicorn vs butterfly, butterfly vs unicorn, and butterfly vs butterfly. For instance, the first of these four methods could be implemented as follows:\nvoid encounter(Unicorn u1, Unicorn u2) { // save the initial value of the first unit\u0026#39;s health int copy = u1.health; u1.health -= u2.health; u2.health -= copy; } More generally, if the game has \\(n\\) types of units, then the code will contain \\(n^2\\) nearly identical encounter methods.\n**_Question._** Can we use inheritance in this example to avoid duplicate code (and how)? Observe that a unicorn and a butterfly (viewed as object) have identical attributes (a.k.a. \u0026ldquo;keys\u0026rdquo;), namely String color, int health, and int attackCountdown. So we can create a superclass of UnicornandButterflythat carries these attributes, and let the two subclasses inherit it. For instance, this superclass may be called Unit.\nHowever, we may also want every unit in the game to have a concrete type (like \u0026ldquo;unicorn\u0026rdquo; or \u0026ldquo;butterfly\u0026rdquo;), rather than being a generic \u0026ldquo;unit\u0026rdquo;. In Java, this can be achieved with the abstract keyword. This keyword ensures that our superclass cannot be directly instantiated (even though it can still have a constructor). For instance:\npublic abstract class Unit { String color; int health; int attackCountdown; public Unit(String color, int health) { this.color = color; this.health = health; int attackCountdown = -1; } } Because this class is abstract, the following code will not compile:\nUnit myUnit = new Unit(\u0026#34;green\u0026#34;, 2); Next, we can declare that Unicorn extends Unit, by using the Java keyword extends. We can also use the constructor of Unit within the constructor of Unicorn, with the Java keyword super.\n**_Note._** In Java (as opposed to C++ for instance), a class can only have _one_ immediate superclass, so the keyword `super` is never ambiguous. This yields:\npublic class Unicorn extends Unit { public Unicorn(String color) { super(color, 1); } } And we can proceed similarly for the class Butterfly.\nObserve that all the attributes are now carried by the superclass Unit. However, because they are inherited, these attributes can be accessed as if they were regular attributes of the subclass. For instance,\nUnicorn myUnit = new Unicorn(\u0026#34;green\u0026#34;); System.out.println(myUnit.health); outputs\n1 This allows us to write a generic encounter method, as follows:\nvoid encounter(Unit u1, Unit u2) { // save the initial value of the first unit\u0026#39;s health int copy = u1.health; u1.health -= u2.health; u2.health -= copy; } And this method can be used with unicorns and/or butterflies. For instance:\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); Butterfly myButterfly = new Butterfly(\u0026#34;yellow\u0026#34;); encounter(myUnicorn, myButterfly); } Transitive inheritance # In the example above, we assumed that all units have a color and can attack. What if we also want to create a type of unit called Wall that has no color and cannot attack? An instance of this class does not need the attributes color and attackCountdown.\nA quick solution here consists is setting attackCountdown to -1, and color to null. However, unnecessary attributes make code harder to understand, and such a design may not scale well if the game is extended with more units types.\nExercise Modify our model to accommodate for the class `Wall`, so that an instance of `Wall` only has the `health` attribute. Possible solution One solution (among others) is the following: 1. modify the class `Unit` so that it only carries the attribute `health`, 2. `Wall` extends `Unit`, 3. create an (abstract) subclass of `Unit` (for instance `MobileUnit`) that carries the other two attributes, 4. `Butterfly` and `Unicorn` extend `MobileUnit` (therefore they also extend `Unit`, by transitivity). ![](/img/diagrams/plantuml/abstract_inherit_complex.svg) Or in Java: ```java public abstract class Unit { int health; public Unit(int health) { this.heath = health; } } ``` ```java public class Wall extends Unit { public Wall() { super(5); } } ``` ```java public abstract class MobileUnit extends Unit { String color; int attackCountdown; public MobileUnit(String color, int health) { super(health); this.color = color; this.attackCountdown = -1; } } ``` ```java public class Unicorn extends MobileUnit { public Unicorn(String color) { super(color, 1); } } ``` and similarly for `Butterfy`. "},{"id":16,"href":"/docs/lambda/sections/lambda/","title":"Lambda expression","section":"Callback methods and lambda expressions","content":" Lambda expression # In certain programming languages like Java, C#, C++ or JavaScript, the term lambda expression (sometimes called closure expression) is used to denote an anonymous method with a certain syntax.\nThe term is a (loose) reference to lambda calculus, a model of computation exclusively based on function composition and application.\nSyntax in Java # A Java method\n\u0026lt;ReturnType\u0026gt; myMethod (\u0026lt;Type 1\u0026gt; \u0026lt;argument 1\u0026gt;, .., \u0026lt;Type n\u0026gt; \u0026lt;argument n\u0026gt;){ \u0026lt;Body\u0026gt; } can be written anonymously as the lambda expression:\n(\u0026lt;Type 1\u0026gt; \u0026lt;argument 1\u0026gt;, .., \u0026lt;Type n\u0026gt; \u0026lt;argument n\u0026gt;) -\u0026gt; { \u0026lt;Body\u0026gt; } For instance, the method:\nint division (int x, int y){ return x / y; } is equivalent to the lambda expression\n(int x, int y) -\u0026gt; { return x / y ; } However, a more concise syntax can often be used:\nArguments # If the types of the arguments can be inferred by the compiler (which is most often the case), then they can be omitted.\n**_Example._** ```java (int x, int y) -\u003e { ... } ``` can often be written ```java (x, y) -\u003e { ... } ``` If the method has exactly one argument and its type is omitted, then parentheses can also be omitted.\n**_Example._** ```java (x) -\u003e { ... } ``` can always be written ```java x -\u003e { ... } ``` If the method takes no argument, then parentheses are mandatory.\n**_Example._** ```java () -\u003e { ... } ``` Body # If:\nthe body of a lambda expression consists of a single statement, and the return type of this lambda expression (or void if there is none) can be inferred by the compiler (which is most often the case), then the semicolon (;), curly braces ({ and }) and return keyword (if any) can be omitted.\n**_Example._** ```java (x, y) -\u003e { return x / y ; } ``` can often be written ```java (x, y) -\u003e x / y ``` "},{"id":17,"href":"/docs/objects/","title":"Objects and classes","section":"Docs","content":" Objects and classes # This chapter introduces some basic notions of (class-based) object-oriented programming.\n"},{"id":18,"href":"/docs/regex/sections/java/","title":"Using Java regexes","section":"Regular expressions","content":" Using Java regexes # Escaping \\ # A regex in Java is a string.\nRecall that within a Java string, a \\ character must be escaped (i.e. written \\\\) to be read as a normal character. So in a Java string that represents a regex, every \\ should be written \\\\.\n**_Example._** The string `\"[A-Z]\\\\d+\"` represents the regex `[A-Z]\\d+` **_Hint._** This is another good reason for using a regex validation tool (e.g. [regex101](https://regex101.com/)) to test and debug a regex, before incorporating it into a program. **_Warning._** We saw earlier that when `\\` is treated as a normal character in a regex, it must be escaped (`\\\\`). Therefore in this specific case, the Java string should contain `\\\\\\\\`. **_Example._** The string `\"\\\\d+\\\\\\\\[A-Z]\"` represents the regex `\\d+\\\\[A-Z]` Regexes and String instance methods # Some instance methods of the class String take a regex as input. Among these:\nboolean matches(String regex) returns true iff the whole string belongs to the language described by the regex. Or equivalently if there is a match for the regex ^regex$. String input = \u0026#34;ab\u0026#34;; // Outputs false System.out.println(input.matches(\u0026#34;a\u0026#34;)); // Outputs true System.out.println(input.matches(\u0026#34;ab|a\u0026#34;)); // Outputs true System.out.println(input.matches(\u0026#34;a|ab\u0026#34;)); String replaceFirst(String regex, String replacement) replaces the best first match with the input replacement string: String input = \u0026#34;aba\u0026#34;; // Outputs \u0026#34;ba\u0026#34; System.out.println(input.replaceFirst(\u0026#34;ab|a\u0026#34;, \u0026#34;b\u0026#34;)); // Outputs \u0026#34;bba\u0026#34; System.out.println(input.replaceFirst(\u0026#34;a|ab\u0026#34;, \u0026#34;b\u0026#34;)); String replaceAll(String regex, String replacement) replaces all (successive) best first matches with the input replacement string: String input = \u0026#34;aba\u0026#34;; // Outputs \u0026#34;bb\u0026#34; System.out.println(input.replaceAll(\u0026#34;ab|a\u0026#34;, \u0026#34;b\u0026#34;)); // Outputs \u0026#34;bbb\u0026#34; System.out.println(input.replaceAll(\u0026#34;a|ab\u0026#34;, \u0026#34;b\u0026#34;)); For both `replaceFirst` and `replaceAll`, the replacement string can use a [reference]() to a group, written `$`$n$, where $n$ is the [group number](): ```java String input = \"The windows are open. The apples are green.\"; String output = input.replaceAll(\"(\\\\w+)s\\\\s+are\", \"$1 is\"); // Outputs \"The window is open. The apple is green.\" System.out.println(output); ``` **_Reminder._** Strings in Java are [immutable](http://localhost:1313/docs/objects/sections/quasi-objects/#string). So when the methods `replaceFirst` and `replaceAll` successfully \"modify\" the string, they return a different object. String[] split() splits the input string around the (successive) best first matches: String input = \u0026#34;This is weird.\\n\u0026#34;+ \u0026#34;Or not.\u0026#34; // Contains [ \u0026#34;This\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;weird.\u0026#34;, \u0026#34;Or\u0026#34;, \u0026#34;not.\u0026#34; ] String[] output = input.split(\u0026#34;\\\\s+\u0026#34;); java.util.regex # The native package java.util.regex contains among other the following classes:\nPattern # A Pattern is a regex.\nA Pattern can be created with the static method Pattern Pattern.compile(Sring regex).\nMatcher # A Matcher is a \u0026ldquo;regex engine\u0026rdquo; for a specific regex and a specific string.\nA Matcher can be created out of a Pattern, with the instance method Matcher matcher(String inputString) of the class Pattern.\nPattern pattern = Pattern.compile(\u0026#34;\\\\d+[a-z]*\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;Alice787@unibz\u0026#34;); Among others, the class Matcher provides the following instance methods:\nboolean matches(), String replaceFirst() and String replaceAll() behave analogously to their counterpart for the class String, described above.\nboolean find() tries to match the next best first match. If this method succeeds, then information can be retrieved about the matched segment (see below). The next call to find() will find the following best first match (if any).\nPattern pattern = Pattern.compile(\u0026#34;[A-Z][a-z]*\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;Alice and Bob are exhausted.\u0026#34;); // Outputs true and matches the segment with word \u0026#34;Alice\u0026#34; System.out.println(matcher.find()); // Outputs true and matches the segment with word \u0026#34;Bob\u0026#34; System.out.println(matcher.find()); // Outputs false System.out.println(matcher.find()); String group(int i) returns the substring captured by Group $i$ in the latest match. Group 0 stands for the whole regex.\nString group() is equivalent to group(0).\nint start() returns the start index (included) of the latest matched segment.\nint end() returns the end index (excluded) of the latest matched segment.\nPattern pattern = Pattern.compile(\u0026#34;([A-Z])[a-z]*\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;Alice and Bob are exhausted.\u0026#34;); //Find the best first match matcher.find(); // Outputs \u0026#34;Alice\u0026#34; System.out.println(matcher.group()); // Outputs \u0026#34;A\u0026#34; System.out.println(matcher.group(1)); // Outputs 0 System.out.println(matcher.start()); // Outputs 5 System.out.println(matcher.end()); //Find the next best first match matcher.find(); // Outputs \u0026#34;Bob\u0026#34; System.out.println(matcher.group()); // Outputs \u0026#34;B\u0026#34; System.out.println(matcher.group(1)); public Sream\u0026lt;MatchResult\u0026gt; results() returns all (successive) best first matches. Pattern pattern = Pattern.compile(\u0026#34;[A-Z][a-z]*\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;Alice and Bob are exhausted.\u0026#34;); // Contains two match results: // - one for the segment with word \u0026#34;Alice\u0026#34;, // - one for the segment with word \u0026#34;Bob\u0026#34; List\u0026lt;MatchResult\u0026gt; matches = matcher.results().toList(); MatchResult # A MatchResult is a matched segment.\nThe class MatchResult provides (among others) the instance methods String group(int i), String group(), int start() and int end(), which behave analogously to their counterparts in the class Matcher.\nPattern pattern = Pattern.compile(\u0026#34;[A-Z][a-z]*\u0026#34;); Matcher matcher = pattern.matcher(\u0026#34;Alice and Bob are exhausted.\u0026#34;); // Get all best first matches List\u0026lt;MatchResult\u0026gt; matches = matcher.results().toList(); // Outputs \u0026#34;Alice\u0026#34; System.out.println(matches.get(0).group()); // Outputs \u0026#34;Bob\u0026#34; System.out.println(matches.get(1).group()); "},{"id":19,"href":"/docs/build/sections/artifact/","title":"Artifact","section":"Build automation","content":" Artifact # A Maven **artifact** is the output of a build process. It can for instance be a [jar](). Coordinates # A Maven artifact is identified by so-called **coordinates**: - **groupId:** identifier of the organization that created the project (this is usually the organization's reversed domain name), - **artifactId:** identifier of the project within the group, - **version:** version of the artifact. **_Examples._** ```xml com.google.guava guava 33.1.0-jre ``` ```xml com.github.haifengl smile-core 3.1.0 ``` These coordinates are notably used to declare dependencies.\nVersions # SemVer # Maven artifact versions often follow (or loosely follow) the so-called semantic versioning scheme.\nMajorVersion.MinorVersion or\nMajorVersion.MinorVersion.Patch **_Example._** According to the SemVer scheme, Version `3.4.1` means: - major version: `3` - minor version: `4` - patch: `1` By convention: - a new **major version** often signals the absence of backward compatibility, - a new **minor version** often signals (backward compatible) new features, - a **patch** often signals bug (or security-related) fixes. **_Note._** Java has only one major version. For instance \"Java 17\" actually refers to Java `1.17`. SNAPSHOT # The `SNAPSHOT` qualifier (e.g. in Version `3.4.1-SNAPSHOT`) indicates an _upcoming_ release, still _under development_. The SNAPSHOT qualifier is typically used to describe the (current state of) the source code of (a git branch of) a project (e.g. available as a public git repository). For instance, if the latest release of the project was 3.5.2, and if the developers are working on bug fixes, then the latest source code may have Version 3.5.3-SNAPSHOT.\n**_Warning._** A program whose version number has the `SNAPSHOT` qualifier may be modified by it authors, _while keeping the same version number_. In other words, `Version 3.4.1-SNAPSHOT` downloaded today may differ from `Version 3.4.1-SNAPSHOT` downloaded tomorrow. So when releasing a project, it is recommended to avoid dependencies on `SNAPSHOT` versions. "},{"id":20,"href":"/docs/objects/sections/methods/","title":"Instance methods","section":"Objects and classes","content":" Instance methods # In most object-oriented languages (like Java), methods are implemented within class declarations.\nAn instance method can only be called using an instance of the class where it is declared.\nFor instance, in Java, an instance method declared in MyClass can be called by appending . to a variable of type MyClass. The object referenced by the variable is accessible in the method, as well as its attributes.\nThis intuitively allows us to write methods with one less argument. For instance, consider the following method, which is not and instance method. It verifies whether two instance of MobileUnit have the same color:\npublic boolean sameColor(MobileUnit u1, MobileUnit u2){ return u1.color.equals(u2.color); } This method may be called as follows:\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); Butterfly myButterfly = new Butterfly(\u0026#34;green\u0026#34;); boolean sameColor = sameColor(myUnicorn, myButterfly); Instead, one may write an equivalent method, as an instance method of our class MobileUnit, with one less argument:\npublic abstract class MobileUnit extends Unit { String color; ... public boolean sameColorAs(MobileUnit otherUnit){ return color.equals(otherUnit.color); } } and we can call this method as follows:\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); Butterfly myButterfly = new Butterfly(\u0026#34;green\u0026#34;); boolean sameColor = myUnicorn.sameColorAs(myButterfly); } Overriding # A same instance method can be declared in a class C and a subclass S or C. In this case, we say that S overrides the method.\nWhen such a method is called, the most specific applicable version is executed.\nFor instance, let us extend our example from the previous section with a method regen, declared in both Unit and MobileUnit, as follows:\npublic abstract class Unit { int health; ... public void regen(){ if(health \u0026lt; 10){ health += 1; } } } public abstract class MobileUnit extends Unit { ... public void regen(){ if(health \u0026lt; 10){ health += 1; } health += 1; } } Now consider this program.\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); myUnicorn.regen(); This program increases the health of (the object referenced by) myUnicorn by 2, because Unicorn is a subclass of MobileUnit. However, the following program increases the health of (the object referenced by) myWall by 1, because Wall is a subclass of Unit, but not a subclass of MobileUnit.\nWall myWall = new Wall(); myWall.regen(); **_Hint._** In Java, you can use the annotation `@Override` to indicate that a method overrides another, as follows: ```Java public abstract class MobileUnit extends Unit { ... @Override public void regen(){ if(health \u003c 10){ health += 1; } health += 1; } } ``` This is not necessary. The benefit is that the program will not compile if the overridden and overriding methods have different signatures. More generally, _syntactic_ mistakes (a.k.a. compile time errors) are easier to fix than _bugs_ (a.k.a. runtime errors). So when possible, it is good practice to use features of a language that prevent compilation if incorrect programs. This is why debugging in an untyped language (like Python, Javascript, Lua, etc.) can be more difficult than in a _typed_ one (such as Java, C#, Typescript, etc.). Dynamic dispatch (a.k.a. runtime polymorphism) # **Dynamic dispatch** consists in determining which version of a method must be called when a program is executed (a.k.a. \"at run time\"), when this cannot be determined by analyzing the program alone. This is a feature of most (class-based) object-oriented languages. For instance, in our example, assume a method generateRandomUnits that generates a random array of units (butterflies, unicorns or walls). And let us call the method regen for each unit in this array:\nUnit[] ramdomUnits = generateRandomUnits(); for (Unit unit: randomUnits){ unit.regen(); } The most specific applicable version of the method regen will be executed for each unit, based on its type, even though this type cannot be determined at compile time. For instance, if there is an instance of Unicorn in this array, then the method MobileUnit.regen() will be executed for this instance (rather than the method Unit.regen()).\nCode factorization # An overriding method often extends the functionality of the overridden one. This is a possible source of duplicate code. For instance, in the example above, both implementations of regen() contain:\nif(health \u0026lt; 10){ health += 1; } A common way to factorize this consists in calling the overridden method inside the overriding one. In Java, the keyword super allows us to distinguish the two methods (since they have the same name). For instance, in the above example, the overriding method may be better written as follows:\npublic abstract class MobileUnit extends Unit { ... public void regen() { super.regen(); health += 1; } } Exercise In this example, what would be the effect of replacing `super.regen()` with `regen()`? Solution The method would not terminate. Exercise Consider the method `encounter` of the previous section. Add it as an instance method to our example, so that: - the method now distinguishes the attacker from the defender, - a wall cannot attack, - a unicorn gets a regen if it defends. Possible solution The trick here consists in viewing an encounter from the point of view of the defender: ![](/img/diagrams/plantuml/method_inherit_complex.svg) ```Java public abstract class Unit { int health; ... public void defend(MobileUnit attacker) { // save the initial value of the first unit's health int copy = health; health -= attacker.health; attacker.health -= copy; } } ``` ```Java public class Unicorn extends Unit { ... public void defend(MobileUnit attacker) { regen(); super.defend(attacker); } } ``` "},{"id":21,"href":"/docs/objects/sections/tostring/","title":"Displaying objects","section":"Objects and classes","content":" Displaying objects # The class Object # Java has a native class called `Object` with [11 instance methods](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html). Every Java class implicitly extends `Object`, _including user-defined classes_. Therefore any Java class _inherits_ these methods. The method toString # toString is one of the methods of the class Object. Here is (part of) its specification:\n/** Returns a string representation of the object. * In general, the toString method returns a string that * \u0026#34;textually represents\u0026#34; this object. */ public String toString(); This is the preferred way to display information about an object. For instance, the debugger of your IDE probably relies on this method to display a string that represents an object.\nThis method is also called by many (native or not) methods and operators. For instance, the following program\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); System.out.println(myUnicorn); String message = \u0026#34;Hello \u0026#34; + myUnicorn; is equivalent to\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); System.out.println(myUnicorn.toString()); String message = \u0026#34;Hello \u0026#34; + myUnicorn.toString(); Overriding toString # The default implementation of toString (in the class Object) displays very little information about the object:\npublic String toString() { return getClass().getName() + \u0026#34;@\u0026#34; + Integer.toHexString(hashCode()); } **_Warning._** The output of `hashCode()` in this example is _not_ the reference (a.k.a. \"memory address\") of the object. So a common practice consists in overriding toString. For instance, here is a possible implementation of the method toString within a class Unicorn:\npublic class Unicorn { String color; int health; @Override public String toString() { return \u0026#34;Unicorn{\u0026#34; + \u0026#34;color=\u0026#34; + color + \u0026#34;, \u0026#34; + \u0026#34;health=\u0026#34; + health + \u0026#34;}\u0026#34;; } } **_Hint._** Your IDE can generate such a method. Recursion # A naive implementation of toString (e.g. generated by an IDE) may have unexpected effects.\nExercise Consider an implementation of our game where units (on each side of the board) are grouped by column. This implementation may use a class `Column` to represent a column and the adjacent one(s), as follows: ```java public class Column { Unit[] units; // null if this is the left-most column Column leftAdjacentColumn; // null if this is the right-most column Column rightAdjacentColumn; public Column(Unit[] units){ this.units = units; } @Override public String toString() { return \"Column{\" + \"left=\" + leftAdjacentColumn +\", \" + \"right=\" + rightAdjacentColumn +\", \" + \"units=\" + units + \"}\"; } } ``` Then a board may be created as follows: ```java Unit[] a1 = new Unit[]{ new Unicorn(\"green\") }; Column c1 = new Column(a1); Unit[] a2 = new Unit[]{ new Butterfly(\"yellow\") }; Column c2 = new Column(a2); c1.rightAdjacentColumn = c2; c2.leftAdjacentColumn = c1; System.out.println(c1); ``` There is an issue with this program. Can you identify it? Solution The program does not terminate, because `toString` is (implicitly) recursive, and each of the two columns refers to the other. "},{"id":22,"href":"/docs/unittests/sections/junit/","title":"in Java","section":"Unit tests","content":" Unit tests in Java # Several frameworks are available in Java for unit tests. Popular frameworks include:\nJUnit 4 JUnit 5 TestNG Spock In this section, we focus on Junit 5.\nInstall Junit 5 with Maven # Junit 5 can be used in a Maven project by declaring the following dependency and plugin\n\u0026lt;dependencies\u0026gt; ... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.10.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; ... \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; ... \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-surefire-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.5\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; ... \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; For the latest versions, search Maven Central.\nLayout # Maven # Recall that in a Maven project, by default:\nsource code for unit tests is located in the directory src/test/java, resources for unit tests (e.g. data) are located in the directory src/test/resources. **_Note._** You can create sub-directories (in these directories) to organize your tests and resources. Gradle # Junit 5 can be used with Gradle in a similar way, but the directories for unit tests and related resources and (usually) specified manually.\n**_Hint._** If you chose the [board game](http://localhost:1313/docs/project/sections/board_game/) as your project, then you can write JUnit 5 tests under `core/src/test/java`. You will also find (dummy) unit tests in the directory `core/src/test/java/dummy`. Writing unit tests # With Maven, any (public or protected) Java class in src/test/java (or a subdirectory) can contain JUnit tests.\nA **Junit 5 test** is a (public or protected) _instance method_ : - with `void` return type, - annotated with `org.junit.jupiter.api.Test`. In addition, the method usually contains one or several calls to static methods of JUnit\u0026rsquo;s Assertions class, like assertEquals or assertThrows. The test succeeds iff all these calls return true.\nFor instance, the following class contains a single (successful) test:\nimport org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class MyTests { @Test void myTest(){ String myString = \u0026#34;foo\u0026#34;; assertEquals(true, myString.contains(\u0026#34;oo\u0026#34;)); } } **_Warning._** The method `assertEquals` takes the expected value as first argument, and the actual one as second argument. This has an incidence on logs in case of test failure (\"expected\" : XXX, \"actual: \"YYY\"); **_Hint._** A string can be passed to `assertEquals` as third argument, in order to display an additional message in case of failure. **_Hint._** Most methods of the class [Assertions](https://junit.org/junit5/docs/5.0.1/api/org/junit/jupiter/api/Assertions.html) are syntactic sugar (thus not strictly necessary). For instance ```java assertTrue() ``` is a shortcut for ```java assertEquals(true, ) ``` **_Warning._** By default, the execution of a test method is interrupted as soon as an assertion fails. So following instructions (for instance other assertions) will _not_ be executed. Checking exceptions # The assertion assertThrows allows checking whether the execution of a piece of code method throws an exception of a given type. For instance the following unit test succeeds:\n@Test void testException(){ assertThrows( ArithmeticException.class, () -\u0026gt; { int x = 2 / 0; } ); } Prior and/or subsequent code # The annotation @BeforeAll (resp. @AfterAll) can be used to indicate that a (static) method must be executed (only once) before (resp. after) all unit tests in the class, regardless of test successes or failures. This can be used for costly operations, or for opening (resp. closing) a resource, like an connection or an input (resp. output) stream. For instance\nimport org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.Test; import java.sql.Connection; public class SQLTests { Connection myConnection; @BeforeAll static void openConnection(){ ... } @Test void test1(){ ... } @Test void test2(){ ... } @AfterAll static void closeConnection(){ ... } } Similarly the annotation @BeforeEach (resp. @AfterEach) can be used to indicate that a method must be executed before (resp. after) each unit test in the class. This can be convenient to avoid copy-pasting code. For instance\nimport org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; public class BoardgameTests { Snapshot testSnapshot; @BeforeEach void createTestSnapshot(){ testSnapshot = new DummySnapshot(); } @Test void test1(){ ... } @Test void test2(){ ... } } Disabling tests # A unit test can be disabled with the annotation @Disabled. As a result, it will be ignored by Maven, Gradle, and (to some extent) your IDE. For instance:\nimport org.junit.jupiter.api.Disabled; import org.junit.jupiter.api.Test; public class MyTests { @Test @Disabled void test1(){ ... } @Test void test2(){ ... } } Running unit tests # from the command line # For a Maven project, the command\nmvn test executes all phases that precede the test phase (e.g. compile and test-compile) in Maven\u0026rsquo;s default lifecycle, and then executes all unit tests under src/test/java.\n**_Note._** The source code of unit tests (and related resources) is by default _excluded_ form the output of the `package` phase (e.g. from the jar produced by Maven). **_Note._** A unit test failure will prevent execution of Maven phases that are posterior to `test`. For instance ```bash mvn package ``` does _not_ produce the expected jar if a test fails. However, if needed, it is possible to execute a posterior Maven phase while skipping the unit tests, with the option `-DskipTests`. For instance: ```bash mvn package -DskipTests ``` within an IDE # IDEs provide several ways to run unit tests, either:\nin isolation, or all tests within a class, or all tests within a package (including subpackages). For instance, with IntelliJ:\nclick on the green arrow to run a single unit test, click on the double green arrow to run all unit tests defined in the current class, right click on a folder and select \u0026ldquo;Run Tests\u0026rdquo; to run all tests in this package. **_Note._** Within an IDE, a unit test can (and most often should) be run in _debug_ mode. For instance, with IntelliJ, right-click on the green arrow and select 'Debug'. "},{"id":23,"href":"/docs/generics/sections/erasure/","title":"Type erasure","section":"Generic programming","content":" Type erasure in Java # Java compilers rely on an approach called **_type erasure_** to compile: - type parameters (e.g. `Box`), - type variables (e.g. `Box`), and - question marks (e.g. `Box\u003c? extends Number\u003e`). More often than not, when a Java program does not compile, we can understand why without understanding the compilation procedure. However, for generics, some basic understanding of type erasure can help.\nProcedure # Intuitively, type erasure consists in producing a program equivalent to the initial one, but free of generic or parameterized types (i.e. intuitively with no \u0026ldquo;diamond\u0026rdquo;).\nInformally, a Java compiler first performs all type checks specified in the program. If all type checks succeed, then:\neach type variable or question mark is replaced with its (upper or lower) bound (if any), or Object if there is none, explicit casts are introduced where they become necessary (as well as so-called bridge methods if needed, to ensure that overriden methods remain overriden), all type parameters, type variables and question marks are deleted. Illustrations # **_Warning._** Type erasure is traditionally illustrated with a Java program before and after erasure (for instance, in Oracle's [Java tutorials](https://docs.oracle.com/javase/tutorial/java/generics/erasure.html)). However, these illustrations should _not_ be taken literally, because compilation produces _byte code_, not source code. **_Example._** Consider the generic class `Box` that we used [earlier]() illustrate covariance and contravariance, together with the methods `unbox` and `replaceValue`: ```java public class Box { T boxedValue; public Box(T boxedValue){ this.boxedValue = boxedValue; } T getValue(){ return boxedValue; } void setValue(T newValue){ boxedValue = value; } } ``` $\\qquad$ ```java Number unbox(Box\u003c? extends Number\u003e box){ return box.getValue(); } void replaceValue(Box\u003c? super Integer\u003e box, Integer integer){ box.setValue(integer); } ``` The bytecode generated after type erasure may be equivalent to bytecode generated for the following program: ```java public class Box { Object boxedValue; public Box(Object boxedValue){ this.boxedValue = boxedValue; } Object getValue(){ return boxedValue; } void setValue(Object newValue){ boxedValue = value; } } ``` $\\qquad$ ```java Number unbox(Box box){ return (Number) box.getValue(); } void replaceValue(Box box, Integer integer){ box.setValue(integer); } ``` **_Example._** Generic methods are compiled in a similar way. For instance, consider once again our generic method ```java T healthiest(T[] units) { ... } ``` The bytecode generated after type erasure may be equivalent to bytecode generated for a method: ```java Unit healthiest(Unit[] units) { ... } ``` Consequences # Runtime # A first important consequence of type erasure (e.g. for debugging) is that parameterized types do not exist at runtime (as opposed C++ or C#).\nFor instance, a JVM cannot distinguish an instance of Box\u0026lt;Integer\u0026gt; from an instance of Box\u0026lt;String\u0026gt;. Both are instances of the same class Box.\nCompile-time # Type erasure may also explain in some cases why a Java program are invalid.\nWe list here two simple cases (among others).\nAmbiguity # Java (like C++ or C#) allows defining two methods with the same name in the same class, as long as they have different argument types (this is called method overloading). However, after type erasure, this may result in two methods with the same name and arguments (which is forbidden).\n**_Example._** The following program does _not_ compile: ```java public class MyClass { void myMethod(String s, T t) { ... } void myMethod(String w, V v) { ... } } ``` Constructor # A type parameter cannot be instantiated.\n**_Example._** The following program does _not_ compile: ```java public class Box { T create(){ return new T(); } } ``` "},{"id":24,"href":"/docs/lambda/sections/type/","title":"Type of a method","section":"Callback methods and lambda expressions","content":" Type of a method # **_Terminology._** The **type** (a.k.a. **signature**) of a method consists of: - the type(s) of its argument(s), and - its return type. **_Notation._** The type of a method is sometimes described analogously to the type of a mathematical [function](). For instance, consider the following Java method `square`: ```java int square(int x){ return x * x; } ``` This method takes as input an `int`, and returns an `int`. In other words, this is a function with domain `int` and codomain `int`. This is written: $\\qquad$`square`$\\colon$ `int` $\\to$ `int` And the type of this function is $\\qquad$ `int` $\\to$ `int` Similarly, we may use: - `int` $\\times$ `int` $\\to$ `int` if the method takes two `int` and returns another, - `Unit` $\\times$ `int` $\\to$ `Unit` if the method takes a `Unit` and an `int` (in that order) and returns a `Unit`, - `Unit[]` $\\to$ `void` if the method takes an array of `Units[]` and returns nothing, - etc. in Java # Syntactically, Java does not provide a method typing system like the one above. Instead, Java uses (abuses?) interfaces for this purpose.\nFunctional interface # A method type in Java is described with a so-called functional interface.\n**_Syntax._** A Java **functional interface** is an [interface](http://localhost:1313/docs/interfaces/sections/java_interfaces/) with a single (standard) method. **_Note._** In this definition, \"standard\" method stands for a method that does not have the [default](http://localhost:1313/docs/interfaces/sections/java_interfaces/#interfaceVsAbstractClass) qualifier (\"standard\" interface methods are also called \"abstract\"). **_Example._** The following is a functional interface, which describes the type `Unit` $\\times$ `Integer` $\\to$ `Unit`. Any method with type `Unit` $\\times$ `Integer` $\\to$ `Unit` implements this interface. ```java interface UnitPerIntegerToUnit { Unit myMethod(Unit unit, Integer x); } ``` The name of a functional interface is irrelevant, as well as the name of its method (and the arguments of this method).\n**_Example._** The following functional interface also describes the type `Unit` $\\times$ `Integer` $\\to$ `Unit`. ```java interface Just { Unit because(Unit we, Integer can); } ``` A functional interface can be annotated with @FunctionalInterface. This will for instance cause a compilation error if the interface has more than one (non-default) method.\n**_Example._** ```java @FunctionalInterface interface UnitPerIntegerToUnit { Unit myMethod(Unit unit, Integer x); } ``` Native functional interfaces # Java provides native (parameterized) functional interfaces for some frequent method types.\nWe highlight here a few of them:\nFunction # The functional interface `Function` stands for the type `InputType` $\\to$ `OutputType`. Its method is called `apply`. **_Examples._** - a method with type `Unit` $\\to$ `Integer` implements the functional interface `Function` - a method with type `Unit` $\\to$ `Unit` implements the functional interface `Function` Consumer # The functional interface `Consumer` stands for the type `InputType` $\\to$ `void`. Its method is called `accept`. **_Examples._** - a method with type `Integer` $\\to$ `void` implements the functional interface `Consumer` - a method with type `Unit` $\\to$ `void` implements the functional interface `Consumer` Supplier # The functional interface `Supplier` stands for the type `void` $\\to$ `OutputType`. Its method is called `get`. **_Examples._** - a method with type `void` $\\to$ `Integer` implements the functional interface `Supplier` - a method with type `void` $\\to$ `Unit` implements the functional interface `Supplier` Comparator # The interface Comparator\u0026lt;T\u0026gt; (already seen in the section dedicated to sorting) is functional. Its method is called compare, and has type T $\\times$ T $\\to$ int.\n"},{"id":25,"href":"/docs/intro/sections/bibliography/","title":"Bibliography","section":"This course","content":" Bibliography # Java\u0026rsquo;s syntax # This website contains Java code snippets that illustrate how to perform certain operations. However, this documentation is far from exhaustive (on purpose).\nWhen it comes to syntax, the first two sources of complementary material for this course are:\nthe Javadoc of the libraries (standard and auxiliary) used in projects and assignments. An IDE is often the fastest way to navigate through it, the web. Books # A reading list for this course is available in the catalogue of the Unibz\u0026rsquo;s library. All books can be accessed via the library (either physically or digitally).\nAmong these books, we highlight the following two:\nMain textbook # Java: How to Program, Early Objects (11th edition)\nby Paul Deitel and Harvey Deitel\nPearson, 2018\nThis is a general introductory book to Java and object oriented programming. It covers most of the topics seen in this course.\nGood practices # Effective Java (3rd edition)\nby Joshua Bloch\nAddison-Wesley Professional, 2017\nThis is a reference book for best practices and common pitfalls when programming in Java.\n"},{"id":26,"href":"/docs/lambda/sections/callback/","title":"Callback method","section":"Callback methods and lambda expressions","content":" Callback method # When a method takes another method as argument, the latter is a **callback method**. Anonymous methods are often used as callback methods.\nin Java # Running example # **_Example._** The two following Java methods have the same structure: both modify each unit in the input list. ```java void boostUnits(List units){ for(Unit unit: units){ unit.health++; } } void penalizeGreenUnits(List units){ for(Unit unit: units){ if(unit.color.equals(\"green\")){ unit.health--; } } } ``` In each case, let us isolate the modification that is applied to a single unit, with a dedicated method (called `boost` and `penalizeGreen` respectively). ```java void boost(Unit unit){ unit.health++; } void penalizeGreen(Unit unit){ if(unit.color.equals(\"green\")){ unit.health--; } } ``` Both methods have type `Unit` $\\to$ `void`, so they are instances of the [functional interface](http://localhost:1313/docs/lambda/sections/type/#functionalInterface) `Consumer`. This allows us to factorize our code with a method `transform` that takes as input: - an array of units, - a callback method with type `Consumer`, and applies the callback method to each unit in the input array. ```java void transform(List units, Consumer method){ for (Unit unit: units){ method.accept(unit); } } ``` Passing a callback method # A callback method in Java can be:\na method reference, or a lambda expression. Method reference as a callback method # **_Syntax._** A Java **method reference** is written: - `ClassName::methodName` for a static method, - `objectVariable::methodName` for an instance method, - `ClassName::new` for a constructor. **_Example (continued)._** Let us assume that our methods `boost` and `penalizeGreen` above are static methods of some class called `UnitTransformer`: ```java public class UnitTransformer{ static void boost(Unit unit){ unit.health++; } static void penalizeGreen(Unit unit){ if(unit.color.equals(\"green\")){ unit.health--; } } } ``` We can call our method `transform` with `boost` as callback method: ```java List units = getUnits(); transform( units, UnitTransformer::boost ); ``` And similarly with `penalizeGreen`: ```java List units = getUnits(); transform( units, UnitTransformer::penalizeGreen ); ``` Lambda expression as a callback method # Alternatively, instead of declaring a method boost, we can directly use a lambda expression:\n**_Example (continued)._** ```java List units = getUnits(); transform( units, unit -\u003e unit.health++ ); ``` And similarly, instead of declaring a method `penalizeGreen`, we can use the following lambda expression: ```java List units = getUnits(); transform( units, unit -\u003e { if(unit.color.equals(\"green\")){ unit.health-- ; } ); ``` Native support # Programming languages that support anonymous methods (like Java, Python, C#, C++, JavaScript, etc.) often provide concise syntaxes to use them as callback methods.\n**_Example(continued)._** In Java, the above method `transform` is not necessary. Instead, we can use the native method [forEach](), available (among others) for any Java [Collection](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Collection.html). This method takes a `Consumer` method as input, and applies this method to each element of the collection. So the following program: ```java getUnits().forEach(unit -\u003e unit.health++); ``` is equivalent to: ```java transform( getUnits(), unit -\u003e unit.health++ ); void transform(List units, Consumer method){ for (Unit unit: units){ method.accept(unit); } } ``` "},{"id":27,"href":"/docs/objects/sections/comparing/","title":"Cast and equality","section":"Objects and classes","content":" Cast and Equality # Cast # Java (as well as C# and C++) provides mechanisms to change the type associated with an object _o_, using either a _supertype_ of _o_ (this is an **upcast**), or a _subtype_ of _o_ (this is a **downcast**). Upcast # Explicit upcasts are uncommon, but may still be useful in some scenarios, e.g. to disambiguate two method calls.\nImplicit upcasts on the other hand are very frequent, when the type of an object cannot be determined at compile time.\n**_Example._** Consider the following classes: ![](/img/diagrams/plantuml/downcast_simple.svg) Now consider the following program, where the method `getUnits` produces an array of units that depends on the player's input. The type of objects in this array (`Unicorn` or `Butterfly`) cannot be determined at compile time. Thanks to the implicit upcast, they can nonetheless be treated as (underspecified) units. ```java Unit[] units = getUnits(); for (Unit unit: units){ System.out.println(unit.health); } ``` Downcast # Downcasting in Java is frequent for objects whose type cannot be determined at compile time. However, this may not be safe. For instance, in the above example, downcasting a unit from Unit to Unicorn may cause a ClassCastException (at runtime), because this unit is a instance of Butterfly. This is why downcasting is often used in combination with the instanceof operator. For instance the above example can be modifed as follows:\nUnit[] units = getUnits(); for (Unit unit: units){ if(unit instanceof Unicorn){ ((Unicorn) unit).regen(); } } Here the operation (Unicorn) unit is a downcast. The output of this operation has type Unicorn, thus allowing the call to the method regen.\nObject equality # As we saw in a previous chapter, a constructor in Java creates an object in memory and returns a (fresh) reference to that object. Since two objects have different locations in memory, their respective references must differ, even if the objects are identical.\n**_Example._** Consider (a simplified version of) the class `City` that we saw [earlier](http://localhost:1313/docs/objects/sections/classes/). ```java public class City { String name; int zipCode; public City(String name, int zipCode){ this.name = name; this.zipCode = zipcode; } } ``` The following program will output `false`: ```java City city1 = new City(\"Florence\", 50100); City city2 = new City(\"Florence\", 50100); System.out.println(city1 == city2); ``` However, in some scenarios, it may be useful to compare the objects themselves, rather than their references. Java provides a native method called equals for this purpose.\nLike the method toString that we saw earlier, the equals is an instance method of the native Java class Object, which is an (implicit) superclass of every other class. So every (user-defined of native) class inherits equals.\nHere is the source code of Object.equals:\npublic boolean equals(Object obj) { return (this == obj); } In other words, by default, this method behaves like the == operator. In order to use this method to check whether two objects are equal, it has to be overriden.\nFor instance, here is a prototypical implementation of the method equals within our class City:\n@Override public boolean equals(Object o) { if (this == o) { // same reference return true; } if (o == null || getClass() != o.getClass()) return false; // o is null or has a different type } City downcastObject = (City) o; return zipCode == downcastObject.zipCode \u0026amp;\u0026amp; name.equals(downcastObject.name); } **_Hint._** Your IDE can generate such a method. Note in this example:\nthe (safe) downcast from Object to City, and the recursive call to equals (because String is not a primitive type). Recursion # **_Warning._** Similarly to what we saw with the method [toString](http://localhost:1313/docs/objects/sections/tostring/#recursion), beware of naive (recursive) implementations of `equals` if your program can create an object that refers to itself (directly or indirectly). Built-in implementations # Several native Java classes have their own implementation of equals. We will encounter several of them during this course, notably for the class String and for the implementations of the interface Set.\nThe method hashCode # The method equals is usually overridden together with another method of the class Object, called hashCode. In particular, this is needed for the method equals of the class HashSet to behave correctly. We will explore this topic later in this course, when we introduce the notion of a hash table.\n"},{"id":28,"href":"/docs/background/sections/cost/","title":"Computational cost","section":"Background","content":" Computational cost # In this section, we briefly introduce the standard way to estimate the cost of an algorithm, as a function $f(n)$ of the size $n$ of its input.\nSize # The **size** $n$ of the input may be the size of its representation in bits. Other common measures include: - the number of entries for array, - the number of nodes for tree, - etc. Time or memory # Among others, the function $f(n)$ may estimate: - the **running time** of the algorithm, or - its **memory consumption**. Worst case, average # Among others, the function $f(n)$ may estimate: - cost in the **worst case**, i.e. for the worst possible inputs of size $n$ - **average** cost over all possible inputs of size $n$. Exercise Consider the following algorithm, which returns true iff the input array `A` contains the input value `a`. ```perl boolean contains(int[] A, int a){ foreach(v in A) { if(v == a){ return true } } return false } ``` If the input array has length $n$, how many times would the loop be executed in the worst case? Solution $n$ times (if `a` doe not appear in `A`). Exercise Consider the following algorithm (known as binary search), which solves the same problem as the previous one, but assuming that the input array is _sorted_. ```java boolean contains(int[] A, int a){ int begin = 0 int end = A.lenghth - 1 while(begin \u003c end){ mid = (begin + end) / 2 if(a \u003c= A[mid]){ end = mid } else { begin = mid + 1 } } return A[begin] == a } ``` For an input array of length $n$, how many times is the loop executed? Solution $\\log_2 n + 1$ times, rounded down. Asymptotic cost # When comparing the costs of algorithms, we are usually interested in scalability, i.e. how they behave when the input gets large.\nLet $f(n)$ measure the (worst case or average) running time of an algorithm.\nIf $n$ doubles, does $f(n)$ double as well? In other words, does $f(2 n) = 2 f(n)$?\nIf this is the case, then $f$ is a linear function.\n**_Examples._** The following are linear functions: - $f(n) = n$ - $g(n) = 5n$ - $h(n) = \\frac{1}{2} n$ Alternatively, if $f(2 n) \u0026gt; 2 f(n)$, then the cost grows more than linearly with the size of the input.\n**_Examples._** - if $f(n) = n^2$, then $f(2n) = 4 f(n)$, - if $f(n) = c n^2$ for some $c$, then $f(2n) = 4 f(n)$ as well, - if $f(n) = n^3$, then $f(2n) = 8 f(n)$, - if $f(n) = 2^n$, then $f(n+1) = 2 f(n)$ Alternatively, $f(n)$ may grow less than linearly with $n$.\n**_Examples._** - if $f(n) = \\sqrt{n}$, then $f(4n) = 2f(n)$ - if $f(n) = \\sqrt[3]{n}$, then $f(8n) = 2f(n)$ - if $f(n) = \\log_2 n$, then $f(n+1) = 2 f(n)$ Comparing cost functions # Two cost functions $f$ and $g$ are said to be asymptotically equivalent if they intuitively have the same growth.\n**_Examples._** - all linear functions are asymptotically equivalent, - (as illustrated above), the functions $f(n) = n^2$ and $g(n) = 3n^2$ are asymptotically equivalent. **_Terminology._** A function $f: X \\to Y$ is **monotone** if $x_1 \\le x_2$ implies $f(x_1) \\le f(x_2)$ for any $x_1, x_2 \\in X$. **_Definition._** Let $f$ and $g$ be two monotone functions over $\\mathbb{N}$ such that $\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)}$ is defined. And let $l$ be this limit. - if $l = 0$ then $g$ **outgrows** $f$, - if $l = \\infty$ then $f$ **outgrows** $g$, - otherwise (i.e. if $l \\in \\mathbb{R}$ and $l \\neq 0$), $f$ and $g$ are **asymptotically equivalent**. In practice # **_Hint._** $f$ outgrows $g$ iff the derivative of $f$ outgrows the derivative of $g$. **_Example._** Let $f(n) = 5n^2$ and let $g(n) = n^3$. Then $\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = \\lim_{n \\to \\infty} \\frac{5n^2}{n^3} = \\lim_{n \\to \\infty} \\frac{10n}{3n^2} = \\lim_{n \\to \\infty} \\frac{10}{6n} = 0$ So $g$ outgrows $f$. **_Example._** Let $f(n) = 5n^2$ and let $g(n) = n^2$. Then $\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = \\lim_{n \\to \\infty} \\frac{5n^2}{n^2} = \\lim_{n \\to \\infty} \\frac{10n}{2n} = 5$ So $f$ and $g$ are asymptotically equivalent. **_Hint._** If there exists a function $h$ over $\\mathbb{N}$ such that - $\\lim_{n \\to \\infty} h(n) = \\infty$ and - $f(n) = g(n)h(n)$, then $f$ outgrows $g$. **_Example._** Let $f(n) = n \\cdot \\log_2 n$ and let $g(n) = n$. Take $h(n) = \\log_2 n $. Then - $\\lim_{n \\to \\infty} h(n) = \\lim_{n \\to \\infty} \\log_2(n) = \\infty$, and - $f(n) = n \\cdot \\log_2 n = g(n) h(n)$, Therefore $f$ outgrows $g$. Equivalence classes # **_Notation._** If $f$ is a cost function, then $\\Theta(f)$ is used to denote the set of all cost functions that are asymptotically equivalent to $f$ (including $f$ itself). **_Example._** If $f(n) = n$, then the class $\\Theta(f)$ contains the functions: - $g(n) = 2n$, - $h(n) = \\frac{n}{2}$, - $j(n) = 3n + 4$, - etc. **_Note._** If $g$ is in $\\Theta(f)$, then $\\Theta(f)$ and $\\Theta(g)$ are the same class. **_Notation._** If $\\Theta(f)$ is a class of cost functions, then the name of the function (\"$f$\" here) can be omitted. Instead, the definition of $f$ is used (typically with $n$ as variable). **_Examples._** - if $f(n) = n$, then the class $\\Theta(f)$ is usually denoted with $\\Theta(n)$, - if $f(n) = n^2$, then the class $\\Theta(f)$ is usually denoted with $\\Theta(n^2)$, - etc. A simple, representative function is usually preferred to denote in each class.\n**_Example._** $\\Theta(n)$, $\\Theta(\\frac{n}{2})$ and $\\Theta(3n+4)$ are three alternative notations for the same class of cost functions. For readability, $\\Theta(n)$ is usually preferred. Some of the most frequent classes of cost functions for algorithms are (from lower to higher cost):\n$\\Theta(1)$ (a.k.a. constant cost) $\\Theta(\\log n)$ (a.k.a. logarithmic cost) $\\Theta(n)$ (a.k.a. linear cost) $\\Theta(n \\log n)$ $\\Theta(n^2)$ (a.k.a. quadratic cost) $\\Theta(n^3)$ (a.k.a. cubic cost) $\\Theta(2^n)$ Useful simplifications # The definition of asymptotic equivalence implies that the cost function of an algorithm can often be simplified into an equivalent one, using simple rules. We list here a few of them.\n**_Simplification rule._** If $f(n) = c \\cdot g(n)$ for some constant $c$, then $f$ is in $\\Theta(g)$. **_Examples._** - $f(n) = 3n$ is in $\\Theta(n)$ - $f(n) = 2n^3$ is in $\\Theta(n^3)$ - $f(n) = 5 \\log n$ is in $\\Theta(\\log n)$ - etc. **_Simplification rule._** - if $f(n) = \\log_a n$ (for some base $a$), then $f$ is in $\\Theta(\\log n)$ - if $f(n) = n \\log_a n$ (for some base $a$), then $f$ is in $\\Theta(n \\log n)$ - etc. **_Examples._** - $f(n) = \\log_2 n$ is in $\\Theta(\\log n)$ - $f(n) = \\frac{1}{5} \\log_3 n$ is in $\\Theta(\\log_3 n) = \\Theta(\\log n)$ - $f(n) = 4n \\log_2 n$ is in $\\Theta(n \\log_2 n) = \\Theta(n \\log n)$ **_Simplification rule._** If $f(n)$ is a sum of terms (e.g. a polynomial), then it belongs to the class that represents the highest order term. **_Examples._** - $f(n) = 2n^2 + 3n + 20$ is in $\\Theta(2n^2) = \\Theta(n^2)$ - $f(n) = \\frac{3}{2}n^3 + 2n^2 + 3n + 20$ is in $\\Theta(\\frac{3}{2}n^3) = \\Theta(n^3)$ - $f(n) = 2 n\\log(n) + 3n + \\sqrt{n}$ is in $\\Theta(2 n \\log n) = \\Theta(n \\log n)$ Big $O$ # **_Notation._** $O(f)$ denotes the union of all classes of functions that are at most as expensive as $f$ (asymptotically). **_Example._** $f(n) = 3n + 5$ is in $\\Theta(n)$, therefore the following also hold: - $f$ is in $O(n^2)$ - $f$ is in $O(n^2 \\log n)$ - $f$ is in $O(n^{2.5})$ - $f$ is in $O(n^3)$ - $f$ is in $O(2^n)$ **_Note._** As a consequence, $\\qquad f$ is in $\\Theta(g)$ is syntactic sugar for $\\qquad f$ is in $O(g)$ and $g$ is in $O(f)$ Overloaded equality # **_Warning._** Instead of \"$f$ is in $\\Theta(g)$\", it is customary to write: $\\qquad f(n) = \\Theta(g)$ (and similarly for $O$), thus overloading the meaning of the symbol \"$=$\". **_Examples._** - $f(n) = 3n^2 + 5 = \\Theta(n^2)$ - $f(n) = 2 n^2 \\log n = \\Theta(n^2 \\log n)$ - $f(n) = 2 n^2 = O(n^2)$ - $f(n) = 2 n^2 = O(n^3)$ Application # Let us now evaluate the asymptotic cost of some algorithms.\nFor simplicity, we will focus of the worst-case running time (but the same notion of asymptotic cost can be used for average cost and/or memory usage).\nRAM cost model # The so-called Random Access Machine (RAM) model of computation makes several assumptions about computational cost. In particular, for a given index $i$, the cost of accessing the $i^\\text{th}$ element of an array does not depend on the size of this array.\nAnother simplification that is often made (although not consistently by all authors) in the RAM model is that the cost of a value comparison or a basic arithmetic operation (e.g. addition or multiplication) does not depend on the values of its operands.\n**_Example._** Consider the following method ```java boolean myMethod(int[] A, int i){ return A[i] + A.length } ``` Let $n$ be the size of the input array $A$, and let us express the running time of this method as a function of $n$. If we adopt the RAM cost model, then: - the cost $c_1$ of reading the value `A[i]` is independent of $n$ - the cost $c_2$ of reading the length of `A` is also independent of $n$ - the cost $c_3$ of summing these two values is also independent of $n$ Therefore, expressed as a function $f$ of $n$, the running time of this method is $\\qquad f(n) = c_1 + c_2 + c_3$ which is in $\\Theta(1)$. In other words, the running time of this method is _constant_ in the size of the array. **_Example._** Consider the same algorithm as [above](#worstCaseOrAverage) (but where the meaning of `foreach` is made explicit) ```java {linenos=true} boolean contains(int[] A, int a){ int i = 0 while (i \u003c A.length) { if(A[i] == a){ return true } i++ } return false } ``` Once again, let $n$ be the size of the input array `A`, and let us express the worst case running time of this method as a function of $n$. Recall that the worst possible input is the one where the input value `a` does not appear in `A`. In this case, the loop is executed $n$ times. If we adopt the RAM cost model: - the cost $c_1$ of the initialization of `i` (line 2) is independent of $n$ - the cost $c_2$ of _one_ comparison of `i` with `A.length` (line 3) is independent of $n$ - the cost $c_3$ of _one_ execution of the loop is independent of $n$ - the cost $c_4$ of the final `return` statement (line 8) is independent of $n$ Therefore, expressed as a function $f$ of $n$, the cost of this method is $$ f(n) = c_1 + c_2 n + c_3 n + c_4 $$ $$ \\qquad\\ \\ = (c_2 + c_3) n + c_1 + c_4 $$ which is in $\\Theta(n)$. In other words, the worst-case running time of this method is _linear_ in the size of the array. Exercise What is the asymptotic running time of the [binary search](#worstCaseOrAverage) algorithm seen above, expressed as function of the size of the input array `A`? Solution The running time of this algorithm is logarithmic in the size $n$ of the array, i.e. in $\\Theta(\\log n)$. Exercise What is the asymptotic running time of the following method, expressed as function of the size of `A`? Can you think of a more efficient algorithm for the same problem (and what would be its running time)? ```java int myMethod(int[] A){ int val = 0 for (int i = 0; i \u003c A.length; i++){ for (int j = 0; j \u003c A.length; j++){ val += A[i] + A[j] } return val } ``` Solution The method has quadratic running time, i.e. its running time is in $\\Theta(n^2)$. A more efficient algorithm (with _linear_ running time) could be: ```java int myMethod(int[] A){ int val = 0 for (int i = 0; i \u003c A.length; i++){ val += A[i] } return 2 * n * val } ``` --\u003e --\u003e --\u003e --\u003e --\u003e --\u003e "},{"id":29,"href":"/docs/lambda/sections/captured/","title":"Captured variables","section":"Callback methods and lambda expressions","content":" Captured variables # In practice, lambda expressions are often used to represent pure functions.\nSome languages (like Java, JavaScript, C++, etc) restrict (or allow the user to restrict) the usage of lambda expressions, so that they lean towards pure functions.\n**_Terminology._** Some programming languages allow a lambda expression to use variables that: - are declared _outside_ of the lambda expression's body, and - are _not_ arguments of the lambda expression. In this case, the expression is called a **capturing lambda expression**, and these variable are said to be **captured**. **_Example._** In the following Java program, the lambda expression `x -\u003e x == a` is a capturing lambda, because it uses the variable `a`, which is defined outside of the lambda expression. ```java boolean myMethod() { int a = 2; return execute( 3, x -\u003e x == a ); } boolean execute(Integer x, Function function) { return function.apply(x); } ``` Captured variables in Java # **_Restriction._** A capture variable in Java must be **effectively final**, meaning that it cannot be modified after its initialization. **_Examples._** The following Java program is nearly identical to the previous one, but does _not_ compile, because the captured variable `a` is not effectively final. ```java boolean myMethod() { int a = 2; a = a + 1; return execute( 3, x -\u003e x == a ); } boolean execute(Integer x, Function function) { return function.apply(x); } ``` The following program does not compile either, for the same reason. ```java boolean myMethod() { int a = 2; return execute( 3, x -\u003e { a = a + 1; return x == a; } ); } boolean execute(Integer x, Function function) { return function.apply(x); } ``` **_Exception._** An exception to the rule above is captured variables that are allocated on the heap, i.e (class or instance) _attributes_. For instance, the following program is nearly identical to the (first) program above that does not compile. However, this new program compiles, because the captured variable `a` is now an instance attribute. ```java public class EnclosingClass { int a = 2; boolean myMethod() { a = a + 1; return execute( 3, x -\u003e x == a ); } boolean execute(Integer x, Function function) { return function.apply(x); } } ``` "},{"id":30,"href":"/docs/objects/sections/classesasobjects/","title":"Classes as objects","section":"Objects and classes","content":" Classes as objects # Some object-oriented languages (like Java, C# or C++) provide ways to access or manipulate classes (almost) as if they were objects.\nStatic attributes and methods # Static attributes # Java (as well as C# and C++) supports attributes that do not depend on a specific object, but on a _class_ instead. These are often called **static attributes** (or sometimes **class attributes** or **class variables**), as opposed to the attributes that we have seen so far, called **instance attributes** (or **member variables**). Static attributes are marked with the keyword static.\n**_Example._** Consider a version of our game where characteristics for each unit type (e.g. default health, etc.) can be declared manually, in a text file. The path to this file could be stored as a static attribute, as follows: ```java public class Unicorn { static String configFile = \"units/unicorn.txt\"; int health; public Unicorn(){ health = getHealthFromConfigFile(configFile); } public regen(){ health++; } } ``` Each instance of Unicorn carries its own value for the attribute health. But the value of configFile is unique.\nFor instance, the following program creates in memory a unique string for configFile, which is carried by the class.\nUnicorn u1 = new Unicorn(); Unicorn u2 = new Unicorn(); Static methods # Similarly to a static attribute, a **static method** does not depend on a specific object, as opposed to an [instance method](http://localhost:1313/docs/objects/sections/methods/). **_Example_** (continued). We can add to our class `Unicorn` a static method that checks whether the configuration file exists: ```java public class Unicorn{ ... static boolean configFileExists() { return Files.exists(Paths.get(configFile)); } } ``` (note that the method `getHealthFromConfigFile` also may also be static, if its execution is identical for all instances of `Unicorn`). Remember that an instance method can be called outside of the class where it is declared, using an instance of the class followed by .:\nUnicorn myUnicorn = new Unicorn(); myUnicorn.regen(); A static method can (syntactically) be called in the same way, for instance:\nUnicorn myUnicorn = new Unicorn(); boolean valid = myUnicorn.configFileExists(); However, this is often discouraged, because this syntax can be misleading (in this example, configFileExists can be mistaken for an instance method).\nAlternatively, since the method depends on the class (rather than an instance), the call can be prefixed with the class name. This syntax is often preferred, because it leaves no ambiguity. For instance:\nboolean valid = Unicorn.configFileExists(); Note that there may be several instances of a same class in memory during the execution of a program, or no instance at all. This is why a static method cannot reference an instance method or attribute. For instance, adding the following static method to our class would cause a compilation error, because health is an instance attribute.\npublic class Unicorn { static void reduceHealth(){ health--; } } Inheritance # Two static methods with the same name and signature can be declared in a class and a superclass. In Java\u0026rsquo;s terminology, this is not called method overriding, but instead method hiding. An important difference is that dynamic dispatch (a.k.a. runtime polymorphism) does not apply to this case (the method to be called is determined at compile time, rather than run time).\n**_Example_** (continued). Let us extend our example with a subclass of Unicorn that **hides** the static method `configFileExists`. ```java public class EvilUnicorn extends Unicorn { static boolean configFileExists(){ return false; } } ``` Now consider the following program, where the method getUnicorns produces an array of unicorns that depend on the player\u0026rsquo;s input. The specific type of objects in this array (Unicorn or EvilUnicorn) cannot be determined at compile time.\nUnicorn[] unicorns = getUnicorns(); for (Unicorn unicorn: unicorns){ System.out.println(unicorn.configFileExists()); } } In this example, the method of the superclass (i.e. Unicorn.configFileExists) will be executed for each object in the array, regardless of its type.\nThis is another reason why calling a static method via an instance (rather than via a class name) is often discouraged. In this example, writing Unicorn.configFileExists() would make it clear that this loop serves no purpose (the same method is executed unicorns.length times).\nReflection # Java (as well as C#) offers a mechanism called reflection to intuitively treat classes analogously to objects. Precisely, each class of a program (e.g. the class Unicorn) is associated with an object that represents it. This object is itself an instance of the Java class called Class. It can be accessed either:\nvia an instance of the class: Unicorn myUnicorn = new Unicorn(); Class unicornClass = myUnicorn.getClass(); or via the qualified name of the class (assuming for instance that the file Unicorn.java is in the folder \u0026lt;workingDirectory\u0026gt;/src/main/java/org/units): Class unicornClass = Class.forName(\u0026#34;org.units.Unicorn\u0026#34;); The instance methods of the class Class are listed here. Among others, they allow:\nlisting the attributes of the class, retrieving its immediate superclass, or the interfaces that it implements, creating a new instance of this class, etc. Reflection is a powerful feature. It is rarely used in everyday code, but can be helpful in specific situations. Notably, it is used (internally) by numerous Java frameworks such as Spring, Jackson or JUnit.\n"},{"id":31,"href":"/docs/multithreading/sections/abstractions/","title":"Abstractions","section":"Multithreading","content":" Abstractions # We review here some higher-level utilities available in Java to use multithreading, while reducing the risk of unwanted behaviors.\nThread safety # **_Terminology._** A method is said to be **tread-safe** if it can be accessed by concurrently by several threads without \"unexpected\" consequences. Thread safety is a vague term, which may for instance refers to implementations that are free of race conditions.\nMost high-level libraries or frameworks that exploit concurrency provide methods with some from of thread safety. In particular, this is the case of most Graphical User Interface frameworks (such as JavaFX or Swing for Java).\nBy default, it is highly recommended to rely on such methods when using concurrency. For instance, Effective Java (Item 81) recommends using \u0026ldquo;thread safe\u0026rdquo; concurrency utilities when possible, rather than Java\u0026rsquo;s (error prone) wait, notify and notifyAll methods.\nAtomic operation # **_Terminology._** An operation performed by a thread is **atomic** if no operation performed by a concurrent or parallel thread can affect its execution. We saw earlier that the operation\ni++; is not atomic, but corresponds to a sequence of instructions (fetch, increment and write).\nThe package java.util.concurrent.atomic provides classes like AtomicInteger, AtomicBoolean or AtomicReference that support atomic operations.\n**_Example._** The program ```java AtomicInteger i = new AtomicInteger(0); int j = i.getAndIncrement(); ``` is analogous to ```java int i = 0; int j = i++; ``` but the operation `i.getAndIncrement()` is atomic, whereas `i++` is not. Associative array # ConcurrentMap # The interface ConcurrentMap is a sub-interface of Map (which stands for an associative array) with additional atomicity and thread-safety guarantees.\nIt has two native implementations, one as a hash table, the other as a so-called skip list. The latter maintains the order of insertion, analogously to what we saw for a LinkedHashMap.\nConcurrentNavigableMap # The interface ConcurrentNavigableMap is a sub-interface of SortedMap (like TreeMap, that we saw in the dedicated section), with additional atomicity and thread-safety guarantees. It has one native implementations, as a so-called skip list.\nQueue # The Java interface BlockingQueue is a sub-interface of Queue (which stands for the abstract data type queue). In addition to the traditional operations supported by a queue (dequeue and enqueue), a blocking queue provides variants of these operations to:\nwait for the queue to become non-empty (when dequeuing), or wait for space to be freed in the queue (when enqueueing). These allow implementing the producer/consumer pattern seen earlier, without relying on Java\u0026rsquo;s wait, notify and notifyAll methods.\nBlockingQueue has several native implementations (e.g. as a doubly linked list or as a dynamic array).\nThread pool # A **thread pool** is a (of fixed or flexible) set of threads that can be reused for different tasks. The factory class Executors provides a series of static methods that return a thread pool. In particular:\nExecutors.newFixedThreadPool returns a pool (instance of ExecutorService) with a fixed number of threads (specified as argument), Executors.newCachedThreadPool returns a pool (also instance of ExecutorService), but with flexible size. In both cases, tasks submitted to the pool will reuse existing threads if available.\nAn introduction to Java thread pools can be found here.\n"},{"id":32,"href":"/docs/git/sections/backtracking/","title":"Backtracking","section":"git","content":" Backtracking # We already saw how a file can be unstaged (with git reset) before it is committed.\nIf the file was committed by mistake, then there are at least three scenarios.\nReset # If the commits that contain the file have not been shared yet with a remote, then these commits can be cancelled locally. The command\ngit reset \u0026lt;ID\u0026gt; moves the pointer for the current branch \u0026ldquo;back in time\u0026rdquo; to the commit \u0026lt;ID\u0026gt;. This has the effect of deleting all posterior commits.\nRevert # If the commits that contain the file have been shared with a remote, then git revert is often recommended by default.\nThis command does not affect the history of a branch (as opposed to git reset). Instead, if adds a commit to the history that reverts the k last commits on the current branch.\nFor instance\ngit revert HEAD adds a commit that reverts the latest one.\nAnd\ngit revert HEAD~3.. adds a commit that reverts the 3 latest ones.\nRewriting history # In some (rare) scenarios, one may need to rewrite the history of a branch that has already been shared.\nFor instance, sensitive information (passwords, etc.) or a large dataset may have been committed by mistake.\nDedicated tools may be used in such scenarios.\n"},{"id":33,"href":"/docs/objects/sections/clone/","title":"Duplicating objects","section":"Objects and classes","content":" Duplicating objects # In some scenarios, it may be useful to duplicate an object.\nIn Java, as we saw earlier, copying the value of a variable with reference type does not copy the object that it references. For instance, the following program outputs \u0026ldquo;yellow\u0026rdquo;:\nUnicorn unicorn = new Unicorn(\u0026#34;green\u0026#34;); Unicorn shallowCopy = unicorn; unicorn.color = \u0026#34;yellow\u0026#34;; System.out.println(shallowCopy.color); The need to duplicate objects may notably appear in a program that rely on concurrency.\nExercise In our game, the \"view\" component is in charge of rendering the game visually. This component exposes a method called `drawSnapshot` that takes as input a [game snapshot](http://localhost:1313/docs/interfaces/sections/java_interfaces/#snapshotExample) and draws this snapshot on screen. The backend calls this method whenever a snapshot must be drawn. However, the backend may send these snapshots _faster_ than they can be displayed (due to the duration of on-screen animations). To deal with this scenario, the \"view\" **buffers** the snapshots that it receives (displaying a new snapshot only after all previously submitted ones have been displayed). For the sake of this exercise, you can think of this buffer as an array with type `Snapshot[]`. Now consider the following method `deleteUnit(int x, int y)`, executed by our backend each time it receives the instruction to delete a unit: ```java public class Backend implements EventHandler { Snapshot currentSnapshot; ... public void deleteUnit(int x, int y){ if(\u003c\"there is a unit on the tile x, y\"\u003e){ removeUnitFromTile(x, y); drawSnapshot(currentSnapshot); shiftUnitsInColumn(x); drawSnapshot(currentSnapshot); performUnitMerges(); drawSnapshot(currentSnapshot); ... } } } ``` where the auxiliary methods `removeUnitFromTile`, `shiftUnitsInColumn` and `performUnitMerges` may modify the object `currentSnapshot`. Observe that the method `deleteUnit` calls `drawSnapshot` three times. Now let us assume that the buffer of the \"view\" is nonempty when this method is executed, so that the 3 snapshots are added to the buffer, before any of them can be rendered on screen. How many of these 3 snapshots will be drawn on screen? Solution Only the third snapshot will be drawn (three times), because the buffer contains three references to the same object. Shallow, deep and hybrid copy # Copying a reference to an object can be viewed as the shallowest possible form of copy. As we saw already, this is what happens in Java when a variable with reference type is passed as argument.\nAt the other end of the spectrum is a so-called deep copy, where all attributes of the copied object are duplicated, recursively. In this case, the copy or any object that it references (recursively) can be modified without affecting their original counterparts.\nBetween these two extremes:\na shallow copy creates a new object (with fresh attributes), but does not copy referenced objects recursively, a hybrid copy is anything between a shallow copy and a deep copy. in Java # Copy constructor # A copy can be performed in Java with a so-called **copy constructor**. This is an additional constructor that takes an instance of the class as input, and returns a copy of this instance. For example:\npublic class Hero { int health; // standard constructor public Hero(){ this.health = 10; } // copy constructor public Hero(Hero original){ this.health = original.health; } } In order to perform a deep(er) copy, a copy constructor may call another copy constructor. For example:\npublic class Snapshot { Hero firstHero; Hero secondHero; Board board; int remainingActions; // standard constructor public Snapshot(Hero firstHero, Hero secondHero, Board board, int remainingActions){ // some code here ... } // copy constructor public Snapshot(Snapshot original){ this.firstHero = new Hero(original.firstHero); this.secondHero = new Hero(original.secondHero); this.board = new Board(original.board); this.remainingActions = original.remainingActions; } } **_Warning._** Similarly to what we saw with the methods [toString](http://localhost:1313/docs/objects/sections/tostring/#recursion) or [equals](http://localhost:1313/docs/objects/sections/comparing/#recursion), beware of recursive implementations of copy constructors, if your program can create an object that refers to itself (directly or indirectly). The method clone # Java also provides a native method called clone to duplicate objects. Like the methods toString and equals that we saw earlier, clone is an instance method of the native Java class Object, which is an (implicit) superclass of every other class.\nOverriding clone can be more concise than using a copy constructor (especially for a class with a large number of attributes).\n**_Warning._** Overriding `clone` can be _error-prone_, especially in presence of a class hierarchy (see [Effective Java](http://localhost:1313/docs/intro/sections/bibliography/#effectiveJava), Item 13 for further insight). Notably, the overriding class must implement the `Cloneable` interface, and an implementation of `clone` usually calls `super.clone` recursively (even for a class whose only superclass is `Object`). For these reasons, overriding `clone` is sometimes discouraged, in favor of conceptually simpler solutions (like copy constructors). "},{"id":34,"href":"/docs/objects/sections/quasi-objects/","title":"Quasi-objects","section":"Objects and classes","content":" Quasi-objects # Enumerated types # Most imperative languages allow the creation of so-called enumerated types.\nAn enumerated type is a datatype for a finite set or enumerated values. For instance, if our game only allows \u0026ldquo;blue\u0026rdquo;, \u0026ldquo;green\u0026rdquo; and \u0026ldquo;red\u0026rdquo; as unit colors, then we may create a dedicated type that only allows these three values.\nIn Java # An enumerated type in Java is a set of constants. These constants are effectively static, meaning that they depends on the class or interface where the enumerated type is declared (similarly to a static attribute). The name of an enumerated type can generally be used like a regular reference type. For instance\npublic class Unit { enum UnitColor {BLUE, GREEN, RED} int health; UnitColor color; public Unit(int health, UnitColor color){ this.health = health; this.color = color; } ... } **_Note._** In the above example, the enumerated type `UnitColor` could equivalently be represented with an integer. For instance, `0` for blue, `1` for green and `2` for red. However, with such an encoding, a conditional statement (e.g. `if` or `switch`) that checks the color of a unit would also need to handle the case of values `\u003c 0` or `\u003e 2`. So (besides readability), a benefit of the enumerated type in this case is that it restricts possible inputs to _valid_ ones. **_Hint._** Enumerated types in Java are significantly more expressive than their counterparts in some other languages. Notably, a Java `enum` can have its own [constructor and methods](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html). Records # A record is an object whose attributes cannot be modified.\nin Java # Records were introduced in Java 14 (2020). They are a convenient way to avoid boilerplate code. Records provide a concise syntax for \u0026ldquo;lightweight\u0026rdquo; classes that are only meant to hold data.\nFor instance, here is the full implementation of a record City:\npublic record City(String name, int zipCode) {} This record has an implicit constructor, and implements equals, hashcode and toString in the expected way. For instance:\nCity florence = new City(\u0026#34;Florence\u0026#34;, 50100); City florenceAgain = new City(\u0026#34;Florence\u0026#34;, 50100); // Outputs true. System.out.println(florence.equals(florenceAgain)); The attributes of a record cannot be modified. For instance, the following program does not compile:\nCity florence = new City(\u0026#34;Florence\u0026#34;, 50100); florence.zipCode = 50121; A record is often declared inside a class or interface. For instance, in our game:\npublic class Board { public record TileCoordinates(int X, int Y){}; ... } Records are convenient for methods that need to return more than one value. For instance:\nTileCoordinates getOngoingMove(); Strings # Interning # Many modern languages (such as Java, C#, Python, Ruby, JavaScript, Go, etc.) support a technique called **interning**, in order to manage strings in memory. This consists in storing only one copy of each distinct string created during the execution of a program. These strings are stored in a shared **pool**, and each of them is an [immutable](http://localhost:1313/docs/objects/sections/mutability/) object (meaning that it cannot be modified). Some benefits are faster string comparisons, lower memory footprint, etc.\nin Java # In Java, a string is an object. Like for regular objects, comparing two variables of type String with == compares their references:\nString myString = new String(\u0026#34;foo\u0026#34;); String sameString = new String(\u0026#34;foo\u0026#34;); // Outputs false, because the two variables hold different references. System.out.println(myString == sameString); A string can be explicitly interned (i.e. added to the shared pool) with the (instance) method intern. This method:\ntries to add the string to the pool, and then returns a reference to the (only) version of the string contained in the pool. For instance, consider the following program:\n// Creates a string \u0026#34;foo\u0026#34;, String myString = new String(\u0026#34;foo\u0026#34;) // adds it to the pool, myString = myString.intern(); // Creates another string \u0026#34;foo\u0026#34;, String sameString = new String(\u0026#34;foo\u0026#34;); // Outputs false. System.out.println(myString == sameString); // Tries to add \u0026#34;foo\u0026#34; to the pool once again. // Because the pool already contains a version of \u0026#34;foo\u0026#34;, returns a reference to it. sameString = sameString.intern(); // Outputs true, because the two variables now hold the same reference. System.out.println(myString == sameString); A string that is initialized without constructor (i.e. directly with \u0026quot; \u0026ldquo;) is interned. For instance\nString myString = \u0026#34;foo\u0026#34;; String sameString = \u0026#34;foo\u0026#34;; // Outputs true, because of (implicit) interning System.out.println(myString == sameString); In order to support interning, string in Java are immutable.\nIn particular, the instance methods of the class String (like substring, etc.) do not modify a string. Instead, some of them may return (a reference to) a different object. For instance:\nString foo = new String(\u0026#34;foo\u0026#34;); String copy = foo; // Outputs true, because the two variables hold the same object reference. System.out.println(copy == foo); foo = foo.replace(\u0026#39;o\u0026#39;,\u0026#39;O\u0026#39;); // Outputs false, because the method \u0026#39;replace\u0026#39; returns a reference // to another object. System.out.println(copy == foo); The class String overrides the method equals so that it implements string comparison in the expected way. For instance:\nString myString = new String(\u0026#34;foo\u0026#34;); String sameString = new String(\u0026#34;foo\u0026#34;); // Outputs false. System.out.println(myString == sameString); // Outputs true. System.out.println(myString.equals(sameString)); **_Hint._** By default, you can always use `equals` to compare the values of two strings. This is less error-prone than `==` (albeit less efficient if the two strings differ). Java boxed types # Java has 8 primitive types: byte, short, int, long, float, double, boolean and char.\nFor each primitive type, Java has a so-called boxed or (wrapper) type: Byte, Short, Integer, Long, Float, Double, Boolean and Character.\nThese types can be used in Java collections (Set, List, etc.), whereas primitive types cannot. Some boxed types also offer additional functionalities, via instance methods (e.g. an Integer can represent a positive numbers up to \\(2^{32} - 1\\) ).\nConstructors for boxed types are deprecated. Instead, instances can be created via so-called autoboxing, for instance:\nInteger myInteger = 2; Character myCharacter = \u0026#39;a\u0026#39;; Several Java operators (like +, ==, \u0026lt;=, etc.) are also overloaded so that they behave with boxed types as they would with primitive types. For instance:\nInteger i = 1; i += 1; Integer j = 2; // Outputs true System.out.println(i == j); Like strings, instances of boxed types are immutable. This can affect performance. For instance:\nfor (Integer i = 0; i \u0026lt; 1000000 ; i++){ ... } may create up to 1 million objects in memory. This is one of the reasons why it is usually recommended to use primitive types whenever possible (see for instance Effective Java, Item 61). Some boxed types are (partially) interned, analogously to strings.\n"},{"id":35,"href":"/docs/objects/sections/encapsulation/","title":"Encapsulation","section":"Objects and classes","content":" Encapsulation # **Encapsulation** is a (vague) principle in object-oriented programming that refers to _\"bundling\"_ data with the code that operates on it, and _restrict visibility_ of this code and data to other components of a system. From Wikipedia: \u0026ldquo;Essentially, encapsulation prevents external code from being concerned [\u0026hellip;]\u0026rdquo;\nEach component hides its internal logic by exposing only data and methods that other components may need.\n**_Example._** As we saw [earlier](http://localhost:1313/docs/objects/sections/clone/), in our game, the \"view\" component (which is in charge of rendering the game on screen) may _buffer_ the game snapshots that it receives from the backend, if these snapshots are received faster than they can be displayed. As a buffer, this component uses a structure called a **queue**. This queue is _not exposed_ to other components, because they do not need to _see_ it, and (most importantly) should not _modify_ it. In other words, this queue is an implementation detail, _internal_ to the \"view\" component. Encapsulation can have many benefits. Among others:\nEasier debugging. If our queue is internal to the \u0026ldquo;view\u0026rdquo; component, then we know that it cannot be responsible for the malfunction of another component. Easier collaboration. Alice may refactor the implementation of the \u0026ldquo;view\u0026rdquo; component, knowing that this will not affect Bob, who is currently working on the backend. This is why a common practice in object-oriented programming consists in hiding all attributes and methods of a new class by default, and make accessible only the ones that need to be (in particular, this is likely to be the default behaviour of your IDE).\nEncapsulation also largely dictates how libraries are structured. For instance, when you create a String in Java, you do not have access to the internal representation of the string object.\nin Java # Each attribute or method of a class can have an access modifier, which specifies which other classes can access it. For instance, the keywords private and protected below are access modifiers.\nprivate int myAttribute; protected int myMethod(){ return 1; } **_Definition._** There are four levels of access in Java: - `private` restricts access to the _current class_, - \"package-private\" relaxes `private` by also allowing access from the _folder_ of the current class (in Java, a folder for source code is called a **package**), _excluding subfolders_, - `protected` relaxes \"package-private\" by also allowing access from the _subclasses_ of the current class, - `public` does not restrict access. **_Warning._** There is no keyword for the \"package-private\" level. Instead, this is the default level for an attribute or method _without_ access modifier. For instance, in the example below, the attribute `myAttribute` is package-private: int myAttribute; Here is a recap table from the Oracle tutorials:\nkeyword class package subclasses world private yes no no no none yes yes no no protected yes yes yes no public yes yes yes yes **_Warning._** A method declared in an [interface](http://localhost:1313/docs/interfaces/sections/java_interfaces/) is (implicitly) public. **_Warning._** If a method _m1_ overrides (or implements) a method _m2_, then _m1_ must be at least as accessible as _m2_. Exercise The following program does not compile. Can you see why, and how to fix this? ```bash ├── Run.java └── units ├── Unit.java └── impl └── Unicorn.java ``` ```java public abstract class Unit { static String configFolder = \"path/to/config\"; } ``` ```java public class Unicorn extends Unit { String name; public Unicorn (String name){ this.name = name; } public static String getConfigFilePath (){ return configFolder + \"/unicorn.properties\"; } } ``` ```java public class Run { void testUnicorn(){ Unicorn myUnicorn = new Unicorn(\"Storm\"); myUnicorn.name = \"Tornado\"; } } ``` Solution - `Unicorn.getConfigFilePath` tries to access the package-private attribute `Unit.configFolder` (it should be made protected of public), - `Run.getConfigFilePath`, tries to access the package-private attribute `name` of `myUnicorn` (it should be made public). **_Hint._** Your IDE may suggest how to fix such compilation errors. To improve encapsulation, it is good practice to restrict access whenever possible (i.e. without compromising compilation).\n**_Hint_.** As a rule of thumb, in Java: - use `private` by default for all attributes and methods that you create, and - if the program does not compile, then use your IDE to relax access. Exercise Encapsulation in this program can be improved. Can you see how? ```bash ├── Run.java └── units ├── Unit.java └── impl └── Unicorn.java ``` ```java public abstract class Unit { public int health; public Unit(int health) { this.health = health; } public void attack(Unit defender){ int copy = health; health -= defender.health; defender.health -= copy; } } ``` ```java public class Unicorn extends Unit { public Unicorn (){ super(1); } @Override public void attack(Unit defender){ regen(); super.attack(defender); } public void regen(){ health += 1; } } ``` ```java public class Run { void testUnicorn(){ Unicorn u1 = new Unicorn(); Unicorn u2 = new Unicorn(); u1.attack(u2); } } ``` Solution - `Unit.health` can be made protected, - the constructor of `Unit` can be made protected, - `Unit.attack` can be made protected, - `Unicorn.regen` can be made private. **_Note._** The constructor of an _abstract_ class can always be made protected (since it can only be called in the constructor of a subclass). Getters and setters # For attributes, the notion of \u0026ldquo;access\u0026rdquo; can be refined. An attribute may be:\nneither visible nor modifiable, or only visible, or only modifiable, or both visible and modifiable. This can be achieved with private attributes and so-called \u0026ldquo;getter\u0026rdquo; and \u0026ldquo;setter\u0026rdquo; methods. For instance, in the following class, the attribute health has public visibility but is not modifiable.\npublic class Unicorn { private int health; public int getHealth(){ return health; } } Conversely, in the following class, the attribute health can be modified but is not visible.\npublic class Butterfly { private int health; public void setHealth(int health){ this.health = health; } } **_Hint._** Getter and setter methods can be automatically generated by your IDE. To go further: inheritance violates encapsulation # Composition # **_Example_** (from [Effective Java](http://localhost:1313/docs/intro/sections/bibliography/#effectiveJava), Item 18). Consider a class `MyHashSet` that extends Java's `Hashset` functionality by keeping track of the number of objects _added_ to the set (as opposed to the output of `HashSet.size()`, which returns the numer of elements _remaining_ in the set). This class `myHashSet` may have an attribute `int counter` (initialized to `0`) that keeps track of the number of elements added to the set so far. And it may be implemented by overriding `add` and `addAll` in the expected way, i.e.: ```java @Override public boolean add(E e){ counter++; return super.add(e); } @Override public boolean addAll(Collection\u003c? extends E\u003e c){ counter += c.size(); return super.addAll(c); } ``` However, this implementation of `addAll` would count every insertion twice, because the implementation of `HashSet.addAll` calls `HashSet.add`. A design pattern called composition can be used to avoid such unintended effects. Intuitively, instead of extending the original class, use an instance Hashset set of it as a (private) attribute of the new class. However, this requires re-implementing all methods of the original class (albeit in a straightforward way), for instance:\npublic boolean isEmpty(){ return set.isempty(); } Prevent overriding or inheritance # As show by the example above, in order to improve encapsulation, one may want in some scenarios to forbid overriding a method or extending a class. In Java, this can be enforced with the keyword final, for instance:\npublic final class NonExtensibleClass { ... } public class MyClass{ public final void nonOverridableMethod(){ ... } } "},{"id":36,"href":"/docs/objects/sections/mutability/","title":"Mutability","section":"Objects and classes","content":" Mutability # Illustration # Exercise The Java method `createUsers` below is incorrect. Can you see why, and how to fix this? ```java public class User { int id; String name; } ``` ```java /* Input: - ids: a nonempty array of user identifiers - names: an array of the same length as 'ids' that contains user names Ouput: an array of users of the same lenght as 'ids', such as the i-th user has identifier ids[i] and name names[i] */ User[] createUsers(int[] ids, String[] names){ User[] users = new User[names.length]; User currentUser = new User(); for(int i = 0; i \u003c ids.length; i++){ currentUser.id = ids[i]; currentUser.name = names[i]; users[i] = currentUser; } return users; } ``` Possible solution The output array contains $i$ times the same user (with the last id and name from the input arrays). One way to fix this is: - add an explicit constructor to the class `User`: ```java public class User { int id; String name; public User(int id, String name){ this.id = id; this.name = name; } } ``` - call this constructor for each new user: ```java public User[] createUsers(int[] ids, String[] names) { User[] users = new User[names.length]; for(int i = 0; i \u003c ids.length; i++){ users[i] = new User(ids[i], names[i]); } return users; } ``` In this example, an instance of the class User is a mutable object, meaning that its attributes (id and name) can be modified after the object is created. However, these two values (or at least the value of the attribute id) are unlikely to change.\nIn Java (or C#, C++, etc.), it is possible to forbid these two values to be modified. This would have prevented compilation of the incorrect program above.\nImmutable object # Informally, an object is mutable if it can be modified after its creation.\nImmutability has many known benefits (but also drawbacks):\nBenefits # Easier debugging: as illustrated above, forcing an object to be immutable may prevent an incorrect program to compile. Compile-time errors are usually easier to fix that bugs. Readability: code that modifies or reuses objects can be harder to understand (and reason about) than code that creates (fresh) immutable objects. Thread-safety: multiple threads can access an immutable object concurrently without race condition. Easier collaboration and maintenance: Alice can safely pass an immutable object to Bob (i.e. make the object visible to Bob\u0026rsquo;s code). This will not affect the correctness of Alice\u0026rsquo;s code (because Bob\u0026rsquo;s code cannot modify this object). Reference. For a more in-depth analysis of the benefits of immutability, we refer to Effective Java, item 17:\n\u0026ldquo;Classes should be immutable unless there\u0026rsquo;s a very good reason to make them mutable.\u0026rdquo;\n**_Observation._** Some programming language (like Haskell or Rust), enforce (a form of) immutability by default. Drawbacks # Performance: on a large scale (e.g. thousands of objects), reusing existing object may be more efficient that creating (fresh) immutable ones. Terminology # The term \u0026ldquo;immutable object\u0026rdquo; (or \u0026ldquo;immutable class\u0026rdquo;) is used with slightly different meanings. In particular:\na weaker notion of immutability only requires the attributes of an object to be non-modifiable, a stronger notion also requires the objects that are referred to (transitively) to be non-modifiable. By convention, we will use in what follows the term \u0026ldquo;final\u0026rdquo; for the weaker requirement, and \u0026ldquo;immutable\u0026rdquo; for the stronger requirement. More precisely:\n**_Definition._** An object is **final** if its attributes cannot be modified after the object's creation. **_Definition._** An object is **immutable** if it is final and the objects that it references are immutable. in Java # final # The Java keyword final ensures that a variable cannot change value after its initialization.\n**_Example._** The following Java program does not compile. ```java final int a = 2; a = 3; ``` **_Warning._** This meaning of the keyword `final` is different from that we already saw in the section on [encapsulation](http://localhost:1313/docs/objects/sections/encapsulation/#final). When the variable is an instance attribute, this also forces the attributes to be explicitly instantiated before the execution of the constructor terminates.\n**_Example._** The following Java program does not compile. ```java public class User { final int id; final String name; public User(int id){ this.id = id; } } ``` **_Example._** The following Java program compiles, and the instances of `User` are immutable (because strings in Java are themselves immutable). ```java public class User { final int id; final String name; public User(int id){ this.id = id; this.name = name; } } ``` **_Note._** Alternatively, a `final` instance attribute can be instantiated immediately after it is declared (because this instruction is executed before the constructor). For instance, the following program compiles. ```java public class User { public final int id; public final String name = \"Alice\"; public User(int id){ this.id = id; } } ``` **_In practice._** Your IDE is likely to create `final` (and `private`) instance attributes by default. final vs immutable # **_Warning._** The `final` keyword may not be sufficient to enforce immutability (at least as it is defined above), in particular when a `final` attribute refers to a mutable object. **_Example._** Instances of the class `User` below are final, but not immutable, because instances of `Address` are not immutable. ```java public class User { final int id; final Address address; public User(int id, Address address){ this.id = id; this.address = address; } } public class Address { int streetNumber; String street; int zipCode; public Address(int streetNumber, String street, int zipCode){ this.streetNumber = streetNumber; this.street = street; this.zipCode = zipCode; } } ``` For instance, the following code compiles. ```java Address myAddress = new Address(14, \"via Goethe\", 39100); User myUser = new User(1, myAddress); myAddress.streetNumber = 12; ``` Final and immutable types # We already encountered several types of Java object and quasi-objects that are:\nfinal: records, sets (resp. lists, maps) that are declared with Set.of() (resp. List.of(), Map.of()), immutable: strings, boxed types (like Integer or Boolean). Record # A record is final.\n**_Examples._** Because strings are immutable, the following records are immutable: ```java record User(int id, String name){}; ``` However, the following records are only final (unless instance of `Address` are immutable): ```java record User(int id, String name, Address address){}; ``` Set, List, Map # If a set (resp. list, map) is created with Set.of() (resp. List.of(), Map.of()), then its content is final.\n**_Example._** The following Java program throws an `UnsupportedOperation` exception. ```java Set mySet = Set.of(2, 3); mySet.add(5); ``` However, if the set (resp. list, map) contains references, then the objects that are referred to may be mutable.\n**_Example._** The following program compiles (assuming that the attribute `streetNumber` of the class `Address` does not have the `final` keyword). ```java Address myAddress = new Address(14, \"via Goethe\", 39100); Set mySet = Set.of(myAddress); myAddress.streetNumber = 12; ``` By design, most other implementations of List, Set and Map are not final (this is expected, for performance reasons).\nHowever, in some scenarios, a program may create a (small) list (resp. set, map) that is not meant to be modified. For instance, the list of all files in a folder. In this case, the list (resp. set, map) can be made final. A common way to achieve this is the class ImmutableList (resp. ImmutableSet, ImmutableMap) of the Guava library.\nTo use Guava in a Maven project, declare this dependency:\n\u0026lt;dependencies\u0026gt; ... \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.guava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;guava\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;33.1.0-jre\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; ... \u0026lt;/dependencies\u0026gt; or in a Gradle project:\nimplementation group: \u0026#39;com.google.guava\u0026#39;, name: \u0026#39;guava\u0026#39;, version: \u0026#39;33.1.0-jre\u0026#39; String # Java\u0026rsquo;s strings are immutable.\nHowever, the class StringBuilder implements a mutable string. It provides instance methods like append, insert, delete (a substring), etc.\nBoxed types # Java\u0026rsquo;s boxed types (like Integer or Boolean) are immutable.\nHowever, each boxed types has a mutable \u0026ldquo;atomic\u0026rdquo; counterpart, e.g. AtomicInteger for Integer and AtomicBoolean for Boolean.\nThe main purpose of these classes is to offer build-in thread safety for common sequences of operations. For instance, AtomicInteger provides a method equivalent to i++, but thread-safe (note that i++ is a shortcut for three operations: read the value, increment it and write it back).\nExercise What does the following program output? ```java Boolean b = true; // Create an atomic boolean with value true AtomicBoolean ab = new AtomicBoolean(true); List booleans = new LinkedList\u003c\u003e(); List aBooleans = new LinkedList\u003c\u003e(); booleans.add(b); aBooleans.add(ab); b = false; // Set the value of the atomic boolean to false ab.set(false); booleans.add(b); aBooleans.add(ab); System.out.println(booleans); System.out.println(aBooleans); ``` Solution ``` [true, false] [false, false] ``` "},{"id":37,"href":"/docs/objects/sections/quiz/","title":"Quiz","section":"Objects and classes","content":" Quiz # To answer the quiz (and check your answers), click here or scan this code:\nBoxed type # public class City { int population; public City (int population){ this.population = population; } } int myInteger = 1; Integer myBoxedInteger = 1; Integer myBoxedCopy = myInteger; City myCity = new City(5000); myMethod(myInteger, myBoxedInteger, myBoxedCopy, myCity); System.out.println( myInteger + \u0026#34;, \u0026#34;+ myBoxedInteger + \u0026#34;, \u0026#34;+ myBoxedCopy + \u0026#34;,\u0026#34; + myCity.population); void myMethod(int integer, Integer boxedInteger, Integer boxedCopy, City city) { integer += 1; boxedInteger += 1; boxedCopy += 1; city.population += 1; } This Java program outputs:\n1, 1, 1, 5000 1, 1, 1, 5001 1, 2, 1, 5000 1, 2, 1, 5001 1, 2, 2, 5000 1, 2, 2, 5001 2, 2, 2, 5000 2, 2, 2, 5001 I do not know the answer Objects and references # ```java public class City { String name; Country country; public City(String name, Country country) { this.name = name; this.country = country; } } ``` ```java public class Country { String name; City capital; public Country(String name, City capital) { this.name = name; this.capital = capital; } } ``` Country italy = new Country(\u0026#34;Italy\u0026#34;, null); City florence = new City(\u0026#34;Florence\u0026#34;, italy); City rome = new City(\u0026#34;Rome\u0026#34;, italy); italy.capital = rome; System.out.print(italy.capital.name + \u0026#34;, \u0026#34;); System.out.print(florence.country.capital.name + \u0026#34;, \u0026#34;); System.out.print(rome.country.capital.name + \u0026#34;, \u0026#34;); System.out.print(rome.country.capital.country.capital.name); This Java program:\ndoes not terminate outputs null, null, null, null outputs null, null, Rome, null outputs null, null, Rome, Rome outputs Rome, null, null, null outputs Rome, null, Rome, null outputs Rome, null, Rome, Rome outputs Rome, Rome, Rome, Rome I do not know the answer Copy constructor # ```java public class City { String name; Country country; public City(String name, Country country) { this.name = name; this.country = country; } public City (City original) { this.name = original.name; this.country = original.country; } } ``` ```java public class Country { String name; City capital; public Country(String name, City capital) { this.name = name; this.capital = capital; } public Country(Country original){ this.name = original.name; this.capital = new City(original.capital); } } ``` Country italy = new Country(\u0026#34;Italy\u0026#34;, null); City rome = new City(\u0026#34;Rome\u0026#34;, italy); italy.capital = rome; Country littleItaly = new Country(italy); littleItaly.name = \u0026#34;littleItaly\u0026#34;; littleItaly.capital.name = \u0026#34;littleRome\u0026#34;; System.out.print(littleItaly.capital.name+ \u0026#34;, \u0026#34;); System.out.print(littleItaly.capital.country.name+ \u0026#34;, \u0026#34;); System.out.print(littleItaly.capital.country.capital.name); This Java program:\ndoes not terminate outputs Rome, Italy, Rome outputs Rome, littleItaly, Rome outputs littleRome, Italy, Rome outputs littleRome, littleItaly, Rome outputs littleRome, littleItaly, littleRome I do not know the answer toString # ```java public class City { String name; Country country; public City(String name, Country country) { this.name = name; this.country = country; } @Override public String toString() { return \"City{\"+ \"name=\" + name + \", \"+ \"country=\" + country + \"}\"; } } ``` ```java public class Country { String name; City capital; public Country(String name, City capital) { this.name = name; this.capital = capital; } @Override public String toString() { return \"Country{\"+ \"name=\" + name + \", \"+ \"capital=\" + capital + \"}\"; } } ``` In this program, the method City.toString():\ncan output the empty string always outputs the empty string never outputs the empty string is recursive is not recursive may not terminate always terminates never terminates Static attribute # public class MyClass { static int value; boolean flag; public MyClass(int value, boolean flag){ this.value = value; this.flag = flag; } void print(){ System.out.print(\u0026#34;[\u0026#34;+value+\u0026#34; \u0026#34;+flag+\u0026#34;]\u0026#34;); } void incrementValue(){ value++; } void setFlag(boolean flag){ this.flag = flag; } } MyClass o1 = new MyClass(2, true); MyClass o2 = new MyClass(3, false); o1.print(); myMethod(o1); o1.print(); void myMethod(MyClass object) { object.setFlag(false); object.incrementValue(); object.print(); } This (strange) Java program outputs:\n[2 true][3 false ][3 false] [3 true][4 false ][4 false] [2 true][3 false ][2 true] [3 true][4 false ][3 true] [2 false][3 false ][3 false] [3 false][4 false ][4 false] [2 false][3 false ][2 true] [3 false][4 false ][3 true] I do not know the answer. "}]