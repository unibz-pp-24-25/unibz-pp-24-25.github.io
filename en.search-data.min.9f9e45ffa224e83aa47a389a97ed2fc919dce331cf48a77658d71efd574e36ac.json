[{"id":0,"href":"/docs/git/sections/basics/","title":"Basics: repository, commits and branches","section":"git","content":" Basics: repository, commits and branches # Repository # A git repository is a folder that stores a project. It is identical to a regular folder, except for a folder named .git. This folder stores (among others) the whole history of the project.\nCommit # A commit is a snapshot of a repository.\nEach commit has medatada associated to it. In particular:\nan ID, the name of the commit\u0026rsquo;s author, a timestamp, a message that describes the commit. For instance, Alice may create a fresh git repository, add some files to it, and commit these files. After this step, Alice\u0026rsquo;s repository may be pictured as follows.\nNext, Alice may modify some of these files (and/or add new ones), and commit these changes:\nNotation. In the figures below, for readability, we will omit the commits\u0026rsquo; metadata. So the above repository will be represented as:\nMain branch # By default, Alice\u0026rsquo;s commits belong the main branch of her repository (often called main or master). You can think of a branch as a timeline.\nGit keeps tack of the latest commit on this branch with a so-called \u0026ldquo;pointer\u0026rdquo; (you can think of it as a variable) to that commit: Time travel # Alice can load any previous snapshot of her repository. The history of the repository will not be affected.\nTo achieve this, Git uses another \u0026ldquo;pointer\u0026rdquo; called HEAD, which intuitively keeps track of the current position of Alice in the commit\u0026rsquo;s history. By default, HEAD points to the main pointer: If Alice decides to load her previous snapshot (thanks to the git checkout command), then HEAD will instead point to the corresponding commit: In this case (i.e. when it does not point to a branch pointer, but directly to a commit), the HEAD pointer is said to be in a detached state.\nBranching time # Alice may want to work on an experimental feature of her project. She can develop this feature in an \u0026ldquo;alternative timeline\u0026rdquo;, a.k.a. another branch.\nBefore creating this new branch, Alice most likely wants to travel back to her latest commit. This will move the HEAD pointer back to where it was:\nNow Alice may create a new branch, and name it myFeature. This will create a new branch pointer:\nAlice can also specify that she want to work on this new branch (using the git checkout command still). This will affect the HEAD pointer:\nNext, Alice may implement (part of) her new feature, and commit these changes. This will move the myfeature pointer forward:\nNow Alice may need to fix an urgent bug on her main branch. If she switches to the main branch (again, with git checkout), then HEAD will point to it:\nAlice may fix the bug and commit her changes. This will create a commit and move the main pointer as expected. The two branches now diverge:\nThen Alice may switch back to the myFeature branch to resume her work:\nAnd add a commit to this branch:\nHistory # The history of a branch consists of all commits on a path from the branch\u0026rsquo;s pointer to the original commit. For instance, this is the history of the myFeature branch: And this is the history of main branch: Merging branches # We left Alice\u0026rsquo;s repository in this situation: Alice is now satisfied with her new feature, and she wants to incorporate it into her main branch.\nTo do so, she first switches to the receiving branch (in this case, the main branch): Then she can merge the branch myFeature into the branch main. Because the two branches have diverged, this will generate a new commit, called a merge commit:\nBefore she can create a merge commit, Alice may need to fix potential conflicts between the diverging branches.\nIn this happens, then git will provide Alice a list of files that contain so-called \u0026ldquo;merge conflicts\u0026rdquo;. In each of theses files, each conflict will be identified as follows:\n\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD \u0026lt;Conflicting content from the receiving branch\u0026gt; ======= \u0026lt;Conflicting content from the merged branch\u0026gt; \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026lt;mergedBranchName\u0026gt; After a merge # Observe that a merge commit (usually) has two parent commits. More generally:\na repository with merge commits is not a tree. in such a repository, the history of a \u0026ldquo;branch\u0026rdquo; may consists of commits from different paths. For instance, here is the history of the main branch: Note that after this merge, all commits of the myFeature branch are part of the history of the branch main.\nAlice may keep the myFeature branch for some future usage, or she may decide to delete it. In the latter case, the myFeature pointer will simply be deleted:\nFast-forward merge # If two branches have not diverged, then there is a simpler way to merge them.\nFor instance, consider Carol\u0026rsquo;s repository:\nThe branches main and experimental have not diverged. So experimental can be merged into main by simply moving the main pointer:\nIn this case, no merge commit is needed. This is called a fast-forward merge.\n"},{"id":1,"href":"/docs/errors/sections/callstack/","title":"Call stack","section":"Errors","content":" Call stack # A call stack is a stack that keeps track of the methods that are active during the execution of a program. By \u0026ldquo;active\u0026rdquo;, we mean that an execution of the method has started and has not terminated yet.\nWhen the execution of a method starts, the method is \u0026ldquo;pushed\u0026rdquo; on top of the stack. When it terminates, the method is \u0026ldquo;popped\u0026rdquo; from the stack, and control is passed back to the method that called it (which is now on top of the stack).\nA debugger provides a representation of the successive states of a call stack, with references to the source code. This gives the illusion of source code being interpreted verbatim.\nExample. In our game, consider the following implementation of the method callReinforcement:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class Backend implements EventHandler { Snapshot currentSnapshot; ... @Override public void callReinforcement() { Player activePlayer = currentSnapshot.getActivePlayer(); int unitsToInsert = currentSnapshot.getSizeOfReinforcement(activePlayer); while (unitsToInsert \u0026gt; 0){ Unit unit = generateRandomUnit(); TileCoordinates coordinates = findInsertionSpot(unit); if(coordinates != null) { addUnit(coordinates, unit); unitsToInsert--; } } } private Unit generateRandomUnit() { ... } private TileCoordinates findInsertionSpot(Unit unit) { ... } private void addUnit(TileCoordinates coordinates, Unit unit) { currentSnapshot.getBoard().addUnit(coordinates.rowIndex(), coordinates.columnIndex(), unit); performUnitMerges(); } private void performUnitMerges() { ... } } When the method callReinforcement is called, it is added (a.k.a. pushed) on top of the call stack. This is rendered by a debugger as:\ncallReinforcement \u0026lt;rest of the call stack\u0026gt; If execution \u0026ldquo;reaches\u0026rdquo; Line 13, then the method generateRandomUnit is called and added to the stack:\ngenerateRandomUnit callReinforcement: 13 \u0026lt;rest of the call stack\u0026gt; When the method generateRandomUnit terminates, it passes control (as well as a Unit) back to the method that called it, namely callReinforcement, which can resume its execution:\ncallReinforcement \u0026lt;rest of the call stack\u0026gt; Similarly, when execution \u0026ldquo;reaches\u0026rdquo; Line 14, findInsertionSpot is added to the stack, executed, and then removed from the stack, passing control back to callReinforcement.\nThen if execution \u0026ldquo;reaches\u0026rdquo; Line 16, addUnit is executed, which in turn calls performUnitMerges:\nperformUnitMerges addUnit: 32 callReinforcement: 16 \u0026lt;rest of the call stack\u0026gt; etc.\nNote. If a method is recursive (i.e. if it calls itself, directly or indirectly), then it may appear multiple times in the call stack. E.g.:\nmethod1 method2: 16 method1: 8 \u0026lt;rest of the call stack\u0026gt; Definition. A stack overflow occurs when the size of the call stack exceeds the capacity allowed by the execution environment. This is usually due to a non-terminating recursive method.\n"},{"id":2,"href":"/docs/background/sections/problem/","title":"Computational problem","section":"Background","content":" Computational problem # A computational problem is (usually) specified as:\na set of possible inputs, and the expected outputs (for these inputs). Problem vs algorithm # For instance, here is a problem that you may have encountered already:\nInput: a sorted array $A$ of integers, an integer $a$ Output: true if $a$ appears in $A$, false otherwise There are (infinitely) many algorithms that can solve this problem. But some of them are more efficient than others. Efficiency (a.k.a. computational cost) refers to the time and/or memory needed to execute an algorithm, expressed as a function of the size of the input (more on this later).\nExercise Can you think of (or do you already know) an algorithm that can solve this problem efficiently? Why is it efficient?\nSolution Algorithm. Let $n$ be the size of $A$, and let us assume for simplicity that arrays are $1$-indexed and that $A$ is nonempty.\nIf $n = 1$, then check whether $A$[1] $= a$. Otherwise: check whether $A[n/2] = a$ (where \u0026ldquo;$/$\u0026rdquo; is integer division, rounded up or down if $n$ is odd), depending on the result, repeat on either the left or the right half of $A$. Cost. If $A$ has length $n$, then the number of iterations of the procedure is (in the order of) $\\log_2 n$ in the worst case (e.g. if $a$ does not appear in $A$).\nHere is another problem that you may know:\nInput: an array of integers Output: an array with the same values, but sorted in ascending order And yet another:\nInput: a solvable grid of sudoku Output: the same grid, solved Note. A problem specifies what a program should do, not how to do it. In other words, a computational problem is not an algorithm.\nFor instance, the following is not a computational problem:\nInput: an array of integers. Algorithm: initialize a counter to $1$. Then iterate through the array, and: increment the counter each time two consecutive numbers are encountered, or reset the counter to $1$ otherwise. Exercise Which problem does this algorithm solve? Is this algorithm efficient?\nSolution Input: an array $A$ of integers Output: the length of the longest suffix of $A$ that consists of consecutive numbers Formulating a problem # When developing a project, it can be helpful to express some sub(tasks) as computational problems. This is also a common way to document your code.\nFor instance the Javadoc of a class may consist of computational problems (e.g. the Javadoc for the method endsWith of the class String in Java).\nWhen formulating a problem, make sure that:\nthe output is specified for all inputs, and the formulation is non-ambiguous, meaning that it should clearly specify whether any given pair (input, output) is correct. Exercise Consider the class Unit (and its subclasses), as defined in the section about inheritance. The following problem is not properly defined. Can you see why?\nInput: a nonempty array A of instances of the class Unit Output: the unicorn with highest health in A Solution There may be no unicorn in A, or several healthiest unicorns.\nExercise The following problem is not properly defined. Can you see why?\nInput: a (finite) family of (finite) sets Output: the smallest set that has a nonempty intersection with each of the input sets (where \u0026ldquo;smallest\u0026rdquo; here refers to the size of a set) For instance, for the input\n{ {a,c,k}, {a,b}, {a,m}, {c,d,f}, {c,e} } the expected output is\n{a,c} Solution Some inputs admit more than one solution (the simplest example is the input {{a,b}}).\nNote. A problem may admit several outputs for the same input without being ambiguous. For instance:\nInput: a graph G, two nodes s and t in G, Output: one of the shortest paths from s to t in G if any, and null otherwise. A problem may be undecidable, meaning that for any algorithm attempting to solve this problem, there (provably) exist (infinitely many) inputs for which the algorithm either produces an incorrect output or does not terminate.\nA problem may be decidable but intractable, meaning that (provably) no efficient algorithm can solve it (where cost is once again measured as a function of the size of the input).\n"},{"id":3,"href":"/docs/abstractdatatypes/sections/list/","title":"List","section":"Abstract data types","content":" List # The abstract data type list simulates a tuple.\nAccordingly, a list may contain duplicates.\nA list may expose the following methods:\nisEmpty is self-explanatory, append adds an element at the end of the list, prepend adds an element at the beginning of the list, tail returns the sub-list identical to the current one, but without its first element, etc. Note. The size of a list is often unbounded (as opposed to the size of an array for instance). This can be implemented in different ways, for instance with a dynamic array or a linked list.\nin Java # Java has an interface List with 8 native implementations (i.e. 8 different classes that implement this interface). The most commonly used are ArrayList and LinkedList.\nThe interface List extends the interface Collection.\nSyntax # Here are code snippets for a few operations specified in the interface List.\nCreate a List and populate it: City milan = new City(\u0026#34;Milan\u0026#34;, 20100); City florence = new City(\u0026#34;Florence\u0026#34;, 50100); // Creates an empty list of cities List\u0026lt;City\u0026gt; myList = new ArrayList(); // Appends Milan to the list myList.add(milan); // Appends Florence to the list myList.add(florence); // Appends Milan again to the list myList.add(milan); // Creates a list identical to the previous one, but which cannot be modified List\u0026lt;City\u0026gt; myOtherList = List.of(milan, florence, milan); City[] myArray = new City[]{milan, florence}; // Creates a fixed-lenght \u0026#34;wrapper\u0026#34; list around the array. // No data is duplicated. List\u0026lt;City\u0026gt; yetAnotherList = Arrays.asList(myArray); Retrieve the size of a list: // Outputs 3 System.out.println(myList.size()); Retrieve the element at index i (the first index being 0, like in an array): // Contains (a reference to) Florence City secondCity = myList.get(1); Insert an element at index i (shift the position of all subsequent elements by 1). City trento = new City(\u0026#34;Trento\u0026#34;, 38100); myList.add(1, trento); // Now contains (a reference to) Trento secondCity = myList.get(1); // contains (a reference to) Florence City thirdCity = myList.get(2); Remove the element a index i (shift the position of all subsequent elements by -1), and return it myList.remove(1); // Outputs 3 Sysetm.out.println(myList.size()); // Now contains (a reference to) Florence secondCity = myList.get(1); Remove the first occurrence of an object in the list (shift the position of all subsequent elements by -1): myList.remove(milan); // contains (a reference to) Florence City firstCity = myList.get(0); For more operations, consult the Javadoc of the interface List.\n"},{"id":4,"href":"/docs/objects/sections/objects/","title":"Objects","section":"Objects and classes","content":" Objects # An object groups data in a meaningful way.\nA simple example: JSON objects # Here is a JSON object (in Javascript syntax) that describes the city of Florence:\n{ name: \u0026#34;Florence\u0026#34;, zipCode: 50100 } A JSON object may contain other objects, as well as arrays (of values, objects or arrays). For instance:\n{ name: \u0026#34;Alice\u0026#34;, age: 26, birthPlace: { name: \u0026#34;Florence\u0026#34;, zipCode: 50100 }, jobs: [ { employer: \u0026#34;Kolping\u0026#34;, start: 2021, end: 2022 }, { employer : \u0026#34;Eurac\u0026#34;, start: 2023 } ] } In JSON:\nan element can be either: a scalar (e.g. an integer), or an array of elements, or an object, an object is a finite set of key-value pairs, where keys are distinct, and each value is an element. Besides, a JSON element must have finite depth.\nEquivalently, a JSON object can be viewed as a function (with finite domain) that maps keys to JSON elements.\nObjects and programming languages # JSON objects do not exactly correspond to the objects that can be created in Java (and many other programming languages). We highlight here two important differences.\nTypes # Exercise Find a JSON object that satisfies the above description but cannot be represented as an object in a (strongly) typed language such as Java, C++, C#, etc.\nPossible solution { key: [1, [2, 3]]; } In a typed language (like Java), the elements of an array must be of the same type.\nThis is not required in Javascript, Python, etc.\nReferences # A Java (or Python, C#, etc.) object does not contain objects or arrays, but references to objects or arrays. For instance, the equivalent in Java of the above object may be pictured as follows (abusing notation):\n_1: { name: _2, age: 26, birthPlace: _3, jobs: _4, } _2: [\u0026#39;A\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;e\u0026#39;] _3: { name: _5, zipCode: 50100 } _4: [ _6, _7 ] _5: [\u0026#39;F\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;e\u0026#39;] _6: { employer: _8, start: 2021, end: 2022 } _7: { employer: _9, start: 2023 } _8: [\u0026#39;K\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;g\u0026#39;] _9: [\u0026#39;E\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;] Each object or array has an ID (e.g. _1 in this example), which can be used to refer to it (you can think of this ID as an address in memory).\nAs a consequence, some objects can be created in Java that have no (finite) representation in JSON.\nExercise Find one of these objects.\nPossible solution _1: { name: _2, friends: _3 } _2: [\u0026#39;A\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;e\u0026#39;] _3: [ _4, _7 ] _4: { name: _5, friends: _6 } _5: [\u0026#39;B\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;b\u0026#39;] _6: [ _1, _8 ] If we try to represent these objects in JSON, we get (assuming that we start with Alice):\n{ name: \u0026#34;Alice\u0026#34;, friends: [ { name: \u0026#34;Bob\u0026#34;, friends: [ { name: \u0026#34;Alice\u0026#34;, friends: [ ... ]}]}]} Cyclic references (like in this exercise) naturally occur in object-oriented code. Identifying them may be essential to debug a program that does not terminate or runs out of memory (stack overflow, \u0026hellip;).\n"},{"id":5,"href":"/docs/project/sections/free_project/","title":"Option 1: free project","section":"Project","content":" Option 1: free project # The first possible type of group projects is for students to develop a Java application of their choice.\nThis application is only a prototype, so it does not need a comprehensive list of features or functionalities.\nThe evaluation of the project will be mostly based on its backend (rather than the frontend). This means that the application:\ndoes not need a graphical user interface (but may have one), should perform non-trivial backend task(s) (e.g. writing and/or reading to/from files is not sufficient). Guidelines # Motivation # A good projects is driven by an idea.\nFeel free to design your application so that it matches your own interests. For instance:\nrelate it to a hobby (music, cinema, fashion, sport, games, social media, astronomy, etc.), use the project as an opportunity to explore a topic that you are curious about (natural language processing, computer vision, recommender systems, robotics, etc.), develop a functionality that one of your favorite applications is missing. Do not hesitate to be ambitious at first. You can restrict the scope of your project (to certain features or components) later on.\nSpecification # A frequent source of failure for this course is students focusing on tools (e.g. following tutorials) without having a precise objective. The short deadline (June 2025) does not give you this flexibility. Besides, without a precise objective, the amount of libraries that are available to you (especially in Java) can be overwhelming.\nSo we recommend you to clarify what your application should do, before thinking about how you could implement it. In other words, specify which problem(s) (i.e. input and expected output) your program and/or components should solve. Then only think about algorithms, libraries, tools and/or tutorials that can help you solve these problems.\nIn order to determine whether your specification is precise enough, you may check whether it leaves some doubt as to whether an output is correct or not.\nUser interface # Developing a Graphical User Interface (GUI) requires familiarity with a graphical framework. Learning the details of such a framework (terminology, syntax, setup, etc.) can be an important time investment, and this knowledge may not transfer to other graphical frameworks. In other words, developing a GUI may not require lot of thinking, but a lot of reading (and web browsing).\nBeware also that GUIs technologies are still rapidly evolving, and that recent innovation has largely been driven by web development. So learning a graphical framework for Java may not be a strategic investment of your time (compared to learning a Javascript framework like React or Angular). Note that even desktop and mobile applications are increasingly relying on web technologies for their GUIs (thanks to frameworks like Electron or React Native).\nThis is why we recommend you to think carefully before committing to a Java GUI, and to keep it minimal if you do. Note also that we will not evaluate your project based on aesthetic criteria.\nSo in order to design your interface, you may follow the following guidelines:\nAsk yourself whether your application really needs a GUI. A command-line interface (CLI) may be sufficient, because: your program takes files as input and produces files as output, or your program is (primarily) meant to be used by other programs (rather than human beings), or your program is meant to be used by other developers, or external programs with GUIs (such as IDEs) can easily call your application, or you leave the GUI for future work (again, your application is just a prototype), etc. If you really need a GUI, then: decouple frontend and backend (whenever possible), so that the backend could be used with another frontend, and conversely. Many applications accessible via GUI have a natural decoupling of frontend and backend. Example. Consider an application that allows booking hotel rooms. The backend takes as input some data (e.g. number or guests, arrival date, departure date, etc.), and outputs data as well (available rooms, prices, etc.). These input and outputs are objects, integers, strings, etc. They do not depend on a specific GUI (windows, menus, buttons, colors, etc.).\nExample. Even for some games, frontend and backend can easily be decoupled. Consider for instance a program that plays chess against a human opponent. The backend:\nkeeps track of the current state of the board, takes as input either a move from the white player, or a request to play as the (bot) black player, outputs the next state of the board. These input and output do not depend on a specific GUI (they can for instance be encoded using algebraic notation). So the backend can be implemented without any reference to graphical elements or controller inputs (mouse clicks, etc.).\ndevelop the backend first (and write unit tests for it),\ndevelop the frontend afterwards (if you have time for it).\nIf you really need a GUI, then try to keep it minimal. In particular, restrict the input to what is essential for your application (the more freedom the user is given, the more likely he/she is to input a sequence of actions that your program cannot handle). Illustrations # Here are some examples of (past and imaginary) possible projects:\na program that detects texts generated by a large language model, a program that takes as input a dataset of Tweets and identifies communities and/or influencers based on the network formed by re-tweets, a program that retrieves news articles about an input topic (using web APIs), and analyses their polarity (via sentiment analysis) together with their provenance (news outlet, country, etc.), a (toy) recommender system, a program that generates (solvable) sudoku grids with different sizes and/or level of difficulty, a game to help people improve their typing speed, a web crawler that retrieves sport-related statistics from various websites and exposes them via a web API, a classroom reservation system for the Unibz that can computes a default schedule for a whole semester, satisfying a set of constraints (room capacity, etc.) and/or preferences (minimize days of presence per week of a same group, etc.), a flashcard app that incorporates answers produced by a chatbot, an (Obsidian-like) note management application, a program to organize and manage coding contests (similar to this one), a password manager (with encryption), for instance similar to pass, where password update and synchronization are performed via git, a program that analyzes the commit and/or branching history of a git repository (e.g. contributions of the different users, frequency of commits, percentage of preserved code, etc.). "},{"id":6,"href":"/docs/build/sections/packaging/","title":"Packaging a Java application","section":"Build automation","content":" Packaging a Java application # Java (like C# or Python) is a precompiled language, meaning that source code is compiled into a machine-independent representation called bytecode.\nBytecode can be distributed and executed on any machine.\nIn Java, by convention, a source file MyClass.java is compiled into a bytecode file MyClass.class.\nA Java Virtual Machine (JVM) is a program in charge of executing Java bytecode.\nA packaged Java program is usually a zip file that contains:\nbytecode, metadata, and possibly:\ndependencies, other resources (data, images, etc.). Jar file # A jar (for Java ARchive) file is a zip file with extension .jar. This is the most common packaging format for Java applications.\nA jar can be:\na thin jar (i.e. excluding dependencies) or a fat (a.k.a. Ã¼ber) jar (i.e. including dependencies), runnable or non-runnable. A jar contains a text file META-INF/MANIFEST.MF that provides metadata about the package, as a set of key: value pairs (one per line). Among others, it may contain:\nthe name, version and author(s) of the program, the entry point of the program (i.e. the class that contains the main method), paths to additional .class files that are part of the program, etc. Details can be found here.\nNote. A jar for an application (including the META-INF/MANIFEST.MF file) is usually created via a build automation tool (like Maven or Gradle).\nBut if you are curious, you can also build a (toy) jar via command line. A good illustration can be found on the website of the 22-23 course.\nNote. Unit tests (and test-related resources) are usually not included in the release of a program. Therefore in Java, these are generally absent from a jar.\n"},{"id":7,"href":"/docs/input/sections/files/","title":"Paths and files in Java","section":"I/O and serialization","content":" Paths and files in Java # Java\u0026rsquo;s initial package for input/output (I/O) is called java.io. A central class in this package is File.\nOver the years, programmers realized that this package had limitations: limited error handling, limited support for file metadata (owner, access rights, etc.), and some performance issues.\nWith Java 7 (2011), A new I/O package called NIO2 was released, with additional features (and in some cases a more concise syntax). A central interface (resp. utility class) in this package is Path (resp. Files).\nHowever, the package java.io is still part of the latest Java release (it has not been deprecated), in part for backward compatibility reasons.\nIn this chapter, we will focus whenever possible on NIO2\u0026rsquo;s classes and methods, rather than java.io. In particular, we will use Path when possible rather than File.\nNote also that some external libraries (notably Apache commons.io and Guava) provide additional methods for I/O, sometimes with a more concise syntax.\nWarning. Many native Java methods that involve path or file manipulation may throw a checked exception (generally an IOException). For instance, among the methods below, this is the case of:\nPath.toRealPath, Files.size, Files.walk, etc. As a reminder, when such a method is used, checked exceptions must be either caught or explicitly rethrown, otherwise the program will not compile.\nPaths # An instance of Path represents a path in the hierarchical file system.\nAn instance of Path can be created in multiple ways. For instance:\nPath myPath = Path.of(\u0026#34;path/to/file.txt\u0026#34;); Path samePath = Path.of(\u0026#34;path\u0026#34;, \u0026#34;to\u0026#34;, \u0026#34;file.txt\u0026#34;); // Extend a path Path folder = Path.of(\u0026#34;path/to\u0026#34;); // identical to myPath Path myPathAgain = folder.resolve(\u0026#34;file.txt\u0026#34;); Path names # Note. If the string path/to/file.txt is used to create a Java Path (or a Java File), then the / symbol is interpreted (at runtime) as the path separator of the operating system (OS) that executes the program. So you can safely use this syntax, regardless of your OS. Precisely:\nif the program is executed on macOS, Linux, Android, etc., then this string will be interpreted as is, if the program is executed on Windows, then this string will be interpreted as path\\to\\file.txt. Warning. If the string path\\to\\file.txt is used to create a Java Path, then this string will be interpreted as is. So the program may run on Windows, but fail on other systems.\nWarning. Paths are case-sensitive (by default) on Linux, Android, etc., but case insensitive (by default) on Windows and macOS. For maximal compatibility, make sure that path names in your code respect the case of your file and directory names.\nWarning. Do not use absolute paths in your code (e.g. /home/alice/workspace/javaProject/myFile.txt, or C:\\Users\\alice\\workspace\\javaProject\\myFile.txt). Your program may run on your own computer, but will fail on others.\nWorking directory # Warning. When a Java program is executed, relative paths are understood as paths from the current working directory (WD).\nIf you need to know the WD, you can use the following (among other possibilities):\nPaths.get(\u0026#34;\u0026#34;).toAbsolutePath(); This instruction returns an absolute Path to the WD.\nFor instance,\nSystem.out.println(Paths.get(\u0026#34;\u0026#34;).toAbsolutePath()); may output on Windows:\nC:\\Users\\alice\\workspace\\javaProject or on macOS:\n/Users/alice/workspace/javaProject or on Linux:\n/home/alice/workspace/javaProject The Path interface # Here are examples of outputs for some methods of the Path interface (assuming that the WD is /home/alice/workspace/javaProject):\nPath path = Path.of(\u0026#34;src/main/../main/resources/myFile.txt\u0026#34;); // Outputs \u0026#39;/home/alice/workspace/javaProject/src/main/../main/resources/myFile.txt\u0026#39; System.out.println(path.toAbsolutePath()); // Outputs \u0026#39;/home/alice/workspace/javaProject/src/main/resources/myFile.txt\u0026#39; System.out.println(path.toRealPath()); // Outputs \u0026#39;myFile.txt\u0026#39; System.out.println(path.getFileName()); // Outputs \u0026#39;false\u0026#39; System.out.println(path.isAbsolute()); Hint. The method String.endsWith can be used to check whether a file has a certain extension. E.g.\n// Outputs \u0026#39;true\u0026#39; path.toString().endsWith(\u0026#34;.txt\u0026#34;); Existence and metadata # Static methods of the class Files can be used to check whether a file or directory exists, and retrieve metadata about it:\nPath path = Path.of(\u0026#34;src/main/resources/myFile.txt\u0026#34;); System.out.println(\u0026#34;Exists = \u0026#34; + Files.exists(path)); System.out.println(\u0026#34;Is directory = \u0026#34; + Files.isDirectory(path)); System.out.println(\u0026#34;Is file = \u0026#34; + Files.isRegularFile(path)); System.out.println(\u0026#34;Is hidden = \u0026#34; + Files.isHidden(path)); System.out.println(\u0026#34;Size = \u0026#34; + Files.size(path) + \u0026#34; bytes\u0026#34;); System.out.println(\u0026#34;Last modified = \u0026#34; + Files.getLastModifiedTime(path)); Navigation # Path path = Path.of(\u0026#34;src/main/resources/myFile.txt\u0026#34;); // Get the parent directory \u0026#39;src/main/resources\u0026#39; Path dir = path.getParent(); // Contains all files and folders in \u0026#39;src/main/resources\u0026#39; List\u0026lt;Path\u0026gt; children = Files.list(dir).toList(); // Contains all files and folders that have \u0026#39;src/main/resources\u0026#39; // as ancestor, including \u0026#39;src/main/resources\u0026#39; itself. List\u0026lt;Path\u0026gt; descendents = Files.walk(dir).toList(); Manipulation # // Create a directory Path folder = Path.of(\u0026#34;myFolder\u0026#34;); Files.createDirectory(folder); // Create nested directories Path subfolder = Path.of(\u0026#34;myFolder/sub1/sub2\u0026#34;); Files.createDirectories(subfolder); // Create a file Path file = Path.of(\u0026#34;myFolder/hello.txt\u0026#34;); Files.createFile(file); // Move/rename a file Path destination = Path.of(\u0026#34;myFolder/sub1/bye.txt\u0026#34;); Files.move(file, destination); // Copy a file Path copy = Path.of(\u0026#34;myFolder/sub1/sub2/bybye.txt\u0026#34;); Files.copy(renamedFile, copy); // Delete a file. Files.delete(copy); // Delete a directory. // The directory must be empty. Files.delete(subfolder); "},{"id":8,"href":"/docs/intro/sections/schedule/","title":"Schedule","section":"This course","content":" Schedule # The course consists of 60 hours of lectures and 30 hours of labs.\nLectures # By default, lectures are scheduled:\nMonday 13:30 - 15:30 Tuesday 08:30 - 10:30 Wednesday 08:30 - 10:30 All students attend the same lectures.\nLectures can be followed via Teams (e.g. for students sitting at the back of the class), by joining the corresponding meeting (in the \u0026ldquo;Lectures\u0026rdquo; channel of this course\u0026rsquo;s Team).\nLabs # By default, labs are scheduled:\nMonday 15:30 - 17:30 Wednesday 13:30 - 15:30 Students are split in two groups (to be determined) for the labs, with identical content. Students who collaborate on the same group project are expected to attend the same lab.\nMost labs will be dedicated to the assignments for this course. Two labs will be dedicated to a presentation and discussion of the advancement of the group projects.\nTimetable # Some weeks will see fewer lectures/labs, and schedules or room numbers may vary from one week to the other. So make sure to check the timetable.\n"},{"id":9,"href":"/docs/interfaces/sections/specification/","title":"Specification and programming interface","section":"Interfaces","content":" Specification and programming interface # Specification # The specification of a method usually consists of:\nthe computational problem that the method solves (if any), and (if needed,) a description of the format of the input and expected output, and (if applicable,) a description of the behavior of the program for invalid inputs (e.g. errors thrown by the method), and (if useful,) information about the implementation (e.g. if this may have an impact on performance for certain inputs). Example.\nboolean isSolvable(int[][] grid) Input: a 9 x 9 array of integers with numbers between 0 and 9 Output: true is this array represents a sudoku grid with a unique solution (where 0 stands for the absence of value) Errors: if the array\u0026rsquo;s size is not 9 x 9 if the array contains a number smaller that 0 or greater than 9 If a method has no return type or is not a pure function, then the specification may indicate the effect the method on its environment.\nThe specification of a command (for a program with a command line interface) is similar, but may include additional information about the syntax of the command (options, arguments, etc.)\nProgramming interface # In its simplest form, a programming interface is a set of method/command specifications.\n"},{"id":10,"href":"/docs/labs/env/sections/prelim/","title":"Terminal and text editor","section":"First lab","content":" Terminal and text editor # For this lab, you will need to know how to open a terminal and a text editor.\nTerminal # You can launch a terminal in multiple ways:\nsearching for applications, clicking on the corresponding icon or desktop shortcut (if there is one), with a keyboard shortcut (e.g. Ctrl+Alt+t by default on Ubuntu). Warning. Windows comes with two shells by default. Out of these two, we (highly) recommend the Windows PowerShell.\nText editor # Make sure that you know how to open, modify and save a text file on your machine with a text editor. The following text editor should be installed by default:\non Windows: Notepad++ on macOS: TextEdit on Linux (depending on your distribution and/or desktop environment): gedit, xed, mousepad, etc. Other popular options include VSCode, emacs, vim or neovim, sublime text, geany, etc.\nYour can open your text editor in multiple ways:\nsearching for applications, clicking on the corresponding icon or desktop shortcut (if there is one), from a terminal: for instance, on Windows: type notepad to open Notepad++, type notepad \u0026lt;path/to/my/file\u0026gt; to open a file with Notepad++. "},{"id":11,"href":"/docs/intro/","title":"This course","section":"Docs","content":" Structure and organization of the course # This chapter explains how the course is structured and provides a brief overview of its content.\n"},{"id":12,"href":"/docs/git/sections/collaboration/","title":"Basics: network and collaboration","section":"git","content":" Basics: network and collaboration # Network # In the previous section, Alice created and manipulated a git repository (with two branches).\nShe may also want to backup her work. To this end, she can upload some of her branches to a remote server. For instance use a cloud hosting service for git repositories (such as GitHub, Gitlab, Bitbucket, etc.).\nWhenever Alice wants to upload the content of a branch, she can push this branch to the remote server.\nAlice may also want to work from another computer (or a virtual machine). She can achieve this by cloning the repository from the remote server to this second machine.\nWarning. By default, cloning a repository will only clone the main branch. But other branches (or all branches) can also be cloned explicitly.\nNote. When two machines share a git branch, each of them has a copy of the full history of the branch.\nNote. A branch can be shared with several remote servers (e.g. one for releases and one for development or continuous integration).\nFor these two reasons, git is sometimes called a \u0026ldquo;distributed\u0026rdquo; versioning system.\nCollaboration # Enters Bob\u0026hellip;\nBob may want to collaborate with Alice on her project. He can clone Alice\u0026rsquo;s repository, and add his own commits.\nIn order to synchronize their work, Alice and Bob may agree to share the content of one or several branches (for instance the main branch).\nWarning. For a smooth collaboration, code on a shared branch is expected to:\ncompile and pass all unit tests defined for the project. A basic workflow # Alice and Bob share the main branch of their repository, and this branch is called main. This generally means that there are (at least) 3 copies of this branch: one on Alice\u0026rsquo;s machine, one on Bob\u0026rsquo;s machine, and one on the remote server.\nHowever Alice and Bob, do not work directly on this branch. Instead, each of them works on his/her own development branch (e.g. called alice and bob respectively).\nBackup # Alice regularly pushes the content of the branch alice to the remote server, for backup purposes only. And so does Bob for the branch bob.\nHowever, Alice does not need a local copy of bob, and Bob does not need a local copy of alice.\nSharing # Bob has been working on a new feature, on the branch bob. His code compiles and passes all unit tests. He now feels ready to share this code with Alice (via the branch main).\nHowever, Alice may have added commits to the main branch since Bob last looked at it.\nIn order to share his work, Bob:\nswitches to (his local copy of) main (with the git checkout command), then updates his local copy of main (with the git pull command), then merges main into bob (this may require fixing merge conflicts), then merges bob into main, then pushes main to the remote server. And Alice follows the same procedure to share her code (using alice instead of bob).\nTo go further # There is a vast literature (and diverging opinions) on collaborative git workflows. This is beyond the scope of this course.\nNote that many of these workflows incorporate so-called \u0026ldquo;pull requests\u0026rdquo;, which are a mechanism for to notify team members of your team that you have completed a feature. Pull requests are not a functionality of git itself, but of (some) git hosting services. To learn more about pull requests, you may consult the corresponding GitHub or Atlassian guides.\n"},{"id":13,"href":"/docs/objects/sections/classes/","title":"Class and instance","section":"Objects and classes","content":" Class and instance # A class can be viewed as a blueprint for a set of similar objects.\nFor instance, consider the two objects:\n{ name: \u0026#34;Florence\u0026#34;, zipCode: 50100, region: \u0026#34;Tuscany\u0026#34; } { name: \u0026#34;Rome\u0026#34;, zipCode: 00100, region: \u0026#34;Lazio\u0026#34; } Each of these objects describes a city, and they share the same keys (name, zipCode and region). A possible class for these two objects may enforce this structure, and it could be named City. An object that follows this blueprint is called an instance of this class.\nDeclaration # In a typed language (like Java), a class must specify not only the \u0026ldquo;keys\u0026rdquo; of its instances, but also their types. For instance, the class City could be declared as follows in Java:\npublic class City { String name; int zipCode; String region; ... } In Java, a class is often declared in a dedicated file. This file must have the same name as the class (e.g. City.java in this example).\nThe three variables (name, zipCode and region) are called attributes (or sometimes member variables).\nConstructor # A class also needs a special method called a constructor.\nThe constructor is in charge of creating a (fresh) instance of the class.\nNote. A class may have several constructors (with different signatures).\nWriting a constructor in Java # The constructor of a Java class must have the same name as the class.\nFor instance:\npublic class City { String name; int zipCode; String region; public City(String n, int z, String r){ name = n; zipCode = z; region = r; } ... } Note. In this example, the variable names n, z and r are not very explicit. However, using name, zipCode and region would be ambiguous (because these names are already used for the attributes of the class). In Java, we can use the prefix this. to refer to attribute names, thus eliminating the ambiguity.\nFor instance:\npublic class City { String name; int zipCode; String region; public City(String name, int zipCode, String region){ this.name = name; this.zipCode = zipCode; this.region = region; } ... } Calling a constructor in Java # A Java constructor is called with the keyword new. For instance:\nCity myCity = new City(\u0026#34;Florence\u0026#34;, 50100, \u0026#34;Tuscany\u0026#34;); City yourCity = new City(\u0026#34;Rome\u0026#34;, 00100, \u0026#34;Lazio\u0026#34;); Warning. In Java (as in Python, C#, etc.), the constructor does not return the instance itself, but a reference (sometimes called \u0026ldquo;pointer\u0026rdquo;) to this instance.\nNote. The object that is created in memory contains extra information, in particular a reference to its class. This allows type checking, casts, etc. (more on this later).\nDefault constructor # If a class has no explicit constructor, then a default constructor is generated by the compiler. This constructor has no argument.\nExample. The following class has no constructor:\npublic class GhostTown { String name; } But an instance can nonetheless be created with the default constructor:\nGhostTown anonymousCity = new GhostTown(); Accessing an object in Java # The attributes of an object can be accessed like regular variables, using ., followed by the name of the attribute. For instance,\nCity thatCity = new City(\u0026#34;Siena\u0026#34;, 53100, \u0026#34;Lazio\u0026#34;); System.out.println(\u0026#34;Wrong region: \u0026#34; + thatCity.region); thatCity.region = \u0026#34;Tuscany\u0026#34;; System.out.println(\u0026#34;Better now: \u0026#34; + thatCity.region); will output\nWrong region: Lazio Better now: Tuscany Reference type vs primitive type # Recall that a Java constructor returns a reference to the object that it creates. So in the examples above, the value of each variable (myCity, yourCity and thatCity) is a reference, not the object itself.\nThis also holds for variable with an array type (like int[] myArray).\nThe types of these variables (e.g. City or int[]) are called reference types.\nSyntax. In Java, types that start with a capital letter (like City or Set\u0026lt;Integer\u0026gt;) are usually reference types.\nTypes that are not references types (like int or char) are called primitive types.\nIn Java, the value of a reference cannot be output (printed, displayed, etc.) by a program (as opposed to C/C++ for instance). But this value can be overwritten or compared to another.\nExercise What is the output of the following program?\nCity aCity = new City(\u0026#34;Matera\u0026#34;, 75100, \u0026#34;Basilicata\u0026#34;); City theSameCity = new City(\u0026#34;Matera\u0026#34;, 75100, \u0026#34;Basilicata\u0026#34;); System.out.println(aCity == theSameCity); System.out.println(aCity.zipCode == theSameCity.zipCode); Solution false true Exercise What is the output of the following program?\nCity anotherCity = new City(\u0026#34;Bologna\u0026#34;, 40100, \u0026#34;Emilia-Romagna\u0026#34;); City yetAnotherCity = new City(\u0026#34;Mantua\u0026#34;, 46100, \u0026#34;Emilia-Romagna\u0026#34;); yetAnotherCity.name = anotherCity.name; System.out.println(yetAnotherCity.name); anotherCity = yetAnotherCity; System.out.println(anotherCity.zipCode); System.out.println(anotherCity == yetAnotherCity); Solution \u0026#34;Bologna\u0026#34; 46100 true Passing by value or by reference # Programming languages differ in the way arguments are passed to methods. Two common strategies are:\npassing by value: the method receives as input a copy of each argument, passing by reference: the method receives as input a reference to each argument (which allows the method to modify the initial argument). Consider for instance the following program (in pseudocode):\nint myInteger = 0 myMethod(myInteger) print(myInteger) void myMethod(int argument){ argument += 1 } If the argument is passed by value, then the program will print 0. If the argument is passed by reference, then the program will print 1. Java passes by value # In Java (and many other programming languages, like C, Python, Javascript, etc.), arguments are passed by value. So the above program translated in Java will print 0.\nWarning. Consider a method with a reference type argument. Because Java passes by value, this method will receive a copy of this argument. But this is a copy of the reference, not a copy of the object itself.\nExercise What does the following Java program print?\nint myInteger = 0; City myFirstCity = new City(\u0026#34;Florence\u0026#34;, 50100, \u0026#34;Tuscany\u0026#34;); City mySecondCity = new City(\u0026#34;Mantua\u0026#34;, 46100, \u0026#34;Emilia-Romagna\u0026#34;); myMethod(myInteger, myFirstCity, mySecondCity); System.out.println(myInteger); System.out.println(myFirstCity.zipCode); System.out.println(mySecondCity.zipCode); public void myMethod(int integer, City firstCity, City secondCity){ integer += 1; System.out.println(integer); firstCity.zipCode = 20590; System.out.println(firstCity.zipCode); secondCity = new City(\u0026#34;Rome\u0026#34;, 00100, \u0026#34;Lazio\u0026#34;); System.out.println(secondCity.zipCode); } Solution 1 20590 00100 0 20590 46100 "},{"id":14,"href":"/docs/errors/sections/exceptions/","title":"Exceptions","section":"Errors","content":" Exceptions # Programming languages may significantly differ in the way they support errors messages.\nJava relies on a mechanism called exceptions. Several other languages use exceptions, for instance C++, C#, PHP, Python or Ruby. However, the purpose of exceptions may vary from one language to another.\nAn exception is an object or data structure that stores information about an exceptional condition encountered during the execution of a program.\nin Java # In Java, an exception is an object, instance of the native class Exception.\nAll exception types (e.g. IOException) are subclasses of Exception.\nBy convention, a class name for an exception:\nends with the word Exception, and provides information about the cause of the exception. Stack trace # By default, when an exception is thrown, the program interrupts its execution, and the current call stack is sent to an output stream called System.error. This output is called the stack trace (because it allows tracing back the method calls that led to the exception being thrown).\nFor instance, consider the following class:\n1 2 3 4 5 6 public class MyClass{ void myMethod(){ Integer.parseInt(\u0026#34;clearlyNotANumber\u0026#34;); } } When myMethod is executed, the following stack trace is printed to System.error:\njava.lang.NumberFormatException: For input string: \u0026#34;clearlyNotANumber\u0026#34; at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67) at java.base/java.lang.Integer.parseInt(Integer.java:668) at java.base/java.lang.Integer.parseInt(Integer.java:786) at Myclass.myMethod(Myclass.java:4) \u0026lt;rest of the stack trace\u0026gt; The explanation is the following:\nmyMethod (Line 4) calls Integer.parseInt(String string), Integer.parseInt(String string) calls Integer.parseInt(String string, int radix) with the same string as argument, and a value of 10 for the radix (meaning that the string should represent an integer in base 10). Integer.parseInt(String string, int radix) throws an exception, because the string \u0026ldquo;clearlyNotANumber\u0026rdquo; does not represent a (base 10) number. Hint. Your IDE allows you to navigate through Java\u0026rsquo;s source code to trace the cause of an exception.\nHint. To debug your code, by default:\nfind the last method (from bottom to top) in the stack trace that was written by you (in this example Myclass.myMethod), using our IDE, create a breakpoint at the indicated line for this class (4 in this example), run your program in debug mode (e.g. clicking on the \u0026ldquo;bug\u0026rdquo; icon of your IDE). Throwing an exception # An exception can be thrown with the keyword throw, as follows:\nboolean isSolvable(int[][] sudokuGrid){ if(sudokuGrid.length != 9){ throw new IllegalArgumentException(\u0026#34;A sudoku grid should have 9 rows\u0026#34;); } if(sudokuGrid[0].length != 9){ throw new IllegalArgumentException(\u0026#34;A sudoku grid should have 9 columns\u0026#34;); } ... } Classes for native Java exceptions usually have several constructors, one of which takes a string as input. For instance, in the example above, we used the constructor IllegalArgumentException(String errorMessage).\nCatching an exception # When a runtime exception is thrown by a method, the method immediately below it in the call stack can either rethrow the exception, or catch it.\nIf some method in the call stack catches the exception, then the program is not interrupted. Instead, control is passed to the catching method.\nIn other words, when an exception is thrown, the JVM \u0026ldquo;pops\u0026rdquo; method calls from the call stack, until either:\na catching method is found, or the call stack is empty (in which case the program is interrupted). For instance, let us modify myMethod above so that:\nit takes as input a string (maybe supplied at run time), if this string can be converted to an integer, then it returns this integer, otherwise it returns 0. This can be achieved by catching the exception thrown by Integer.parseInt. Syntactically, this is done with a try/catch block, as follows:\nint myMethod(String inputString){ try { return Integer.parseInt(inputString); } catch (NumberFormatException e) { return 0; } } In this example:\nthe code inside the try block is always executed, the code inside the catch block is only executed if a NumberFormatException is thrown during the execution of the try block, the program is not interrupted. Chaining # The catch clause may itself throw an exception.\nThis is a very common pattern. In particular, it can be used to add information about the context in which an error occurred. In such a case, a common practice consists in chaining these two exceptions.\nMost native Java classes for exceptions have a dedicated constructor for this purpose: it takes as input a string (for the error message), and the exception that was caught. For instance, we can modify our example in such a way that if the input string cannot be converted to an integer, then the program gets interrupted, but with a less generic error message:\n1 2 3 4 5 6 7 8 9 10 public class MyClass{ int myMethod(String inputString){ try{ return Integer.parseInt(inputString); } catch (NumberFormatException e) { throw new IllegalArgumentException(\u0026#34;Please provide a valid number\u0026#34;, e); } } } Note in this example the second argument e of the constructor for IllegalArgumentException.\nIf the method is called as follows,\nmyMethod(\u0026#34;notANumberEither\u0026#34;); then the program will be interrupted, with the following stack trace:\nJava.lang.IllegalArgumentException: Please provide a valid number at MyClass.myMethod(MyClass.java:7) \u0026lt;rest of the stack trace\u0026gt; Caused by: java.lang.NumberFormatException: For input string: \u0026#34;notANumberEither\u0026#34; at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67) at java.base/java.lang.Integer.parseInt(Integer.java:668) at java.base/java.lang.Integer.parseInt(Integer.java:786) at MyClass.myMethod(MyClass.java:5) "},{"id":15,"href":"/docs/env/sections/files/","title":"Hierarchical file system","section":"Development environment","content":" Hierarchical file system # File name extension # File names often end with an extension, which provides information about the type of the file. For instance, the file name myDocument.pdf has .pdf as extension.\nExamples. Common file name extensions include:\n.pdf for a PDF file, .mp3 for an MP3 file, .java for a Java source file, .class for a compiled Java file. Warning. A file name extension is not mandatory, and has no incidence on the content of the file. For instance:\na text file myFile.txt can be renamed myFile.mp3 an still be opened with a text editor, a bash script myScript.sh and the same file without the .sh extension can be executed in the same way, a \u0026ldquo;README\u0026rdquo; file is a text file (written in Markdown), often used to describe the content of a git repository. It can be named either README.md or README. However, appropriate file extensions may be needed for some programs to behave as expected. For instance, an IDE or a code editor may use file extensions (like .java) to identify the programming language at hand.\nTree # Most operating system expose files as a (virtual) tree (or possibly several trees for Windows).\nA (nonempty) tree is either:\na single node (called a leaf), or a node with one or several children that are trees. In this tree, non-leaf nodes are directories, and the leaves can be files, links, empty directories, etc. For instance:\nâââ bin â âââ echo â âââ ... âââ home â âââ alice â â âââ .bashrc â â âââ .m2 â â â âââ ... â â âââ Desktop â â â âââ ... â â âââ music â â â âââ thatSong.mp3 â â âââ workspace â â âââ pp â â âââ assignments â â â âââ ... â â âââ project â â âââ .git â â â âââ ... â â âââ src â â â âââ HelloWorld.java â â âââ test â â âââ testHelloWorld.java â âââ bob â âââ .bashrc â âââ Desktop â â âââ ... â âââ music â âââ thatSong.mp3 â âââ anotherSong.mp3 âââ ... Terminology. In this course, we will use the terms \u0026ldquo;folder\u0026rdquo; and \u0026ldquo;directory\u0026rdquo; interchangeably.\nTerminology. \u0026ldquo;File\u0026rdquo; is sometimes used (e.g. in the Linux documentation) as a generic term for all nodes in this tree (in combination with \u0026ldquo;directory file\u0026rdquo;, \u0026ldquo;executable file\u0026rdquo;, \u0026ldquo;regular file\u0026rdquo;, etc.) We will not follow this terminology.\nWindows may expose several trees (e.g. one per physical device).\nPath # Definition. In such a tree, a path from a directory $s$ to an arbitrary node $t$ is either:\n. if $s$ and $t$ are the same node, or .. if $t$ is the parent of $s$, or the name of $t$ if $s$ is the parent of $t$, or a path from $s$ to some node $i$, followed by / (or \\on Windows), followed by a path from $i$ to $t$. For instance (on macOS, Linux, etc.), in the tree above:\nhome/alice/workspace/pp/project/src/HelloWorld.java is a path from the root to the file HelloWorld.java, workspace/pp/project/src/HelloWorld.java is a path from the directory alice to the file HelloWorld.java, ../../bob/Desktop is a path from Alice\u0026rsquo;s Desktop to Bob\u0026rsquo;s Desktop, ../../bob/../bob/./Desktop is another path from Alice\u0026rsquo;s Desktop to Bob\u0026rsquo;s Desktop. Exercise How many paths are there from a directory to a node?\nSolution (Countably) infinitely many.\nCase sensitivity # Warning. Some operating systems (Windows, macOS) use case-insensitive paths, whereas others (Linux, Android) use case-sensitive paths (this may also vary depending on physical storage devices).\nFor instance, on Windows, src/HelloWorld.java and src/helloworld.java are the same path.\nIn order to make sure that your code is portable:\nalways use case-sensitive paths in your code (i.e. respect the names of your files, folders, etc.), do not create two files (or subfolders, etc.) in the same folder with identical names modulo upper/lower case (e.g. Readme.md and README.md). Path separator # As mentioned above, Windows uses \\ as path separator, as opposed to the / used by other OSs (or in web URIs).\nWarning (for Windows). Some programs executed on Windows automatically convert the / path separator into a \\ (or the other way around).\nWarning (for Windows). In Java, a path can be safely written with /. At run time (i.e. when the program is executed), this symbol will be interpreted based on the underlying OS (i.e. as \\ on Windows, and as / on other OSs). However, a path written with \\ will be interpreted as such (therefore the program will throw an exception on OSs other than Windows).\nGood practices # Warning. The following are usually discouraged:\npath separators (/ or \\) in a file or folder name, whitespace characters in a file or folder name, . in a folder name. Your file browser and/or file system may let you to create such names. But these may cause some programs to fail.\nConvention # In what follows (unless explicitly stated), we will adopt by default the conventions for path names adopted on Linux. In particular, we will use / as a separator, and case-sensitive file and folder names.\nAbsolute path # Definition. An absolute path is a path prefixed with:\n/ on macOS, Linux, Android, IOs, etc. a capital letter followed by :\\ on Windows, where the letter identifies a physical device, disk partition, etc. In particular, the identifier of the main partition is often the letter C, in which case absolute paths (within this partition) are prefixed with C:\\. An absolute path is always a path from the root of the tree.\nFor instance (on macOS, Linux, etc.), /home/alice/workspace/pp/project/src/HelloWorld.java is an absolute path to the file HelloWorld.java\nA few simple observations:\ntwo different files may share the same name (but cannot share an absolute path), and two files with the same name may or may not be identical. E.g. in the above example, the two files named thatSong.mp3 may or may not be identical. Relative path # Definition. A relative path is a path that is not absolute.\nFor instance, ../../bob/Desktop is a path to Bob\u0026rsquo;s Desktop relative to Alice\u0026rsquo;s Desktop.\nNote that if p is a relative path, then p prefixed with ./ (or .\\ on Windows) is a path equivalent to p. This prefix is sometimes used to emphasize that a path is relative (among other purposes).\nExercise Complete the table below, based on the tree above.\nabsolute path to source directory $s$ absolute path to target $t$ possible path from $s$ to $t$ /home/alice/Desktop ../../bob/music/anotherSong.mp3 /home/alice/music ./../../../home/../home/alice/music /home/alice /home/alice/music/thatSong.mp3 /home/alice/music /home/bob/music/thatSong.mp3 project alice/../alice/.bashrc Solution absolute path to source directory $s$ absolute path to target $t$ possible path from $s$ to $t$ /home/alice/Desktop /home/bob/music/anotherSong.mp3 ../../bob/music/anotherSong.mp3 /home/alice/music /home/alice/music ./../../../home/../home/alice/music /home/alice /home/alice/music/thatSong.mp3 music/thatSong.mp3 /home/alice/music /home/bob/music/thatSong.mp3 ../../bob/music/thatSong.mp3 /home/alice/workspace/pp /home/alice/workspace/pp/project project /home /home/alice/.bashrc alice/../alice/.bashrc Working directory # Each process (e.g. a process that executes a Java program) has a working directory, which is a directory of the hierarchical file system. This directory may vary depending on the program and/or how it was started.\nMany programs (implicitly) interpret a relative path as relative to their working directory.\nIn particular, this is the case of:\nJava programs, file browsers, shells. Home directory # Each user of a system has its own home directory. E.g. in this example:\n/home/alice/ for Alice /home/bob/ for Bob Warning. The home directory is usually not the root of the tree (even if there is a single user on the machine).\nAbsolute paths to the home directory # The home directory (of a regular user) is normally:\n/home/\u0026lt;userId\u0026gt; on Linux/BSD, /Users/\u0026lt;userId\u0026gt; on macOS, /User/\u0026lt;userId\u0026gt; on iOS, /data/media/\u0026lt;userId\u0026gt; on Android, \u0026lt;mainHardDriveId\u0026gt;:\\Users\\\u0026lt;userId\u0026gt; on Windows (e.g. C:\\Users\\\u0026lt;userId\u0026gt;). On Linux and macOS, the alias ~ can be used as an absolute path to the current user\u0026rsquo;s home directory. For instance, in the above example, if Alice is logged in, then ~/music/thatSong.mp3 and /home/alice/music/thatSong.mp3 are two absolute paths to the same file.\nAccess restriction # Files and programs within the home directory of a user can usually be accessed by this user only (or a system admin). Therefore programs that can be executed by all users are usually located in other directories (e.g. the program /bin/echo in the example above).\nAccess restrictions (read, write and/or execute) may apply to the content of such directories. Notably, on Linux systems, (most of) the content of these directories can only be modified by a system admin.\nHidden files and directories # The home directory often contains files (resp. directories) whose names are preceded with a . (e.g. the file /home/alice/.bashrc in the above example). These are sometimes called \u0026ldquo;dot files\u0026rdquo; (resp. \u0026ldquo;dot folders\u0026rdquo;). On Linux and macOS, dot files and dot folder are hidden by default in a terminal or a file browser. On Windows, a (dot or not) file or folder can also be hidden, via a dedicated \u0026ldquo;hidden\u0026rdquo; attribute.\nHidden files and directories may be used to store (user-specific) parameters or options for a program. For instance, the configuration file ~/.gitconfig can be used to declare parameters (e.g. user identifier, etc.) or options (e.g. disable default fast-forward merge, etc.) to be used with git.\nHint. Configuration files are a convenient way to save your personal preferences and use them on several machines. For instance, you may need to connect to a remote server via ssh to perform some tasks (e.g. deploy a database or run costly computations). In such a scenario, you can upload dot files to your home directory on this server.\nHidden files or directories may serve other purposes. For instance, the dot folder ~/.m2 is used by Maven to store (in one place) the Java libraries that are required (as dependencies) by any Java project present in the home directory.\nHidden files or directories may also contain information specific to a subdirectory. For instance, every git repository (a.k.a. \u0026ldquo;project\u0026rdquo;) contains a dot folder .git that stores the full history of modification made to the repository.\nUsage and layout # Your home directory is where you generally want to store your projects, documents, scripts, etc.\nYou are free to structure it as you like (using sub-directories). Make sure that this structure allows you to retrieve your own work easily.\nWarning. When you download or create a project/document in your home directory, choose its location.\nDo not let an application decide this location for you. Do not rely exclusively on the \u0026ldquo;recently opened\u0026rdquo; feature of an app to locate your files. Do not store files and project directly at the root of your home directory. Warning. Aside from a few exceptional cases, your home directory should not contain multiple copies of a project or document.\nHint. It can be difficult for a new developer to figure out when to accept the default directory or layout suggested by a program, and when to overwrite it. As a (soft) rule of thumb, you generally want to choose the location of:\na file downloaded from your browser (or mail client), a project created with your IDE, a cloned git repository, a file created with an app, etc. Conversely, it is generally recommended to follow suggestions in the following cases:\ninternal structure of a project (typically the one generated by an IDE): e.g. the standard directory layout for a Maven project, or the standard directory structure of a Node JS project. software installed outside of your home directory, location of dot files and folders, etc. "},{"id":16,"href":"/docs/interfaces/sections/java_interfaces/","title":"Java interfaces","section":"Interfaces","content":" Java interfaces # A Java interface is a programming interface with additional (object-oriented) features.\nSyntactically, a Java interface is similar to a class. But (in its simplest form), it contains no code. Instead, it specifies the behavior of some methods (which are implemented in some classes).\nA Java interface can be used to specify how two components of a system communicate (before the interface is even implemented!).\nExamples # The implementation of our game contains an interface called DisplayManager. This interface specifies how the backend can share with the frontend information to be drawn on screen.\npublic interface DisplayManager { ... /** * Displays the input snapshot on screen, as well as the input message. */ void drawSnapshot(Snapshot snapshot, String message); ... } Note. This description contains no code.\nThe method above takes as argument an object of type Snapshot. A snapshot intuitively contains all the information needed by the fronted to draw the current state of the game on screen (board, active player, stats, etc.).\nSnapshot is itself an interface, which specifies (among others) a method called getSizeOfReinforcement, as follows:\npublic interface Snapshot { ... /** * Returns the number of units that will enter the board if reinforcement * is called for the input player. */ int getSizeOfReinforcement(Player player); ... } Note. The name of an interface can be used as a reference type (similarly to the name of a class). For instance, Snaphost is used above as the type of the first argument of the method drawSnapshot.\nA Java interface acts not only as documentation, but also as a contract : any (non-abstract) class that implements this interface must implement all methods declared in the interface (otherwise the program will not compile).\nSo a (non-abstract) class that implements the interface Snapshot must implement the method getSizeOfReinforcement (or inherit an implementation of this method).\nThe interface Snapshot specifies another method\nBoard getBoard(); which must return an object of type Board. And Board is itself an interface, which specifies the information needed to draw the game board (units, position, etc).\nHere is for instance a fragment of the Board interface:\n/** * Board for an ongoing game. * This is a two-dimensional grid. * * Tile coordinates are natural numbers and start at 0. * The top left tile has coordinates (0,0). */ public interface Board { ... /** * Return the maximum possible index for a column (a.k.a. number of columns -1) */ int getMaxColumnIndex(); /** * Returns the maximum possible index for a row (a.k.a. number of rows -1) */ int getMaxRowIndex(); /** * Returns the unit standing on the tile at the input coordinates, if any. * Throws an exception if the coordinates are out of this board\u0026#39;s boundaries. */ Optional\u0026lt;Unit\u0026gt; getUnit(int rowIndex, int columnIndex) throws CoordinatesOutOfBoardException; ... } Observe that these interfaces only specify what classes should implement, not how. In other words, these interfaces specifies communication between components, without exposing unnecessary implementation details.\nWhen to use a Java interface? # Technically, Java interfaces are not needed in a project. But they can make collaboration within a team of developers significantly easier. In particular:\nAn interface is a convenient way to expose what is needed to interact with your code, while hiding the details of your implementation. For instance, the method drawSnapshot (mentioned above) can be called to draw a snapshot on screen, without knowing how this method is implemented.\nAs a contract, an interface allows two programmers to work independently, ensuring interoperability between the methods and/or components that they are respectively developing.\nAn interface leaves room for alternative implementations to coexist, which share some functionalities. E.g.:\nalternative game modes in the example above, implementations that are specific to a specific hardware, operating system, \u0026hellip; implementations that offer different guarantees on performances (like the multiple implementations of Java\u0026rsquo;s Collection interface and subinterfaces). Inheritance # An interface in Java can extend another interface, like a class can extend another class, with the same keyword extends.\nHowever, Java interfaces support multiple inheritance (whereas Java classes do not). This means that an interface $A$ can extend two interfaces $B$ and $C$ even if $B$ and $C$ do not extend each other.\nImplementing an interface # In Java, the keyword implements is used to indicate that a class implements an interface. For instance:\npublic class SnapshotImpl implements Snapshot { ... } Note. It is good practice to avoid a class and an interface with the same name (even if they describe the same objects). To differentiate them, you may for instance use the suffix Impl, as illustrated above.\nConsider a class $C$ that implements an interface $I$ :\nif $C$ is abstract, then it can implement some of the methods declared in $I$, if $C$ is not abstract, then each method declared in $I$ must be implemented in $C$ (or some superclass of $C$), otherwise the program will not compile. Exercise The program represented by the following diagram does not compile. Can you see why?\nSolution The class Butterfly does not implement the method sleep.\nNote. In this example, the class Butterfly inherits an implementation of boost (from AbstractUnit), and overrides it. This is not an error.\nSince Java interfaces support multiple inheritance, a Java class can implement several interface that do not extend each other.\nFor instance, the class Unicorn could implement an interface Animal and another interface ImaginaryCreature, even though none of these two interfaces extends the other (not all animals are imaginary, and not all imaginary creatures are animals). This would be declared as follows:\npublic class Unicorn extends MobileUnit implements Animal, ImaginaryCreature { ... } Exercise The program represented by the following diagram does not compile. Can you see why?\nSolution The class Unicorn does not implement the method hide.\nInterfaces vs abstract classes # In theory, Java\u0026rsquo;s interfaces and abstract classes serve different purposes:\nabstract classes are meant to factorize code (i.e. avoid redundant code), whereas interfaces are meant to document code and act as a contract. However, in practice, they have partially overlapping features, which may be confusing.\nIn particular:\nan abstract class can have abstract methods, which behave similarly to interface methods (with the additional constraint that an abstract method must be implemented by at least one subclass). Since Java 8 (2014), interfaces can carry code, in so-called default methods. This feature was introduced for backward compatibility reasons, but arguably contradicts the meaning of the term \u0026ldquo;interface\u0026rdquo;. Note. A benefit of default methods (i.e. methods implemented in interfaces) is that they allow multiple inheritance of implemented methods (since interfaces allow multiple inheritance), which is not possible with classes. For this reason, some authors (like Joshua Bloch) recommend using interfaces with default methods to play the role of abstract classes. However, this may be confusing for less experienced Java developers.\nFor this course, we chose to present Java interfaces from a more traditional (pre-Java 8) perspective, because this is arguably easier to understand, and still the dominant usage of Java interfaces. However, for your project, feel free to deviate from this model if you think that this is appropriate (in particular if you need multiple inheritance).\n"},{"id":17,"href":"/docs/build/sections/layout/","title":"Layout","section":"Build automation","content":" Layout # The standard directory layout # By default, a Maven project is expected to comply with the so-called \u0026ldquo;standard directory layout\u0026rdquo;.\nWarning. We restrict here the layout to files and folders that you are likely to use in your project. A comprehensive description can be found here.\nâââ pom.xml âââ README.md âââ src â âââ main â â âââ java â â â âââ ... â â âââ resources â â âââ ... â âââ test â âââ java â â âââ ... â âââ resources â âââ ... ... Here is the intended purpose of these files and directories (all paths are from the root of the project):\nfile or directory content pom.xml Maven configuration for the project README or README.md (human readable) description of the project src/main/java source code of the project src/main/resources resources for the project (e.g. additional configuration files, images, etc.) src/test/java source code for unit tests src/test/resources resources for unit tests (e.g. data) Note. By default, the content of the src/main/resources directory is automatically included in a jar generated with Maven.\nHint. Your IDE can generate this folder structure (together with a minimal pom.xml file).\nFor instance, with IntelliJ, click on File/New/Project, and then select \u0026ldquo;Maven\u0026rdquo; as the \u0026ldquo;Build system\u0026rdquo;:\nHint. In some cases, a folder structure and pom.xml file that are tailored to a certain framework (like JavaFX or JSP) can be generated. This is called a maven archetype.\nThe target directory # When building a Maven project, some files and directories are generated.\nBy default, the directory called target (at the root of the project) contains the output of the build, in particular:\nthe bytecode (i.e. .class files), the generated .jar file(s), if any. Hint. Since it is automatically generated, the target directory can be safely deleted.\nMaven and Git # The pom.xml file should usually be committed.\nHowever, the following should not be committed (i.e. should be ignored via .gitignore):\nthe target directory, any other content generated during the build (e.g. generated source code, etc.). "},{"id":18,"href":"/docs/project/sections/board_game/","title":"Option 2: board game","section":"Project","content":" Option 2: board game # The second project option available to you consists in developing a video game with mechanics analogous to the ones of Might \u0026amp; Magic: Clash of Heroes or Legend of Solgard.\nStudents who choose this option you will be provided:\na basic graphical user interface (GUI) that they can reuse and/or customize, examples during lectures that they may adapt to their project. Requirements # The minimal requirement to submit this project is a player vs player game playable on a single machine.\nBut of course, you are free to go further and add your own features. Among other possibilities, you could for instance:\nimplement new mechanics (e.g. a rock-paper-scissor logic for unit encounters, events that may affect the board, etc.), make the game deterministic (i.e. eliminate randomness), create units with specific behaviors, implements scripted encounters (\u0026ldquo;boss fights\u0026rdquo;), implement a story, character progression, etc., develop a player vs bot mode, etc, Note. If you choose the last options in the list above (player vs bot), then you may benefit from an algorithm seen in the chapter on recursion. Besides, if several groups choose this option, we may organize a competition between bots (provided that they play by the same rules).\nGuidelines # GUI # The source code for the GUI can be cloned from GitHub. The project is designed so that:\nyou can develop a fully functional game (player vs player or player vs bot) by focusing exclusively on the backend (i.e. the mechanics of the game), without modifying the GUI. backend and frontend are decoupled. Communication between frontend and backend is specified via Java interfaces. It revolves around the notion of a game snapshot, which contains all the information needed to describe a state of the game (equivalently, you can think of a snapshot as a save state). In particular, snapshots are independent of a specific GUI.\nFor instance, a method is available that allows you to pass a snapshot to the GUI component. When you call this method, the snapshot will be drawn on screen, replacing the previous one (if any).\nAs input, your code receives the next action of the active player (for instance, delete the unit present on a specific tile). These are again specified by an interface, with 7 method that you need to implement. Your implementation should react to each action, i.e. modify the current snapshot, and then send it the GUI component for display.\nThe README.md file (at the root of the project) contains a description of the different components and interfaces, as well as building instructions, and explains where your code could fit. Read it carefully before you start working on your project!\nNote. You are of course free to modify the interfaces that come with the project. But this may require modifying the implementation of the GUI.\nDisclaimer. By design, the project compromises performance for simplicity and modularity. This is not how a resource-intensive game would be implemented.\nMore generally, this exercise is not meant to teach game development, but general-purpose programming and problem solving.\n"},{"id":19,"href":"/docs/project/","title":"Project","section":"Docs","content":" Project # Students enrolled in this course are expected to deliver a group project.\nTwo alternative options # Students can develop either:\nA project of their choice, or Their own version of the board game used as our running example. Groups who choose the second option (board game), will benefit from:\na graphical user interface (so that it is sufficient to implement the mechanics of the game), additional content provided during the lectures (as illustrations), which can be incorporated to the project. Requirements # Here are some requirements common to both options (free project or board game).\nSource code # The source code for the project must be written in Java 21 or lower.\nThe code should be original (or mostly original). If a project incorporates external code, it has to be referenced clearly in the README.md file of the project. If the project takes inspiration from a tutorial or the source code of another project, then this should be referenced as well.\nThe source code must be submitted as a GitHub repository. The commit history must reflect the individual contribution of each member of the group. For this reason:\neach student should use a different (and only one) GitHub account, and each student should commit his/her own code. The repository should contain at its root a .gitignore file hat indicates files that should not be tracked. In particular, a repository should not contain:\ncompiled classes, jars, logs, run-time files, IDE-generated files (e.g. .idea/), OS-generated files (e.g. .DS_Store), etc. Dependencies, build and packaging # Any additional Java library can be used in a project.\nThe project should be build with either Maven or Gradle. It should run on the evaluation environment via command line instructions.\nFor instance (depending on how the project is designed), the instructions to build the executable may be:\nmvn package and the instruction to run the executable may be (assuming that the executable is called myJar.jar and that the program takes two strings as input):\njava -jar myJar.jar \u0026lt;firstInput\u0026gt; \u0026lt;secondInput\u0026gt; If the executable cannot be built in the evaluation environment, then an Ã¼ber-jar should be provided that can run in this environment (via command line still).\nDocumentation # README # The git repository should contain at its root a README.md file (written in Markdown). This file should contain at least the following information:\nmembers of the group and their respective GitHub identifiers, clear instructions for building and running the project, a description of the project, a user\u0026rsquo;s guide for the project (either a written guide, or a link to a video), a brief overview of the implementation of the project. This should include information on: the different (high-level) components and interfaces between components, which third-party libraries were used (if any), and some programming techniques (seen in the course or not) that were particularly relevant for this project. a description of the human experience in this project. This should include information on: how the workload was distributed between the members of the project, how git was used, and challenges that each member faced (at least one per person). For further information about what a README.md file usually contains, one may look at this web page.\nThe README should not document the methods of your code (this documentation should be part of the code itself).\nCode documentation # No need to document every method of the project. It is sufficient to document (i.e. add a short specification to) the methods that your code exposes.\nThese are typically:\nmethods declared in a Java interface, methods written by one member of the group and called by another, methods that are written in a certain class or component (e.g. in the backend) and called in another (e.g. the fronted), and/or if your project is a Java library, methods that you want to make available to the user. These methods are usually public. The other methods are usually private or protected, and can remain undocumented.\nYou may also add comments to the more complex portions of your code, if the code is not self-explanatory.\n"},{"id":20,"href":"/docs/input/sections/read/","title":"Reading from and writing to a file in Java","section":"I/O and serialization","content":" Reading from and writing to a file in Java # There are numerous ways to read from or write to a file in Java, using either native of external libraries.\nWe highlight here some of the simplest ones (syntactically), even though they may not be the most efficient.\nWe also restrict our scope to:\nreading and writing text (but Java also offers multiple ways to read or write sequences of bytes), reading sequentially and writing by appending (but some classes like RandomAccessFile allow accessing any position in a file). Reading # Reading a text file line by line # Here is one way to process the content of a text file line by line:\ntry (BufferedReader reader = Files.newBufferedReader(Path.of(\u0026#34;path/to/file.txt\u0026#34;))){ String line = reader.readLine(); while (line != null){ System.out.println(line); line = reader.readLine(); } } catch (IOException e) { throw new RuntimeException(e); } Reading an entire text file # Alternatively, if the file is small, its whole content can be stored as a list of strings (one per line), as follows:\nList\u0026lt;String\u0026gt; lines; try (Stream\u0026lt;String\u0026gt; stream = Files.lines(Path.of(\u0026#34;path/to/file.txt\u0026#34;))){ lines = stream.toList(); } catch (IOException e) { throw new RuntimeException(e); } Or even as a single string:\nString text; try { text = Files.readString(Path.of(\u0026#34;path/to/file.txt\u0026#34;)); } catch (IOException e) { throw new RuntimeException(e); } Splitting # The method String.split can be used to decompose a string into an array of substring, based on some delimiter. For instance, in a csv file, each line can be decomposed using a comma (,), as follows:\nString line = \u0026#34;Alice,Bob,Carol\u0026#34;; // Contains [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Carol\u0026#34;] String[] names = line.split(\u0026#34;,\u0026#34;); Regular expressions allow you (among other things) to use more expressive delimiters. Regular expressions will be seen in another course of the bachelor (alternatively, you can look at last year\u0026rsquo;s course for an introduction).\nReading with a scanner # The class Scanner is a versatile tool that allows reading from the standard input, but also from a file.\nWe refer to the 22-23 course for an overview.\nWriting # Warning. In Java, methods that write an (underspecified) line separator produce a (sequence of) character(s) that depends on the operating system running the program: \\r\\n on Windows, and \\n on most other modern operating systems.\nThis is the case in all three examples below, with the methods BufferedWriter.newLine, PrintWriter.println and Files.write.\nWriting incrementally # A common way to write to a file consists in using a BufferredWriter. For instance:\ntry(BufferedWriter writer = Files.newBufferedWriter(Path.of(\u0026#34;path/to/file.txt\u0026#34;))){ writer.write(\u0026#34;Hi\u0026#34;); writer.newLine(); } catch (IOException e) { e.printStackTrace(); } A PrintWriter offers additional methods to easily format the output, such as print, println or printf, analogous to the methods of the standard output stream System.out. It is often used as a wrapper around another writer, for instance a BufferedWriter:\ntry(PrintWriter writer = new PrintWriter(Files.newBufferedWriter(Path.of(\u0026#34;path/to/file.txt\u0026#34;)))){ writer.println(\u0026#34;Hi\u0026#34;); } catch (IOException e) { e.printStackTrace(); } Writing an entire list # The method Files.write can be used to write all elements of a list to a file (one per line):\nList\u0026lt;String\u0026gt; strings = List.of(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;); try { Files.write( Path.of(\u0026#34;path/to/file.txt\u0026#34;), strings ); } catch (IOException e) { throw new RuntimeException(e); } Writing a single string # The method Files.writeString can be used to write a single string to a file\ntry { Files.writeString( Path.of(\u0026#34;path/to/file.txt\u0026#34;), \u0026#34;foo\u0026#34; ); } catch (IOException e) { throw new RuntimeException(e); } Note that this will overwrite the content of the file.\nInstead, in order to append a string to a file, a third argument can be added to the method Files.writeString:\ntry { Files.writeString( Path.of(\u0026#34;path/to/file.txt\u0026#34;), \u0026#34;foo\u0026#34;, StandardOpenOption.APPEND ); } catch (IOException e) { throw new RuntimeException(e); } "},{"id":21,"href":"/docs/abstractdatatypes/sections/set/","title":"Set","section":"Abstract data types","content":" Set # The abstract data type set simulates a (usually finite) mathematical set.\nA set may expose the following methods:\nadd: adds an element to the set if it was not present already (and returns true iff this was the case), contains: checks whether an element belongs to the set, size: returns the cardinality of the set, etc. Warning. A set provides no guarantee on the order of its elements!\nin Java # Java provides an interface Set with 8 native implementations (i.e. different classes that implement this interface). The most commonly used are HashSet and TreeSet.\nThe interface Set extends the interface Collection.\nSyntax # Here are code snippets for a few simple operations specified in the interface Set.\nCreate a Set and populate it: City milan = new City(\u0026#34;Milan\u0026#34;, 20100); City florence = new City(\u0026#34;Florence\u0026#34;, 50100); // Creates an empty set of cities Set\u0026lt;City\u0026gt; mySet = new HashSet\u0026lt;\u0026gt;(); // Adds Milan to the set mySet.add(milan); // Adds Florence to the set mySet.add(florence); // Tries to add Milan again; this has no effect. mySet.add(milan); // Creates a set identical to the previous one, // but which cannot be modified Set\u0026lt;City\u0026gt; myOtherSet = Set.of(milan, florence); Remove an element from a set: mySet.remove(milan); Check whether a set contains an certain element: // Outputs false System.out.println(mySet.contains(milan)); // Outputs true System.out.println(mySet.contains(florence)); Retrieve the cardinality of a set: // Outputs 1 System.out.println(mySet.size()); Compute the intersection of two sets: mySet.add(new City(\u0026#34;Bologna\u0026#34;, 40100)); mySet.retainAll(myOtherSet); // Outputs 1 System.out.println(mySet.size()); Add a collection to a set: mySet.addAll(myOtherSet); // Outputs 2 System.out.println(mySet.size()); For more operations, consult the Javadoc of the interface Set.\nDuplicates # By definition, a set cannot contain identical elements. But what does \u0026ldquo;identical\u0026rdquo; mean for two objects?\nIn Java, the method equals is (implicitly) used to determine whether two elements added to a Set should be considered identical.\nWarning. Recall that the method equals should be overridden together with the method hashCode (more on this later). This is essential for a HashSet to behave as expected (more on this later).\nFor instance, consider a naive implementation of the class City, which does not override equals (or hashCode):\npublic class City { String name; int zipcode; public City(String name, int zipCode){ this.name = name; this.zipCode =zipCode; } } Recall that every class inherits a default implementation of equals (and hashCode), from the class Object. According to this default implementation, equals behaves like ==.\nCity trento = new City(\u0026#34;Trento\u0026#34;, 38100); City trentoAgain = new City(\u0026#34;Trento\u0026#34;, 38100); Set\u0026lt;City\u0026gt; cities = Set.of(trento, trentoAgain); // Outputs 2 System.out.println(cities.size()); Now consider a class SmartCity identical to City, but that overrides equals (andhashCode) in the standard way:\npublic class SmartCity { String name; int zipCode; public SmartCity(String name, int zipCode) { this.name = name; this.zipCode = zipCode; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; SmartCity smartCity = (SmartCity) o; return zipCode == smartCity.zipCode \u0026amp;\u0026amp; name.equals(smartCity.name); } @Override public int hashCode() { return Objects.hash(name, zipCode); } } A Java Set cannot contain two instances of SmartCity that have the same name and zip code:\nSmartCity smartTrento = new SmartCity(\u0026#34;Trento\u0026#34;, 38100); SmartCity smartTrentoAgain = new SmartCity(\u0026#34;Trento\u0026#34;, 38100); Set\u0026lt;SmartCity\u0026gt; smartCities = new HashSet\u0026lt;\u0026gt;(); smartCities.add(smartTrento); smartCities.add(smartTrentoAgain); // Outputs 1 System.out.println(smartCities.size()); // Outputs false System.out.println(smartCities.add(smartTrentoAgain)); Note. Recall that many native Java classes already override equals (and hashCode). Among others: String, boxed types (like Integer), but also most implementations of the Collection interface (including HashSet).\nNote. Some implementations of List also provide methods that perform \u0026ldquo;set-like\u0026rdquo; comparisons. E.g. containsAll, removeAll, retainAll, etc. Again, we refer to the Javadoc for an exhaustive documentation.\nUsage # Implementations of the ADT set can be useful in a variety of contexts. For instance, remove duplicates from an array (assuming that the order of elements in the array is irrelevant):\nInteger[] myArray = new Integer[]{1,2,3,1,2}; List\u0026lt;Integer\u0026gt; tuple = List.of(myArray); Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(tuple); // Outputs 3 System.out.println(set.size()); Or check whether two lists contain the same (distinct) elements:\nSmartCity mantova = new SmartCity(\u0026#34;Mantua\u0026#34;, 46100); SmartCity bergamo = new SmartCity(\u0026#34;Bergamo\u0026#34;, 24100); List\u0026lt;SmartCity\u0026gt; list1 = List.of(mantova, bergamo); List\u0026lt;SmartCity\u0026gt; list2 = List.of(bergamo, mantova); Set\u0026lt;SmartCity\u0026gt; set1 = new HashSet\u0026lt;\u0026gt;(list1); Set\u0026lt;SmartCity\u0026gt; set2 = new HashSet\u0026lt;\u0026gt;(list2); // Outputs true System.out.println(set1.equals(set2)); Exercise In our game, a same unit may sit on two (or more) adjacent tiles.\nConsider an implementation where:\na board consists of a two-dimensional array with type Unit[][], and if a same unit sits on several tiles, then these tiles contain (a reference to) the same (instance of) Unit, and Unit does not override equals (neither do its sub or superclasses). Write a Java method int countUnits(Unit[][] board) that takes such an array as input, and returns the number of different units on the board.\nFor instance, with the board below as input, the method should return 5.\nPossible solution int countUnits(Unit[][] board) { Set\u0026lt;Unit\u0026gt; units = new HashSet\u0026lt;\u0026gt;(); for (Unit[] row : board) { for (Unit unit : row) { if (unit != null) { units.add(unit); } } } return units.size(); } Exercise What does the following program print?\nSet\u0026lt;Integer\u0026gt; aSet = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;Integer\u0026gt; anotherSet = new HashSet\u0026lt;\u0026gt;(); aSet.add(1); aSet.add(2); anotherSet.add(1); Set\u0026lt;Set\u0026lt;Integer\u0026gt;\u0026gt; aFamily = new HashSet\u0026lt;\u0026gt;(); aFamily.add(aSet); aFamily.add(anotherSet); System.out.println(aFamily.size()); anotherSet.add(2); System.out.println(aFamily.size()); Solution 2 and 2.\n"},{"id":22,"href":"/docs/background/sections/set_tuple_map/","title":"Set, tuple, function","section":"Background","content":" Set, tuple, function # Set # A set can be informally viewed as a collection of elements with no duplicate and in no specific order.\nDefinition. The power set $\\mathcal{P}(S)$ of a set $S$ is the set of all subsets of $S$.\nFor instance, if\n\\( \\qquad \\qquad S = \\{a,b\\}\\) , then\n\\( \\qquad \\qquad \\mathcal{P}(S) = \\Big\\{ \\{\\}, \\{a\\}, \\{b\\}, S \\Big\\} \\) Note. An alternative notation for the power set of $S$ is $2^S$.\nIf $S$ is finite with size $n$, then $\\mathcal{P}(S)$ has size $2^n$.\nDefinition. The product $S_1 \\times S_2$ of two sets $S_1$ and $S_2$ is the set of all pairs $(s_1, s_2)$ such that $s_1 \\in S_1$ and $s_2 \\in S_2$.\nFor instance, if\n\\( \\qquad \\qquad S_1 = \\{a,b\\} \\) and\n\\( \\qquad \\qquad S_2 = \\{1,2,3\\} \\) , then\n\\(\\qquad \\qquad S_1 \\times S_2 = \\{ \\ (a,1), (a,2), (a,3), (b,1), (b,2), (b,3)\\ \\} \\) Notation. Similarly to $S_1 \\times S_2$:\n$S_1 \\times S_2 \\times S_3$ denotes the set of all triples $(s_1, s_2, s_3)$ such that $s_1 \\in S_1, s_2 \\in S_2$ and $s_3 \\in S_3$. $S_1 \\times .. \\times S_k$ denotes the set of all tuples $(s_1, .., s_k)$ such that $s_1 \\in S_1, .., s_k \\in S_k$. Notation.\n$S^2$ is sometimes used for $S \\times S$, $S^3$ is sometimes used for $S \\times S \\times S$, etc. Tuple # Definition. A tuple (or list) over a set $S$ is a finite sequence of (possibly repeated) element of $S$.\nFor instance:\n-$\\ ()$ is the 0-tuple or empty tuple,\n-$\\ (a)$ is a 1-tuple,\n-$\\ (b,a)$ is a 2-tuple or pair,\n-$\\ (a,b,a)$ is a 3-tuple or triple, etc.\nFunction # A function (or map) $f\\colon X \\to Y$ maps each element $x$ of its domain $X$ to an element $f(x)$ of its codomain $Y$.\nDefinition. A function $f\\colon X \\to Y$ is:\ninjective is no two elements in its domain have the same image, i.e. if for all $ x_1, x_2 \\in X$, $\\qquad \\qquad x_1 \\neq x_2$ implies $f(x_1) \\neq f(x_2)$\nsurjective if every element in its codomain has a preimage, i.e. if $\\qquad \\qquad$ for each $y \\in Y$, there is a $x \\in X$ such that $y = f(x)$.\nbijective if it is injective and surjective. A function $f\\colon X \\to Y$ can equivalently be viewed as a set of \u0026ldquo;key-value\u0026rdquo; pairs, namely the set of all pairs $(x, f(x))$ such that$ x \\in X$.\nIf $f$ has finite domain, then it can be (physically) represented as this set of pairs. For instance, the function\n\\( \\qquad \\qquad f\\colon \\{a,b,c\\} \\to \\mathbb{N} \\) defined by\n\\( \\qquad \\qquad f(a) = 1,\\ f(b) = 1\\) and \\(f(c) = 2\\) can be represented as the set:\n\\( \\qquad \\qquad \\{\\ (a, 1),\\ (b, 1),\\ (c,2)\\ \\} \\) We may also use the symbol $\\mapsto$ to represent these pairs. For instance, we may represent the above function as\n\\( \\qquad \\qquad \\{\\ a \\mapsto 1,\\ b \\mapsto 1,\\ c \\mapsto 2\\ \\} \\) Multiset # A multiset (or bag) is a finite collection of elements in no specific order, possibly with duplicates.\nSquare bracket are sometimes uses to distinguish a multiset from a set or a tuple. For instance:\n\\( \\qquad [b,b,c] \\) and\n\\( \\qquad [a,b] \\) are multisets (the latter is also a set).\nBesides,\n\\( \\qquad [a,b,a] \\) and\n\\( \\qquad [b,a,a] \\) denote the same multiset.\nExercise A multiset can equivalently be viewed as one of the mathematical objects seen above. Can you identify which one?\n"},{"id":23,"href":"/docs/labs/env/sections/auto_comp/","title":"Shell autocompletion","section":"First lab","content":" Shell autocompletion # For comfort, your shell should allow you to autocomplete commands, in (at least) two ways: Tab-completion and history-based completion.\nTab completion # This feature suggests \u0026ldquo;smart\u0026rdquo; completions of the current command, like possible arguments, options, paths, etc.\nExample. On most operating systems, the command cd (like \u0026ldquo;Change Directory\u0026rdquo;) allows you to change the current directory. E.g.:\ncd workspace allows you to navigate (from the current folder) to the subfolder called workspace (if it exists).\nYou can use an arbitrary path as argument of the cd command. For instance:\ncd ../myCourses/pp/assignments or on Windows (with backslashes):\ncd ..\\myCourses\\pp\\assignments For the command cd, Tab-completion suggests possible paths. For instance:\ntyping cd followed by a whitespace and pressing the \u0026lsquo;Tab\u0026rsquo; key will suggest the directories contained in the current folder (if any), typing cd ../ (or cd ..\\ on Windows) and pressing the Tab key will suggest the directories contained in the parent folder (including the current folder), typing cd wor and pressing the Tab key will suggest the directories contained in the current folder and whose name starts with wor (if any). History-based completion # This feature suggests completions of the current command based on the user\u0026rsquo;s command history. The default key used for history-based completion may vary, depending on the shell: up and down arrow keys for zsh (Linux/macOS), right arrow for the Windows PowerShell.\nExample. The command\njava -version displays the version of the default Java Runtime Environment (JRE) and Java Development Kit (JDK) on your machine (if any).\nIf you want to execute this command again, you may type\nja and then the history completion key.\nThis will suggest you the latest command that you typed and started with ja. If you press the key again, then the previous of these commands will be suggested, etc.\nActivation # Windows # Tab-completion # The Windows PowerShell should now have Tab completion activated by default. If this is not the case on your machine, you may activate it by editing your Powershell profile, as explained here.\nHistory-based completion # History-based completion may also be activated by default (this feature is called \u0026ldquo;Predictive IntelliSense\u0026rdquo;), but only since 2023, and under certain conditions.\nIf Predictive IntelliSense it is not activated on your machine, then you may need to install a more recent version of the module called \u0026ldquo;PSReadLine\u0026rdquo;, following these instructions.\nWarning. You may get an error message when trying to install or upgrade this module. Read it carefully and follow the instructions. These may suggest you to:\nopen the Microsoft PowerShell with administrator rights (select \u0026ldquo;Run as administrator\u0026rdquo; when launching the Microsoft PowerShell), or add a flag to your command: either install for the current user only, or force installation for all users. Linux and macOS # On most Linux distributions, the default terminal shell is bash, which is not very customizable. Instead, you can install zsh, which is a modern take on bash.\nOn macOS, zsh is already the default shell, so you can skip the next step and install oh-my-zsh.\nMake zsh your default shell (Linux only) # Use your package manager to install zsh. For instance, on Debian-based distributions (like Ubuntu, Mint, etc.), your package manager is apt, so you can install zsh with:\nsudo apt-install zsh Then to use zsh, execute:\nzsh If this is the first time, then follow the configuration instructions.\nTo make zsh your default shell, execute:\nchsh -s $(which zsh) You will need to logout and login once for this latter change to take effect.\nInstall oh-my-zsh # Oh-my-zsh is a collection of plugins for zsh that enhances the default experience (autocompletion, colors, etc.). To install oh-my-zsh, you can execute the following command:\nsh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; and follow the instructions.\n"},{"id":24,"href":"/docs/intro/sections/lecturers/","title":"Teaching staff","section":"This course","content":" Teaching staff # Julien Corman will teach the lectures and one lab.\nJamila Oukharijane will teach the other lab.\nOffice hours # If you need additional help with the content of the course, the assignments and/or your project, you can ask for office hours with any (or both) of us.\nThese appointments must be scheduled via email (follow the links above for our email addresses) or Teams.\n"},{"id":25,"href":"/docs/abstractdatatypes/sections/map/","title":"Associative array","section":"Abstract data types","content":" Associative array # An associative array (or dictionary or map) simulates a function with finite domain.\nA associative array exposes at least the following methods:\nlookup (or get) takes a key as input, and returns the value for this key (if any). insert (or put) inserts a pair (key, value). If an entry for this key was already present, then overwrites its value. remove (or delete) deletes the entry for a given key (if any). Note. Associative arrays are pervasive in programming. Many data structures have been designed over the years whose main purpose is to implement associative arrays efficiently (notably hash maps and a variety of search trees).\nin Java # Java provides an interface Map with 19 native implementations (i.e. 19 different classes that implement this interface). The most commonly used is HashMap.\nNote. The interface Map does not extend the interface Collection.\nMap is a parameterized type with two parameters: one for the type of its keys, and one for the type of its values. For instance, a map from integers to strings has type Map\u0026lt;Integer, String\u0026gt;.\nSyntax # Here are code snippets for a few operations specified in the interface Map.\nCreate a Map and populate it: City milan = new City(\u0026#34;Milan\u0026#34;, 20100); City florence = new City(\u0026#34;Florence\u0026#34;, 50100); // Create an empty map whose keys are zipCodes, // and whose values are cities Map\u0026lt;Integer, City\u0026gt; zipCodeToCity = new HashMap\u0026lt;\u0026gt;(); // Adds { 20100 â¦ milan } to the map zipCodeToCity.put(milan.zipCode, milan); // Adds { 50100 â¦ florence } to the map zipCodeToCity.put(florence.zipCode, florence); // Creates a map identical to the previous one, // but which cannot be modified Map\u0026lt;Integer, City\u0026gt; anotherMap = Map.of( milan.zipCode, milan, florence.zipCode, florence ); Retrieve the value associated to a given key: // Contains (a reference to) Milan City aCity = zipCodeToCity.get(20100); // Has value null City anotherCity = zipCodeToCity.get(88888); Check whether a map contains an entry for a given key: // Outputs true System.out.println(zipCodeToCity.containsKey(20100)); // Outputs false System.out.println(zipCodeToCity.containsKey(88888)); Retrieve the number of entries in a map: // Outputs 2 System.out.println(zipCodeToCity.size()); Overwrite an entry in a map: City bologna = new City(\u0026#34;Bologna\u0026#34;, 40100); // Replaces { 20100 â¦ milan } with { 20100 â¦ bologna } zipCodeToCity.put(20100, bologna); // Outputs 2 System.out.println(zipCodeToCity.size()); // Adds { 40100 â¦ bologna } to the map zipCodeToCity.put(bologna.zipCode, bologna); // Outputs 3 System.out.println(zipCodeToCity.size()); // Replaces { 20100 â¦ bologna } with { 20100 â¦ milan } zipCodeToCity.put(milan.zipCode, milan); Retrieve the set of keys of a map (note that this is an instance of Set\u0026lt;E\u0026gt;, where E is the type of the keys) Set\u0026lt;Integer\u0026gt; keys = zipCodeToCity.keySet(); // Outputs true System.out.println(keys.contains(20100)); Retrieve a collection with all values in the map, in no specific order (may contain duplicates): Collection\u0026lt;City\u0026gt; values = zipCodeToCity.values(); // Outputs true System.out.println(values.contains(milan)); // Outputs 3 System.out.println(values.size()); // Adds { 99999 â¦ milan } to the map zipCodeToCity.put(99999, milan); // Outputs 4 System.out.println(zipCodeToCity.values().size()); Wrap the map into a set of entries (a.k.a. \u0026ldquo;key-value\u0026rdquo; pairs): // Creates a \u0026#34;wrapper\u0026#34; Set around the map. // No data is duplicated. // Each element of this set has type Entry\u0026lt;Integer,City\u0026gt; Set\u0026lt;Entry\u0026lt;Integer,City\u0026gt;\u0026gt; entries = zipCodeToCity.entrySet(); // Iterates over entries for (Entry\u0026lt;Integer, City\u0026gt; entry : entries){ // Holds the entry\u0026#39;s key Integer zipCode = entry.getKey(); // Holds the entry\u0026#39;s value City city = entry.getValue(); } Again, we refer to the Javadoc for an exhaustive documentation.\nComparing keys # The identity of two keys in Java is determined by the method equals, analogously to what we saw already for the identity of two elements in a set.\nFor instance, consider once again the classes City and SmartCity that we used in the section on sets, where SmartCity overrides equals (and hashCode), whereas City does not:\nCity trento = new City(\u0026#34;Trento\u0026#34;, 38100); City trentoAgain = new City(\u0026#34;Trento\u0026#34;, 38100); Country italy = new Country(\u0026#34;Italy\u0026#34;); Map\u0026lt;City, Country\u0026gt; cityToCountry = new HashMap(); cityToCountry.put(trento, italy); cityToCountry.put(trentoAgain, italy); // Outputs 2 System.out.println(cityToCountry.size()); SmartCity smartTrento = new SmartCity(\u0026#34;Trento\u0026#34;, 38100); SmartCity smartTrentoAgain = new SmartCity(\u0026#34;Trento\u0026#34;, 38100); Map\u0026lt;SmartCity, Country\u0026gt; smartCityToCountry = new HashMap(); smartCityToCountry.put(smartTrento, italy); smartCityToCountry.put(smartTrentoAgain, italy); // Outputs 1 System.out.println(smartCityToCountry.size()); Usage # Exercise Write a Java method int countRepeatedChars(char[] chars) that takes as input an array of characters, and returns the number of characters that appear at least $3$ times in this array.\nFor instance, for the input array [a,e,b,c,b,a,d,b], the method should return 1.\nPossible solution int countRepeatedChars(char[] chars) { // key: character // value: number of occurrences of this character Map\u0026lt;Character, Integer\u0026gt; charToOcc = computeCharToOccMap(chars); // return value int triplicatedChars = 0; // count the number of entries in the map with a value \u0026gt; 2 for (Integer occ : charToOcc.values()){ if(occ \u0026gt; 2){ triplicatedChars++; } } return triplicatedChars; } /** * Auxiliary method. * * Returns a map that associates each character to its number of occurrences */ private Map\u0026lt;Character, Integer\u0026gt; computeCharToOccMap(char[] chars) { // create an empty map Map\u0026lt;Character, Integer\u0026gt; charToOcc = new HashMap\u0026lt;\u0026gt;(); // for each character in the input array for (char character : chars) { // retrieve the number of occurrences seen so far for this character Integer occ = charToOcc.get(character); // increment this number by 1 occ = (occ == null) ? 1 : occ + 1; // update the map for this character charToOcc.put(character, occ); } return charToOcc; } Exercise Consider the implementation of our game that we used previously in our exercise with sets. Assume in addition that the class Unit has an attribute color of type String.\nWrite a (Java) method void printNumberOfUnitsByColor(Unit[][] board) that takes a board as input, and prints the number of unit of each color, in any order.\nFor instance, for the board below:\nThe method could print:\nblue: 1 yellow: 2 red: 2 Possible solution void printNumberOfUnitsByColor(Unit[][] board) { // key: a color // value: the set of all units with this color Map\u0026lt;String, Set\u0026lt;Unit\u0026gt;\u0026gt; colorToUnits = new HashMap\u0026lt;\u0026gt;(); for (Unit[] row : board) { for (Unit unit : row) { if (unit != null) { updateMap(unit, colorToUnits); } } } // for each entry in the map for (Entry\u0026lt;String, Set\u0026lt;Unit\u0026gt;\u0026gt; entry : colorToUnits.entrySet()) { // print the color and the number of units System.out.println( entry.getKey() + \u0026#34;: \u0026#34; + entry.getValue().size() ); } } /** * Auxiliary method */ private void updateMap(Unit unit, Map\u0026lt;String,Set\u0026lt;Unit\u0026gt;\u0026gt; colorToUnits){ // retrieve the set of units seen so for the color // of the current unit Set\u0026lt;Unit\u0026gt; units = colorToUnits.get(unit.color); if (units == null) { // if this is the first unit seen with this color, // then create an entry (in the map) for this color units = new HashSet\u0026lt;\u0026gt;(); colorToUnits.put(unit.color, units); } units.add(unit); } "},{"id":26,"href":"/docs/env/sections/backup/","title":"Backup","section":"Development environment","content":" Backup # Make sure that your work does not depend on your laptop. You should be able to resume your work easily on another computer if your laptop gets lost, damaged, etc.\nYou should also be able to recover your data if you accidentally delete it from your hard drive.\nWhich information to back up # With highest priority, make sure that there exist copies (outside of your hard drive) of:\nyour passwords (and possibly identifiers), and your own work (code, reports, slides, notes, etc.). These copies may be stored on the cloud, an external disk, another computer, etc.\nOptionally, you may also back up:\nconfiguration files present in your home folder. For development purposes, you generally do not need to back up:\ngenerated content (back up the code that generates it instead), large datasets (these should not be present on your laptop to start with), programs (they can be reinstalled). How to back up # Password managers # For passwords, your password manager may provide an online backup option. Other password managers (like pass) may let you synchronize your passwords via git.\nGit # For your own work and/or configuration files, git can be an option.\nA git repository is (roughly speaking) a directory that can be synchronized across different machines (see the dedicated chapter of this course for an introduction to git). For instance, you may create a (private) git repository for each course that you follow and/or each project that you start. Several providers (GitHub, Gitlab, Bitbucket, etc.) can host copies of your (public or private) repositories on the cloud for free.\nThe benefits are:\nthe possibility to recover any previous state of your work (a git repository stores the whole history of modifications made to it), fine-grained control over your backup: for instance, you can use a \u0026quot;.gitignore\u0026quot; file to exclude files or subfolder that do not need to be backed up. Note. If a git repository is a subfolder of another git repository, then the inner repository is not included in the history of the outer one.\nLimitation. Git is not suited to large volumes of data (more than 1 GB in the same repository). This is usually not an issue for your own work (code, notes, reports, etc.) as a student in computer science. However, git should not be used to back up large collections of images, audio files, videos, etc.\nOther solutions # Numerous programs allow you to back up (part of) the content of your hard drive. One of them may be pre-installed on your operating system.\nYou can back up content on a device that you own (e.g. on an external hard drive), or on the cloud. In the latter case, some fee may apply (depending on the volume of data).\nRestore points # Programs such as System restore (Windows), macOS Recovery (macOS) or Timeshift (Linux) allow you to create snapshots of your system (typically for what lives outside of your home folder), and revert your system\u0026rsquo;s state to one of these snapshots.\nThis can be useful in case of a corrupted system. However, it may be difficult to determine at which point in time the system was \u0026ldquo;healthy\u0026rdquo;. Note also that in such scenarios, a fresh re-install may be a simpler option to restart on a sane basis.\n"},{"id":27,"href":"/docs/git/sections/config/","title":"Configuration","section":"git","content":" Configuration # Text editor # In some situations (commit without message, merge commit, etc.), git automatically opens a text editor to let you type a message.\nBy default, on most operating systems, git open vi for this purpose. I you have never used vi, we recommend selecting another text editor.\nYou can do this by running:\ngit config --global core.editor \u0026lt;myEditor\u0026gt; where \u0026lt;myEditor\u0026gt; is the command that launches your text editor (for instance notepad for Notepad, open -e -W -n for TextEdit , gedit for gedit, sublime for Sublime Text, etc.)\nProtocol # Git hosting services (such as GitHub) usually support two alternative protocols for sharing content with a remote: https and ssh.\nssh is generally recommended.\nSSH key # To share content via ssh, you need a cryptographic key, often called an \u0026ldquo;ssh key\u0026rdquo; (in practice, this is an RSA key).\nYou may already have an ssh key on your machine. By default, ssh keys are located in the dot folder \u0026lt;homeFolder\u0026gt;/.ssh (or \u0026lt;homeFolder\u0026gt;\\.ssh on Windows).\nIf this folder exists, then it should contain (at least) one file with extension .pub. Such a file contains a public RSA key. You can share this key with a git host for authentication.\nIf you do not have an SSH key on your machine, then you can generate one by running\nssh-keygen in a terminal (Linux and macOS) or in the Windows Power Shell (Windows). If you accept the default location, this command will generate the .ssh folder and a key.\nIn order to add a public key to your GitHub account, log in to GitHub, select \u0026ldquo;Settings\u0026rdquo;, then \u0026ldquo;SSH and GPG keys\u0026rdquo;. Click on the \u0026ldquo;New SSH key\u0026rdquo; button, give a name to your key, and paste your public key (i.e.the content of the file with extension .pub) in the field \u0026ldquo;Key\u0026rdquo;.\nFor more details, you can for instance consult this page.\nHTTPS credentials # If you prefer, you can interact with (most) git hosting services via HTTPS. By default, this requires entering your credentials for each interaction with a remote.\nTo avoid this, you may consider caching your GitHub credentials in Git.\n"},{"id":28,"href":"/docs/build/sections/pom/","title":"Configuration file","section":"Build automation","content":" Configuration file # The Project Object Model (POM) # The root folder of a Maven project normally contains a configuration file called pom.xml. This file provides the information needed to identify and build the project.\nHint. Your IDE can generate the backbone of a pom.xml file (for instance, when creating a Maven project).\nFor a basic Java project, the pom.xml file usually has the following structure:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- Artifact coordinates for the project --\u0026gt; \u0026lt;groupId\u0026gt; XXX \u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt; XXX \u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt; XXX \u0026lt;/version\u0026gt; \u0026lt;!-- Properties of the project --\u0026gt; \u0026lt;properties\u0026gt; ... \u0026lt;/properties\u0026gt; \u0026lt;!-- Dependencies of the project --\u0026gt; \u0026lt;dependencies\u0026gt; ... \u0026lt;/dependencies\u0026gt; \u0026lt;!-- Project build specification --\u0026gt; \u0026lt;build\u0026gt; ... \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; For instance, here is the skeleton of a minimal pom.xml file for a Java 17 project:\n\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- Artifact coordinates for the project --\u0026gt; \u0026lt;groupId\u0026gt;it.unibz.pp-23-24\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;myProject\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- Version of Java and character encoding --\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!-- No dependency --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- No build specification --\u0026gt; \u0026lt;build\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; Parent POM, super POM, effective POM # A POM can inherit properties from a parent POM, via so-called project inheritance. In addition, every POM implicitly inherits from the so-called super POM.\nIn case of conflict, the values specified in the child POM have precedence over those specified in the parent POM (analogously to inheritance of attributes in Java).\nThe effective POM of a project is the one induced by the project\u0026rsquo;s POM and the properties that it inherits from other POMs.\nTo display the effective POM of a project, from the root of this project, run:\nmvn help:effective-pom Note. Inheritance of configuration (where a project-specific or user-specific configuration may partially overwrite a parent configuration) is not specific to Maven, but used by many programs.\n"},{"id":29,"href":"/docs/labs/env/sections/git_default_te/","title":"Default text editor for git","section":"First lab","content":" Default text editor for git # Some git commands open a text editor to let you type a message. By default, on most systems, this editor is vi, which is not friendly to new users.\nInstead, we recommend configuring git so that it opens your favorite text editor. The command is:\ngit config --global core.editor \u0026lt;myEditor\u0026gt; where \u0026lt;myEditor\u0026gt; is the command that launches your text editor. For instance:\nnotepad for Notepad++ (Windows), \u0026quot;open -e -W -n\u0026quot; for TextEdit (macOS), gedit for gedit, sublime for sublime text, etc. "},{"id":30,"href":"/docs/intro/sections/evaluation/","title":"Evaluation","section":"This course","content":" Evaluation # Evaluation for this course is based on:\nassignments: up to 30 points, a group project: up to 60 points, and an oral exam: up to 10 points. Your final grade is the sum of the above, multiplied by 0.3.\nAssignments # There will be 7 or 8 assignments for this course. These are standard programming exercises, related to notions seen during the lectures. The labs are (mostly) dedicated to these assignments.\nThe assignments are individual (do not submit the code of another student).\nThe release of each assignment is announced via Teams.\nAssignments are submitted via GitHub classroom. You can submit an assignment multiple times (but only before its deadline).\nNote. In order to submit your assignments (and your project), you will need a GitHub account. If you do not have one already, please create one and communicate it to the lecturer, preferably via Teams. Make sure that you use a single GitHub account for all your assignments and your project.\nGroup project # Guidelines for the content of the project are in the dedicated chapter. We focus here on organization and evaluation.\nEach group must consist of 3 to 4 students. Groups should be decided by March 20, and communicated via mail or Teams to the lecturer.\nProjects are delivered via GitHub.\nThe project\u0026rsquo;s code is expected to apply techniques seen during the lectures, but only if relevant. Please do not add artificial functionalities to your project for the sole purpose of illustrating a certain technique.\nGrades for a project are awarded individually, based on each student\u0026rsquo;s contribution. Students are expected to work on different computers. Make sure that:\neach student uses a different (and only one) GitHub account, and each student commits (via git) his/her own code. Among other evaluation criteria, we consider:\nquantity of work, non-trivial logic, appropriate data types and data structures, structure of the code (no code duplication, good usage of methods, classes, interfaces, inheritance, etc.) readability, documentation, naming, collaboration, integration with the rest of project, evidence of testing, etc. Oral exam # The oral exam is individual.\nNo revision is needed.\nWe will ask you questions about your code and/or involvement in the project.\nFor instance:\nwhich design choices you made, which difficulties you encountered, the expected behavior of a certain method, how some portions of the code may be improved, etc. In particular, we will check whether you have a good understanding of the code that you submitted. If not, then your mark for the project may be reevaluated.\n"},{"id":31,"href":"/docs/objects/sections/inheritance/","title":"Inheritance","section":"Objects and classes","content":" Inheritance # Subclass # In most (class-based) object-oriented languages, a class $A$ can extend another class $B$. In this case, $A$ is called a subclass of $B$.\nThe intuitive meaning is inclusion ($\\subseteq$) between their respective sets of instances, i.e. every instance of $A$ is also an instance of $B$ (but the converse may not hold).\nThis can be paraphrased in English by \u0026ldquo;every $A$ is a $B$\u0026rdquo;. For instance:\nevery banana is a fruit, every square is a rectangle, every rectangle is a polygon, etc. Exercise In each of the following cases, is $A$ a subclass of $B$ ?\n$A$ $B$ Student Vegetarian Polygon Hexagon Continent Country Country Continent City Country ZoomMeeting Meeting ZoomMeeting Calendar Chapter Book Minute TimeInterval Hour TimeInterval Minute Hour Integer RationalNumber RationalNumber RealNumber Integer RealNumber SetOfStudents Student Student SetOfStudents SetOfStudents Set SetOfStudents SetOfPeople ArrayOfIntegers ArrayOfRealNumbers ArrayOfIntegers SetOfIntegers UnionOfSets Set Set UnionOfSets Tree Graph Graph Tree AcyclicGraph Tree Object Class Subclass Class Class Subclass Solution A B Answer Student Vegetarian no Polygon Hexagon no Continent Country no Country Continent no City Country no ZoomMeeting Meeting yes ZoomMeeting Calendar no Chapter Book no Minute TimeInterval yes Hour TimeInterval yes Minute Hour no Integer RationalNumber yes RationalNumber RealNumber yes Integer RealNumber yes SetOfStudents Student no Student SetOfStudents no SetOfStudents Set yes SetOfStudents SetOfPeople yes ArrayOfIntegers ArrayOfRealNumbers yes ArrayOfIntegers SetOfIntegers no UnionOfSets Set yes Set UnionOfSets arguably (except maybe the emptyset?) Tree Graph arguably Graph Tree no AcyclicGraph Tree no Object Class no Subclass Class yes Class Subclass arguably (a class is a subclass of itself) Transitivity # If $A$ extends $B$ and $B$ extends $C$, then $A$ extends $C$\nExample. In the exercise above, Integer extends RationalNumber and RationalNumber extends RealNumber, therefore Integer extends RealNumber.\nAntisymmetry # If $A$ extends $B$ and $B$ extends $A$, then they are the same class.\nExample. In the exercise above, Set and UnionOfSets are (arguably) the same class.\nInheritance # Naturally, if $A$ extends $B$, then it inherits the properties of $B$.\nFor instance, a rectangle has four right angles. Since every square is a rectangle, a square has four right angles as well.\nFactorizing code with a (possibly abstract) superclass # Inheritance can be used to avoid redundant code.\nDirect inheritance: illustration # Let us model the units of our game as objects.\nEach unit has:\na type (e.g. mage, unicorn, etc.), a color (at least in the original game), and a certain amount of health. The behavior and stats of a unit (e.g. number of turns before attacking when combined, default health, etc.) are dictated by its type. So it makes sense to group units by type.\nFor instance, one can create a class Unicorn whose instances are all units of type unicorn. In Java:\npublic class Unicorn { String color; int health; int attackCountdown; public Unicorn(String color) { this.color = color; health = 1; attackCountdown = -1; } } Note. We used the keyword attackCountdown in this example to indicate the number of turns before the unit attacks (and a special value of -1 when it is not set to attack). But there are of course other ways to model this.\nNote. In this example, we used the prefix this. for the attribute color only, because there is no ambiguity for the two other attributes.\nWe can also create a class Butterfly on the same model\npublic class Butterfly { String color; int health; int attackCountdown; public Butterfly(String color) { this.color = color; health = 2; int attackCountdown = -1; } } Now consider a method encounter that manages an encounter between two units. Without inheritance, one would need to implement at least three versions of this method (possibly four if encounters are asymmetric):\nunicorn vs unicorn, unicorn vs butterfly and butterfly vs butterfly. For instance, the first of these three methods could be implemented as follows:\nvoid encounter(Unicorn u1, Unicorn u2) { // subtract the health of u2 from the health of u1 u1.health -= u2.health; // the health of u2 becomes the inverse of the remaining health of u1 u2.health = -u1.health; } More generally, if the game has $n$ types of units, then the code will contain $\\frac{n(n-1)}{2} + n$ nearly identical encounter methods.\nQuestion. Can we use inheritance in this example to avoid duplicate code (and how)?\nObserve that a unicorn and a butterfly (viewed as object) have identical attributes (a.k.a. \u0026ldquo;keys\u0026rdquo;), namely String color, int health, and int attackCountdown. So we can create a superclass of Unicorn and Butterfly that carries these attributes, and let the two subclasses inherit it. For instance, this superclass may be called Unit.\nWe may also want every unit in the game to have a concrete type (like \u0026ldquo;unicorn\u0026rdquo; or \u0026ldquo;butterfly\u0026rdquo;), rather than being a generic \u0026ldquo;unit\u0026rdquo;. In Java, this can be achieved with the abstract keyword. This keyword ensures that our superclass cannot be directly instantiated (even though it can still have a constructor). For instance:\npublic abstract class Unit { String color; int health; int attackCountdown; public Unit(String color, int health) { this.color = color; this.health = health; int attackCountdown = -1; } } Because this class is abstract, the following code will not compile:\nUnit myUnit = new Unit(\u0026#34;green\u0026#34;, 2); Next, we can declare that Unicorn extends Unit, by using the Java keyword extends. We can also use the constructor of Unit within the constructor of Unicorn, with the Java keyword super.\nThis yields:\npublic class Unicorn extends Unit { public Unicorn(String color) { super(color, 1); } } And we can proceed similarly for the class Butterfly:\npublic class Butterfly extends Unit { public Butterfly(String color) { super(color, 2); } } Note. In Java (as opposed to C++ for instance), a class can only have one immediate superclass, so the keyword super is never ambiguous.\nObserve that all the attributes are now carried by the superclass Unit. However, because they are inherited, these attributes can be accessed as if they were regular attributes of the subclass. For instance,\nUnicorn myUnit = new Unicorn(\u0026#34;green\u0026#34;); System.out.println(myUnit.health); outputs\n1 This allows us to write a generic encounter method, as follows:\nvoid encounter(Unit u1, Unit u2) { u1.health -= u2.health; u2.health = -u1.health; } And this method can be called with unicorns and/or butterflies as inputs. For instance:\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); Butterfly myButterfly = new Butterfly(\u0026#34;yellow\u0026#34;); encounter(myUnicorn, myButterfly); } Transitive inheritance # In the example above, we assumed that all units have a color and can attack. What if we also want to create a type of unit called Wall that has no color and cannot attack? An instance of this class does not need the attributes color and attackCountdown.\nA quick solution here consists is setting attackCountdown to -1, and color to null. However, unnecessary attributes make code harder to understand, and such a design may not scale well if the game is extended with more units types.\nExercise Modify our model to accommodate for the class Wall, so that an instance of Wall only has the health attribute, with (default) value 5.\nPossible solution One solution (among others) is the following:\nmodify the class Unit so that it only carries the attribute health, Wall extends Unit, create an (abstract) subclass of Unit (for instance MobileUnit) that carries the other two attributes, Butterfly and Unicorn extend MobileUnit (therefore they also extend Unit, by transitivity). Or in Java:\npublic abstract class Unit { int health; public Unit(int health) { this.health = health; } } public class Wall extends Unit { public Wall() { super(5); } } public abstract class MobileUnit extends Unit { String color; int attackCountdown; public MobileUnit(String color, int health) { super(health); this.color = color; this.attackCountdown = -1; } } public class Unicorn extends MobileUnit { public Unicorn(String color) { super(color, 1); } } and similarly for Butterfly.\n"},{"id":32,"href":"/docs/labs/env/sections/install/","title":"Installing software","section":"First lab","content":" Installing software # In order to install, update and remove programming-related software (compilers, interpreters, execution environment, libraries, build automation tools, git, maven, etc.), we highly recommend using a package manager. This is valid regardless of the programming languages that you use (Java, Javascript, Python, C/C++, etc.).\nLinux distributions already come with a package manager. So you can safely skip the next section if you use Linux.\nInstalling a package manager (Windows and macOS only) # Windows # To install Chocolatey:\nopen the Window PowerShell in admin mode (right click on the program\u0026rsquo;s name and select \u0026ldquo;Run as administrator\u0026rdquo;), copy-paste the command provided on this page (the one that starts with \u0026ldquo;Set-ExecutionPolicy\u0026hellip;\u0026rdquo;) and press Enter. macOS # To install Homebrew, execute\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; and follow (carefully) the instructions.\nTo check whether the installation was successful, type\nbrew --version Installing software with a package manager # Windows # With Chocolatey, to search for a program, type its name in the search bar on this page. Next to each result, you will find the command to install the corresponding package.\nFor this course, you will need git, Maven and Gradle. The respective commands are:\ninstall git: choco install git install Maven: choco install maven install Gradle: choco install gradle We assume that you already have a Java JDK installed. If not, then you can use:\nchoco install openjdk macOS # With Homebrew, to search for a program, type its name in the search bar on this page. If you find the program, then the resulting web page will provide the command to install the corresponding package.\nFor this course, you will need git, Maven and Gradle. The respective commands are:\ninstall git: brew install git install Maven: brew install maven install Gradle: brew install gradle We assume that you already have a Java JDK installed. If not, then you can use:\nbrew install openjdk@21 Linux # If you use Linux, you probably know how to use a package manager.\nFor this course, you will need to install git, Maven and Gradle. For instance, on Debian-based distributions (like Ubuntu, Mint, etc.), your package manager is apt, and the respective commands are:\ninstall git: sudo apt install git install Maven: sudo apt install maven install Gradle: sudo apt install gradle We assume that you already have a Java JDK installed. If not, then you can use (on Debian-based distributions still):\nsudo apt install openjdk-21 "},{"id":33,"href":"/docs/objects/","title":"Objects and classes","section":"Docs","content":" Objects and classes # This chapter introduces some basic notions of (class-based) object-oriented programming.\n"},{"id":34,"href":"/docs/labs/env/sections/ssh/","title":"Ssh key","section":"First lab","content":" ssh key # An ssh key allows you to connect to a remote machine via the ssh protocol. Among other uses, this is the preferred way to share data with a git hosting service (such as GitHub, Gitlab or Bitbucket).\nYou only need one ssh key per machine (laptop, desktop, phone, etc.). So from your laptop, you can use the same ssh key to connect to a server or interact with GitHub, Gitlab, etc.\nBy default, ssh keys are located in the directory \u0026lt;homeDir\u0026gt;/.ssh/ (or \u0026lt;homeDir\u0026gt;\\.ssh\\ on Windows) where \u0026lt;homeDir\u0026gt; is your home directory (i.e. the one with your user name).\nCheck whether there is already an ssh key on your machine # There may already be an ssh key on your machine. To check whether this is the case:\nverify whether the \u0026lt;homeDir\u0026gt;/.ssh/ already exists, if it exists, then open it and check whether it contains two files with the same name, one without extension, and one with the extension .pub. For instance, id_rsa and id_rsa.pub, or id_ed25519 and id_ed25519.pub. Warning. The .ssh directory is a hidden directory, so make sure that your file browser displays hidden files and directories. Alternatively, with a terminal you can list all files and directories in the current directory (including hidden ones) with:\nLinux and macOS: ls -a Windows: ls -force If these two files are already present, then you already have an ssh key, and you can skip the next step.\nCreate an ssh key (if there was none) # If the .ssh directory does not exist or does not contain an ssh key, then generate a key with:\nssh-keygen and follow the instructions (note that if you choose to enter a password, then you will have to type it each time you upload or download data to/from Github, Gitlab, etc.).\nShare your public key # If you followed the instructions above, you should now have an ssh key one your machine (whether it was already there or you just created it)\nYour ssh key consists of two files, with the same name (modulo the extension .pub):\nthe file with the .pub extension is your public key, the file without the .pub extension is your private key. In order to connect to/exchange with a remote machine via ssh, you need to share the public key: this is the content of the file with the pub extension.\nwith GitHub # This is how to share your public ssh key with GitHub (the procedure is similar for GitLab, etc.):\nlogin to GitHub, click on your user icon (top right), and select \u0026ldquo;Settings\u0026rdquo;, in the left menu, select \u0026ldquo;SSH and GPG keys\u0026rdquo;, click on the button \u0026ldquo;new ssh key\u0026rdquo;, give a name to your key (e.g. my_laptop) in the field \u0026ldquo;Title\u0026rdquo;, paste the content of the .pub file in the field \u0026ldquo;Key\u0026rdquo;, click on the \u0026ldquo;Add SSH key\u0026rdquo; button. "},{"id":35,"href":"/docs/build/sections/artifact/","title":"Artifact","section":"Build automation","content":" Artifact # A Maven artifact is the output of a build process. It can for instance be a jar.\nCoordinates # A Maven artifact is identified by so-called coordinates:\ngroupId: identifier of the organization that created the project (this is usually the organization\u0026rsquo;s reversed domain name), artifactId: identifier of the project within the group, version: version of the artifact. Examples.\n\u0026lt;groupId\u0026gt;com.google.guava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;guava\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;33.1.0-jre\u0026lt;/version\u0026gt; \u0026lt;groupId\u0026gt;com.github.haifengl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;smile-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; These coordinates are notably used to declare dependencies.\nVersions # SemVer # Maven artifact versions often follow (or loosely follow) the so-called semantic versioning scheme.\nMajorVersion.MinorVersion or\nMajorVersion.MinorVersion.Patch Example. According to the SemVer scheme, Version 3.4.1 means:\nmajor version: 3 minor version: 4 patch: 1 By convention:\na new major version often signals the absence of backward compatibility, a new minor version often signals (backward compatible) new features, a patch often signals bug (or security-related) fixes. Note. Java has only one major version. For instance \u0026ldquo;Java 17\u0026rdquo; actually refers to Java 1.17.\nSNAPSHOT # The SNAPSHOT qualifier (e.g. in Version 3.4.1-SNAPSHOT) indicates an upcoming release, still under development.\nThe SNAPSHOT qualifier is typically used to describe the (current state of) the source code of (a git branch of) a project (e.g. available as a public git repository). For instance, if the latest release of the project was 3.5.2, and if the developers are working on bug fixes, then the latest source code may have Version 3.5.3-SNAPSHOT.\nWarning. A program whose version number has the SNAPSHOT qualifier may be modified by it authors, while keeping the same version number. In other words, Version 3.4.1-SNAPSHOT downloaded today may differ from Version 3.4.1-SNAPSHOT downloaded tomorrow. So when releasing a project, it is recommended to avoid dependencies on SNAPSHOT versions.\n"},{"id":36,"href":"/docs/input/sections/property/","title":"Configuration files","section":"I/O and serialization","content":" Configuration files # It is common practice for an application to store parameters (e.g. user-specific settings) in configuration files.\nA configuration file may be edited manually and/or via a graphical interface.\nConfiguration files may use different serialization formats. Some popular formats are INI, JSON, TOML, YAML or XML.\nin Java # Java provides native support for at least two configuration file serialization formats: XML and the so-called \u0026ldquo;property file\u0026rdquo; format.\nWe introduce here the latter.\nA property file usually:\nhas extension .properties, may have commented line (starting with # or !), contains one key=value pair per (non-commented) line. Example. In our game, the file config.properties has two key=value pairs:\nanimationDuration=1 resolution=1920x1080 More details about the syntax of property files (escaped characters, spaces, etc.) can be found here.\nReading a property file # The content of a property file can be loaded in memory and modified as an associative array, instance of the class Properties (which implements the interface Map).\nFor instance, the content of a property file can be loaded as follows:\nProperties properties = new Properties(); try { properties.load(new FileInputStream(\u0026#34;path/to/config.properties\u0026#34;)); } catch (IOException e) { throw new RuntimeException(e); } Then a value can be read with the method getProperty (among other possibilities), as follows:\nString resolution = properties.getProperty(\u0026#34;resolution\u0026#34;); float duration = Float.parseFloat(properties.getProperty(\u0026#34;animationDuration\u0026#34;)); Writing to a property file # The content of a property file can be modified with the methods setProperty and store (among other possibilities), as follows:\nString path = \u0026#34;path/to/config.properties\u0026#34;; Properties properties = new Properties(); try { // load the file as an associative array properties.load(new FileInputStream(path)); // modify the associative array properties.setProperty(\u0026#34;animationDuration\u0026#34;, Float.toString(0.5f)); // replace the content of the property file with the // content of the associative array properties.store(new FileOutputStream(path)); } catch (IOException e) { throw new RuntimeException(e); } "},{"id":37,"href":"/docs/intro/sections/content/","title":"Content","section":"This course","content":" Content of the course # This is a beginner\u0026rsquo;s course on imperative and (class-based) object oriented programming, with an emphasis on practice and collaboration.\nWe will use Java as our main programming language. However, for a large part, the content of the course is not specific to Java (although the syntax may be). This content can be easily ported to other (imperative and/or object-oriented) programming languages: C/C++, C#, Javascript, Go, Kotlin, Lua, Perl, PHP, Python, Rust, Ruby, Typescript, Visual Basic, etc.\nPrerequisites # Students are expected to have completed the Computer Programming course (INF/01 76203).\nTherefore the following topics are not covered in this course:\nvariables, assignments, variable scope, basic data types (int, char, boolean, etc.). conditional statements (\u0026ldquo;if/then/else\u0026rdquo;) and loops, expression evaluation, methods/functions, arrays, etc. Students are also expected to have played the board game used as a running example throughout the lectures.\nOutcomes # After completing this course, students should be able to:\ndevelop a prototype application in Java, write structured, documented and easily maintainable code, collaborate with other developers. Focus # Foundations # Most lectures put an emphasis on problem solving, rather than providing (mechanical) recipes.\nBesides, the amount of Java syntax provided in this course is on purpose limited (but sufficient to solve the assignments). For conciseness, pseudocode may even be used in some sections, rather than Java code.\nSome lectures also focus on more abstract (albeit simple) notions. These includes elementary mathematical objects or structures: set, tuple, map, relation, preorder, graph, tree, etc.\nThe purpose is twofold:\ngeneralize techniques seen in this course to programming languages other than Java, provide a widely accepted vocabulary to document/explain your code. Collaboration # The course introduces basic coding practices to ease development within a team. In particular:\nstructuring a project (components, interfaces, encapsulation, inheritance, etc.), collaboration via git, test-driven development. Note. What is considered good communication in computer science may differ from other disciplines. Emphasis is put on clarity, precision and conciseness.\nExercise Here is a (caricature of) a poorly documented method. Can you improve the method\u0026rsquo;s description and/or signature?\n/** The algorithm looks at the first input collection, and is only guaranteed to * work if no number is present twice in this collection, in which case it * loops over the numbers contained in this collection (in no specific order) * and checks for each number whether it is also present in the second input * collection (which is also expected to have distinct numbers). The code * written in this loop adds the current number (from the first collection) * to the output collection if this number is also present in the second * collection, and does nothing with this number otherwise. */ Collection\u0026lt;Integer\u0026gt; filterNumbersThatAreShared(Collection\u0026lt;Integer\u0026gt; c1, Collection\u0026lt;Integer\u0026gt; c2); Solution A simpler signature and description could be:\n/** * Returns the intersection of sets s1 and s2. */ Set\u0026lt;Integer\u0026gt; intersection(Set\u0026lt;Integer\u0026gt; s1, Set\u0026lt;Integer\u0026gt; s2); The following topics are beyond the scope of this course:\ncontinuous integration, project management (agile methodology, bug tracking, etc.), advanced git workflows, advanced design patterns, dependency injection, etc. Quizzes # Some lectures will include quizzes. These are anonymous, and therefore are not part of your evaluation. The purpose is to:\nmake lectures more interactive, and adapt the pace of the lectures based on students\u0026rsquo; answers. Topics covered # Due to limited time, many notions (such as asymptotic cost, hash tables or multi-threading) are only briefly introduced in this course. However, some of them will be further discussed in other courses of the bachelor.\nProgramming techniques # An important part of the lectures is dedicated to the following core topics:\nobjects, classes and interfaces (inheritance, encapsulation, value vs reference, comparing objects, cloning objects, etc.), abstract data types (set, list, associative array, queue, etc.) and data structures (array, linked list, hash table, etc.), recursion. In addition, the following will be (briefly) introduced:\nmutability, pure functions, lambda expressions and streams, generics, multi-threading. Note. Some of these topics pertain to functional programming, but have been incorporated (in some form) to several imperative languages over the years.\nSoftware engineering # unit tests, exceptions, code factorization. Java # input/output, object serialization, JSON/XML serialization. Tools and tutorials # git, build automation (Maven and Gradle), using an IDE, using a terminal efficiently (introduction), etc. "},{"id":38,"href":"/docs/git/sections/create/","title":"Create or clone a repository","section":"git","content":" Create or clone a repository # From a remote server # The most common way to create a repository is to create the remote copy first, using the web interface of your host (Github, Gitlab, Bitbucket, etc.).\nYou will be asked to give the repository a name. Then you will be provided an address that allows use to clone the repository on your own machine (via ssh or https).\nTo do so, navigate on your machine to the folder where you want to clone the repository, and run\ngit clone \u0026lt;address\u0026gt; Note. After cloning a repository, you can verify that it contains a (hidden) subfolder called .git. Recall that this is what distinguishes a git repository from a regular folder.\nNote. You can safely move a cloned repository to another location on your machine (as long as it contains the .git subfolder).\nWith the same command, you can clone any public repository that you find online (e.g. hosted on GitHub).\nTo clone a specific branch, run\ngit clone -b \u0026lt;branchName\u0026gt; \u0026lt;address\u0026gt; Locally # Alternatively, you can create a git repository on your machine with the git init command. This may be convenient if you want to create a git repository from an existing (nonempty) folder.\nIf you create a git repository locally, then you will need to declare your remote(s) manually (with git remote).\n"},{"id":39,"href":"/docs/objects/sections/methods/","title":"Instance methods","section":"Objects and classes","content":" Instance methods # In many object-oriented languages (like Java), methods are implemented within class declarations.\nAn instance method is called using an instance of the class where the method is declared.\nFor instance, in Java, consider an instance method myMethod() declared in a class MyClass:\npublic class MyClass { ... public MyClass(){ ... } public void myMethod(){ ... } } This method can be called by appending . to a variable myVar of type MyClass, as follows:\nMyClass myVar = new MyClass(); myVar.myMethod(); The object referenced by the variable myVar is accessible from the method myMethod (even though it is not passed as argument to the method) (even though it is not passed as argument to the method).\nThis intuitively allows us to write methods with one less argument. For instance, consider the following method, which is not an instance method. It verifies whether two instance of MobileUnit have the same color:\npublic boolean sameColor(MobileUnit u1, MobileUnit u2){ return u1.color.equals(u2.color); } This method may be called as follows:\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); Butterfly myButterfly = new Butterfly(\u0026#34;green\u0026#34;); boolean sameColor = sameColor(myUnicorn, myButterfly); Instead, one may write an equivalent method, as an instance method of our class MobileUnit, with one less argument:\npublic abstract class MobileUnit extends Unit { String color; ... public boolean sameColorAs(MobileUnit otherUnit){ return color.equals(otherUnit.color); } } and we can call this method as follows:\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); Butterfly myButterfly = new Butterfly(\u0026#34;green\u0026#34;); boolean sameColor = myUnicorn.sameColorAs(myButterfly); } Overriding # A same instance method can be declared in a class $C$ and a subclass $S$ or $C$. In this case, we say that $S$ overrides the method (we also say that the method of $S$ overrides the method of $C$).\nWhen such a method is called, the most specific applicable version is executed.\nFor instance, let us extend our example from the previous section with an instance method regen, declared in both Unit and MobileUnit, as follows:\npublic abstract class Unit { int health; ... public void regen(){ if(health \u0026lt; 10){ health += 1; } } } public abstract class MobileUnit extends Unit { ... public void regen(){ if(health \u0026lt; 10){ health += 1; } health += 1; } } Now consider this program:\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); myUnicorn.regen(); This program increases the health of (the object referenced by) myUnicorn by 2, because Unicorn is a subclass of MobileUnit. However, the following program increases the health of (the object referenced by) myWall by 1, because Wall is a subclass of Unit, but not a subclass of MobileUnit.\nWall myWall = new Wall(); myWall.regen(); Hint. In Java, you can use the annotation @Override to indicate that a method overrides another, as follows:\npublic abstract class MobileUnit extends Unit { ... @Override public void regen(){ if(health \u0026lt; 10){ health += 1; } health += 1; } } This is not necessary. The benefit is that the program will not compile if the overridden and overriding methods have different signatures.\nMore generally, it is good practice to use features of a language that prevent compilation of incorrect programs. The reason is that syntactic mistakes (a.k.a. compile time errors) are easier to fix than bugs (a.k.a. runtime errors). This is why debugging in an untyped language (like Python, Javascript, Lua, etc.) can be more difficult than in a typed one (such as Java, C#, Typescript, etc.).\nDynamic dispatch (a.k.a. runtime polymorphism) # Dynamic dispatch consists in determining which version of a method must be called when a program is executed (a.k.a. \u0026ldquo;at run time\u0026rdquo;), when this cannot be determined by analyzing the program alone. This is a feature of most (class-based) object-oriented languages.\nFor instance, in our example, assume a method generateRandomUnits that generates a random array of units (butterflies, unicorns or walls). And let us call the method regen for each unit in this array:\nUnit[] ramdomUnits = generateRandomUnits(); for (Unit unit: randomUnits){ unit.regen(); } The most specific applicable version of the method regen will be executed for each unit, based on its type, even though this type cannot be determined at compile time. For instance, if there is an instance of Unicorn in this array, then the method MobileUnit.regen() will be executed for this instance (rather than the method Unit.regen()).\nNote that this also applies to scenarios where the type of a variable depends on the input of the program.\nCode factorization # An overriding method often extends the functionality of the overridden one. This is a possible source of duplicate code. For instance, in the example above, both implementations of regen() contain:\nif(health \u0026lt; 10){ health += 1; } A common way to factorize this consists in calling the overridden method inside the overriding one. In Java, the keyword super allows us to distinguish the two methods (since they have the same name). For instance, in the above example, the overriding method may be better written as follows:\npublic abstract class MobileUnit extends Unit { ... @Override public void regen() { super.regen(); health += 1; } } Exercise In this example, what would be the effect of replacing super.regen() with regen()?\nSolution The method would not terminate.\nExercise Consider the method encounter of the previous section. Add it as an instance method to our example, so that:\nthe method now distinguishes the attacker from the defender, a wall cannot attack, a unicorn gets a regen if it defends. Possible solution The trick here consists in viewing an encounter from the point of view of the defender:\npublic abstract class Unit { int health; ... public void defend(MobileUnit attacker) { // subtract the health of the attacker from the health of the current unit health -= attacker.health; // the health of the attacket becomes the inverse of the remaining health of the current unit attacker.health = -health; // some code that makes the encounter asymmetric (attacker and defender are treated differently) ... } } public class Unicorn extends Unit { ... @Override public void defend(MobileUnit attacker) { regen(); super.defend(attacker); } } "},{"id":40,"href":"/docs/interfaces/","title":"Interfaces","section":"Docs","content":" Interfaces # The term interface is used to refer to a variety of artifacts. For instance (in computer science alone): (graphical) user interface, command-line interface, Application Programming Interface (API), hardware interfaces, etc.\nWhat do these have in common?\nOne may think of an interface as a set of conventions adopted by two \u0026ldquo;agents\u0026rdquo; (human being, program, \u0026hellip;) to communicate. For instance:\nif Alice sends a message to Bob, then she has to use a language that Bob understands, if Alice uses git via command-line, then she has to use a command that git recognizes as a possible input, if a program calls git, then it also has to use a command that git recognizes as a possible input, etc. Warning. A program interface usually specifies communication in one direction only. So when two programs communicate, they may use different interfaces, one in each direction (a rough analogy could be communication between a human being and a dog).\n"},{"id":41,"href":"/docs/git/sections/navigate/","title":"Navigation, status and history: status, log, checkout, diff, show","section":"git","content":" Navigation and history # Status # Before performing any operation with git, it is common practice to execute\ngit status Among other things, this command will display:\nthe current position of the HEAD pointer, which files have been modified since the last commit, pending conflicts (if any), etc. You can also display the detail of all modification made since the last commit (on the current branch) with\ngit diff History # git log displays the history of the current branch, i.e. all its commits (with their ID, date, author and commit message).\nTo display the modifications made by a specific commit, run\ngit show \u0026lt;ID\u0026gt; where \u0026lt;ID\u0026gt; consists of the first digits of the commit ID.\nNavigation # The git checkout command moves the HEAD pointer. In particular\ngit checkout \u0026lt;myBranch\u0026gt; allows you to move the HEAD to a branch pointer, whereas\ngit checkout \u0026lt;ID\u0026gt; allows you to switch to an existing commit in a detached state (where \u0026lt;ID\u0026gt; consists of the first digits of the commit ID).\n"},{"id":42,"href":"/docs/background/sections/order/","title":"Relation, preorder","section":"Background","content":" Relation, preorder # Relation # Definition. A relation over a set $S$ is a set of tuples over $S$ with the same arity. In particular:\na binary relation over $S$ is a set of pairs, or equivalently a subset of $S \\times S$, a ternary relation over $S$ is a set of triples, or equivalently a subset of $S \\times S \\times S$, etc. For instance, if\n\\(S = \\{a,b,c,d\\}\\) , then \\(\\Big\\{ (a,a),\\ (a,b),\\ (b,a),\\ (b,c) \\Big\\}\\) is a binary relation over \\(S\\) , \\(\\Big\\{ (a,b,a),\\ (c,c,c) \\Big\\}\\) is a ternary relation over \\(S\\) . Exercise If $S$ is finite with size $n$, then how many $k$-ary relations are there over $S$?\nSolution A $k$-ary relation over $S$ is a subset of $S^k$.\nSo there are $2^{|S^k|} = 2^{n^k}$ $k$-ary relations over $S$.\nBinary relation # A binary relation can be represented in multiple ways.\nIn particular, it can be represented as a (directed) graph (and conversely).\nFor instance, the relation\n\\(\\Big\\{ (a,a),\\ (a,b),\\ (b,a),\\ (b,c) \\Big\\}\\) over\n\\(\\{a,b,c,d\\}\\) can be viewed as the graph:\nA binary relation can also be represented with an infix symbol.\nFor instance, the same relation\n\\(\\Big\\{ (a,a),\\ (a,b),\\ (b,a),\\ (b,c) \\Big\\}\\) can be represented as\n\\(a \\preceq a \\ \\) , \\(a \\preceq b\\ \\) , \\(b \\preceq a\\ \\) , \\(b \\preceq c\\ \\) . Reflexivity, transitivity, antisymmetry # Definition. A binary relation $\\preceq$ over a set $S$ is\nreflexive if $x \\preceq x$ for all $x \\in S$ transitive if for all $x, y, z \\in S$ $\\qquad \\qquad \\qquad x \\preceq y$ and $y \\preceq z$ imply $x \\preceq z$\nantisymmetric if for all $x, y \\in S$ $\\qquad \\qquad \\qquad x \\preceq y$ and $y \\preceq x$ imply $x = y$\nExercise Which of these three properties does the relation below satisfy?\nSolution Only reflexivity.\nPreorder, order # Definition. A binary relation is a preorder if it is reflexive and transitive. It is an order if it is also antisymmetric.\nTotal vs partial # Definition. A preorder $\\preceq$ over $S$ is total if every two elements of $S$ are comparable, i.e. if\n$ \\qquad \\qquad x \\preceq y$ or $y \\preceq x$ for all $x, y \\in S$.\nA preoder that is not total is called partial.\nExample. The natural order $\\le$ over $\\mathbb{R}$ is a total order (i.e. total, reflexive, transitive and antisymmetric).\nExample. If $S$ is a set, then the set inclusion relation $\\subseteq$ over the power set of $S$ is a partial order (i.e. reflexive, transitive and antisymmetric).\nWarning. The term \u0026ldquo;order\u0026rdquo; is often used to refer to a total order.\nSorting # If $S$ is a set, then a total preorder over $S$ is intuitively any relation that allows sorting $S$.\nExample. Let $P$ be the set of people, and let $\\preceq_{\\text{age}}$ be the relation defined over $P$ by\n$\\qquad \\qquad p_1 \\preceq_{\\text{age}} p_2$ iff $p_1$ is younger than (or as old as) $p_2$.\nThen $\\preceq_{\\text{age}}$ is a total preorder (i.e. total, reflexive and transitive), but it is not an order (i.e. not antisymmetric), because two persons can have the same age.\nLexicographic product # Notation. If $\\preceq_o$ is a preorder, let us use:\n$x \\prec_o y$ as a shortcut for ($ x \\preceq_o y$ and $ y \\not\\preceq_o x$ ), $x =_o y$ as a shortcut for ($x \\preceq_o y$ and $y \\preceq_o x$ ). Definition. The lexicographic product $\\preceq_{1,2}$ of a preorder $\\preceq_1$ by a preorder $\\preceq_2$ is defined by\n$\\qquad \\qquad x \\preceq_{1,2} y$ iff $x \\prec_1 y$ or ( $x =_1 y$ and $x \\preceq_2 y$ )\nExample. Let $P$ be the set of people, and let $\\preceq_{\\text{age}}$ and $\\preceq_{\\text{size}}$ be the total preorders defined over $S$ by\n$\\qquad \\qquad p_1 \\preceq_{\\text{age}} p_2$ iff $p_1$ is younger than (or as old as) $p_2$, and\n$\\qquad \\qquad p_1 \\preceq_{\\text{size}} p_2$ iff $p_1$ is smaller than (or as tall as) $p_2$.\nThen the lexicographic product $\\preceq_{\\text{age, size}}$ of $\\preceq_{\\text{age}}$ by $\\preceq_{\\text{size}}$ is defined by\n$\\qquad p_1 \\preceq_{\\text{age, size}} p_2$ iff\n$\\qquad \\qquad p_1$ is strictly younger than $p_2$, or\n$\\qquad \\qquad$ they have the same age and $p_1$ is smaller than (or as tall as) $p_2$.\nWarning. The lexicographic product of $\\preceq_1$ by $\\preceq_2$ may differ from the lexicographic product of $\\preceq_2$ by $\\preceq_1$.\nNote. The lexicographic product of a total preorder by a total preorder (resp. a total order) is itself a total preorder (resp. a total order).\n"},{"id":43,"href":"/docs/errors/sections/checked/","title":"Runtime vs checked","section":"Errors","content":" Runtine vs checked # Runtime exceptions # In Java, the simplest exceptions are the instances of the native class RuntimeException. These are also called unchecked exception.\nAn unchecked exception that is not caught is automatically rethrown.\nThe class RuntimeException has several native subclasses. You may be familiar wit some of them: NullPointerException, ArrayIndexOutOfBoundsException, IllegalArgumentException, etc.\nChecked exceptions # In Java, an Exception that is not a RuntimeException is called a checked exception.\nFor instance, an IOException is a checked exception.\nA checked exception is not rethrown by default. Instead, it must be explicitly rethrown (or caught), otherwise the program does not compile.\nFor instance, the following code does not compile, because the method of Files.readAllLines may throw an IOException.\nvoid someMethod(Path path) { Files.readAllLines(path); } Rethrow explicitly # This can be fixed by either catching the exception, or explicitly rethrowing it, as follows:\nvoid someMethod(Path path) throws IOException { Files.readAllLines(path); } Then a method that calls myMethod will in turn have to catch the exception, or rethrow it explicitly, etc.\nWarning. Checked exceptions add boilerplate code to method signatures (e.g. throws IOException in the above example). For this reason, it is often recommended to use unchecked exceptions (i.e. instances of RuntimeException) by default. In Effective java (Item 71), Joshua Bloch suggests checked exceptions only if some calling method is likely to catch the exception and take a meaningful action when this happens.\n"},{"id":44,"href":"/docs/env/sections/install/","title":"Software management","section":"Development environment","content":" Software management # Dependencies # As a developer, you frequently need to download, install and/or update:\nlibraries used in your projects, core programming utilities, such as a compiler or interpreter for a given programming language, a package manager, etc. tools for software development: editor, debugger, etc. These programs have their own dependencies, that have their own dependencies, etc. And two programs may depend on different versions of a same third program.\nDependency management is a frequent source of complications during software development. Dependency patterns that may occur include:\nco-dependencies:\nFor instance, consider the following configuration:\nProject $P$ depends on a certain version of Library $L_1$, $P$ also depends on Library $L_2$, which depends on an older version of $L_1$ (and the two versions are not compatible), The build of project $P$ may fail because it can contain only one version of $L_1$.\ncyclic dependencies:\nLibrary $L_1$ depends on a specific version of Library $L_2$, and\n$L_2$ depends on a specific version of $L_1$.\nUpgrading one of these two libraries independently may prevent the other one to run. But it may be possible to upgrade both at the same time.\netc.\nNote that in these two examples, dependencies may be direct or transitive. As a result, it can be very difficult to diagnose such problems.\nThe term dependency hell is sometimes used to refer to such situations.\nTwo (non-exclusive) broad approaches are commonly adopted to avoid such issues:\nautomated dependency management (using a package manager), and self-containment: avoid shared libraries, each program having a copy (some of) its own dependencies. Automated dependency management # Definitions # A package is a program together with some metadata. These metadata include the program\u0026rsquo;s name, version, release date, authors, licence and the names of its dependencies (together with their versions).\nA software repository is a collection of packages that comply to the same format of metadata. A software repository (precisely, multiple copies of it) is generally hosted on the cloud.\nA package manager automates the installation (as well as configuration, update and removal) of packages from a software repository (or several) to a user\u0026rsquo;s machine.\nExamples # An operating system (OS) may use a package manager and software repositories. Notably, this is the preferred way of installing software on most Linux distributions. Widely used OS package managers include:\napt for Debian and derivatives, dnf for Fedora and derivatives, pacman for Arch and derivatives, Homebrew for macOS, Chocolatey (since 2011) and Winget (since May 2021) for Windows. Many programming languages have dedicated package managers. For instance:\nMaven for Java, npm for Node.js (Javascript) pip for Python, NuGet for .NET (C#, F#, and Visual Basic) RubyGems for Ruby, CPAN for Perl CRAN for R, etc. Some applications also have dedicated software repositories for plugins (and plugin managers to handle these plugins). For instance.\nThe VSCode market place, CTAN for LateX, MELPA for Emacs, etc. Other applications (such as zsh, vim or neovim) only have plugin managers, without a centralized software repository. These managers install plugins directly from hosts (e.g. GitHub repositories).\nUsage # Installing, updating and removing software via a package manager is highly recommended in most scenarios. In particular:\ndependencies of a package are also installed (or it some cases updated or removed) transitively, some package managers can install and manage several versions of the same package (when needed), the installation process often uses a default configuration and directory layout (environment variables, etc.) that facilitates interaction with other programs. The installation (or update or removal) procedure is also significantly simpler, thus leaving less room for manual errors. As an illustration, here is the full procedure to install Maven with the apt package manager (on Debian and derivatives):\napt install maven and similarly with Homebrew (on macOS):\nbrew install maven or with Chocolatey (on Windows):\nchoco install maven In comparison, the procedure to install Maven manually on Windows is more involved, thus more likely to introduce errors (trough inadvertence, or by following outdated instructions).\nWarning (on Windows). The default and/or most frequent software installation instructions found on the web for Windows are typically manual. For most programming related software, we recommend instead looking for a corresponding package on Chocolatey (or Winget).\nAs a (rather extreme) example, compare installing MinGW (to get the GCC compiler) with:\nthis long procedure, or a simple command (with Chocolatey): choco install mingw However, in some (rare) scenarios, a manual installation may be preferred. In particular when the latest version of a program is needed, but not available yet on the software repository.\nSelf-containment # A variety of strategies can be adopted to build a program so that it runs in partial isolation from the rest of the system that it is deployed on (i.e. in its own environment, and with its own dependencies, that cannot be used by other programs).\nFor instance, a Node.js project often includes a copy of all the Javascript libraries that it depends on (transitively). Further self-containment strategies may involve different levels of virtualization (e.g. via Docker).\nThis is one way to avoid shared dependencies. Other benefits are increased portability, and ease of installation by end-users. Drawbacks include and increased workload on the developer\u0026rsquo;s side (e.g. for maintenance), and limited opportunities for integration with other programs.\nSelf-containment in Java # In Java, self-containment is usually less pronounced during development. Java libraries are typically managed via Maven:\non a per-user basis (which can be viewed as a compromise between per-project and system-wise): each user has a hidden folder \u0026lt;homeDir\u0026gt;/.m2/ that contains all Java libraries used in his/her projects, and allowing multiple versions of the same library to coexist. However, a Java application that targets non-developers can be released together with its Java dependencies, as a so-called Ã¼ber jar (a.k.a. fat jar).\n"},{"id":45,"href":"/docs/abstractdatatypes/sections/queue/","title":"Stack, queue, priority queue","section":"Abstract data types","content":" Stack, queue, priority queue # Some abstract data types impose strong limitations on the set of operations allowed on a collection. These limitations provide opportunities for specialized implementations (i.e. specialized data structures), which can be very efficient in some contexts.\nStack # A stack (or Last In First Out queue or LIFO queue) simulates a collection organized as a physical stack (for instance a stack of plates).\nA stack exposes three main methods:\npush adds an element to the collection, pop removes and returns the most recently added element, isEmpty is self-explanatory. Queue # A queue (or First In First Out queue or FIFO queue) simulates a collection organized as physical queue (for instance a waiting line).\nA queue exposes three main methods:\nenqueue (or add) adds an element to the end of the queue, dequeue (or poll) removes and returns the earliest enqueued element, isEmpty is self-explanatory. Priority queue # A priority queue simulates a collection equipped with a total preorder, so that only (one of) the element(s) with highest priority can be retrieved.\nA priority queue exposes three main methods:\ninsert adds an element to the collection, getMaximumElement removes and returns an element with highest priority, isEmpty is self-explanatory. Note. A regular queue can be viewed as a specific case of priority queue, where each inserted element has (strictly) lower priority than the previous one.\n"},{"id":46,"href":"/docs/abstractdatatypes/","title":"Abstract data types","section":"Docs","content":" Abstract data types # An abstract data type (ADT) is an interface to access and manipulate a collection of elements.\nFor instance, a queue is an ADT that mimics the behavior of a \u0026ldquo;first come first served\u0026rdquo; queue (e.g. a waiting line at a post office). This interface typically exposes three methods:\none that checks whether the queue is empty, one that takes as input an element and adds it to the end of the queue, one that removes the first element of the queue and returns it. An ADT may have several implementations. For instance, a queue may be implemented as an array or as a linked list (among others). Each implementation may have advantages and drawbacks (in terms of performance, memory footprint, parallelization opportunities, etc.) for different tasks (reading, writing, etc.).\nA data structure (e.g. an array, a linked list, a hash table, etc.) is not an ADT, but a (concrete) way to store a collection of elements (values, objects, etc.) in memory. A data structure can be used to implement one or several ADT(s).\nSome ADTs correspond to basic mathematical objects (set, tuple, function, etc.), and are therefore easy to understand and manipulate. They allow you to easily write code that is correct, but may be inefficient if you do not have a good understanding of underlying (concrete) data structure.\nAnother benefit of ADTs is that they can make your code significantly easier to read (thus requiring less documentation). For instance, if your program manipulates a collection of objects without duplicates and whose order is irrelevant, then you can simply use the Java interface Set, which is self-explanatory.\nin Java # Parameterized types # An ADT in Java is usually a parameterized type, meaning that it has one or several types as parameter(s).\nFor instance, a set of strings in Java has type Set\u0026lt;String\u0026gt;.\nNote. In Java, a primitive type (like int or bool) cannot be used as a type parameter, but a boxed type (like Integer or Boolean) can. For instance, the type Set\u0026lt;Integer\u0026gt; is valid.\nThe interface Collection # In Java, many ADTs and data structures extend or implement the interface Collection (the only exception in this chapter is Map).\nAmong others, the interface Collection specifies the following methods (if E is the type of the elements in the collection):\nint size() boolean add(E e) boolean contains(Object o) boolean isEmpty() boolean remove(E e), etc. Warning. Some of these methods are so-called \u0026ldquo;optional operations\u0026rdquo;, meaning that they may not be available for some implementations of Collection.\nLike an array, a collection can be iterated over, for instance with a \u0026ldquo;foreach\u0026rdquo;-like loop:\nfor (E element: myCollection){ ... } Another way to iterate over a collection consists in using an iterator.\nWarning. Some collections (e.g. some implementations of the subinterface Set) do not offer any guarantee on the order of their elements!\nExternal libraries # Some external libraries provide additional implementations of Java\u0026rsquo;s ADTs.\nFor instance, Java has 19 native implementations of the ADT Map (e.g. HashMap,TreeMap, etc.). But Guava provides additional ones, like ImmutableMap, HashBiMap, etc.\n"},{"id":47,"href":"/docs/git/sections/commit/","title":"Add, commit, stash","section":"git","content":" Add, commit, stash # Staging files # Git lets you to choose which modifications will be part of your next commit.\nFirst, run\ngit status This will show which files have been added or modified since the last commit on the current branch (if any). In order to add (some of) these files to the next commit, you need to stage them.\nIf you want to stage all these files, from the root of the repository, run\ngit add . Hint. You can create a .gitignore file to indicate files of folders that should never be staged.\nThis allows you to use git add . without staging by accident compiled files, IDE-generated files, etc.\nAlternatively, to stage a specific file (or the content of a specific folder, recursively) run\ngit add \u0026lt;relative/path/to/file\u0026gt; At any moment, you can check which files have been staged with\ngit status You can also unstage all staged files with\ngit reset . And unstage a single file with\ngit reset \u0026lt;relative/path/to/file\u0026gt; Commit # Once you have staged your file, you can commit with\ngit commit -m \u0026#34;\u0026lt;commit message\u0026gt;\u0026#34; If you do not add the -m \u0026quot;\u0026lt;myMessage\u0026gt;\u0026quot; option to your command, then git will open a text editor where you can type a commit message. If this happens, then type your commit message, save and close the file.\nWarning. By default, on most operating systems, git opens vi as a text editor. I you have never used vi, we recommend selecting another default text editor.\nStash # git stash temporarily reverts all modifications made to your repository since the last commit.\nTo apply them back, run\ngit stash pop "},{"id":48,"href":"/docs/intro/sections/board_game/","title":"Board game","section":"This course","content":" Board game # In order to follow this course, you will need to play one of the two following video games:\nMight \u0026amp; Magic: Clash of Heroes, or Legend of Solgard. These two games have nearly identical mechanics. So by default, we will refer to them as a unique game (e.g. when we write \u0026ldquo;this game\u0026rdquo; or \u0026ldquo;our board game\u0026rdquo;).\nWhy this game # Turn-based board games (like chess, go, checkers, etc.) are traditionally a good playground to learn the basics of algorithmic thinking.\nDisclaimer. The course is not about video game development, but general-purpose programming. This game is only used as didactic support.\nPrecisely, this game will serve two purposes:\nwe will use it as a running example throughout the lectures, and students can choose to implement (their own version of) this game as their group project. By default, we will focus on the two player variant, where both players play by the same rules. These two players may be humans and/or bots.\nHow long to play # Students only need to play long enough to understand the basic mechanics of the game.\n1.5 to 2 hours should be sufficient.\nWarning. In both games, mechanics are introduced gradually, so it is difficult to get a full overview by playing less than 1.5 hours.\nWhich game to choose # Might and Magic clash of heroes (MMCoH) # This game was initially released in 2009 for Nintendo DS. It has then been ported to PC and several consoles, as well as Android and iOS.\nA free demo was available on Steam until July 2023. The game has been re-released since, by another editor. As a side-effect, the demo is not available on Steam anymore.\nThe Android and iOS versions have also been removed from the Google Play store and App store respectively.\nAdvantages.\nThe mechanics of this game may be easier to understand (in a short amount of time). The default mode is the (symmetric) 2 player mode (player vs bot or player vs player) that we will work on. Drawbacks.\nThe touch-screen interface on Android and iOS is arguably dated. Legend of Solgard # This game was released in 2016 for Android and iOS. It is still available on the Google Play store and the App store.\nIt is free to play, with optional microtransactions (via so-called loot boxes).\nWarning. For this course, no transaction is needed.\nAdvantages.\nAnimations can be sped up. The touch-screen interface is more modern than the one of MMCoH for Android and iOS. Drawbacks.\nProgression is based on a (complex) system of virtual currencies, which adds noise to the interface. The game can only be played (for free) a limited amount of time per day (approximately 45 min). The default mode is not the (symmetric) 2 players mode that we will work on (it requires more playtime to be unlocked). So an extra effort of imagination may be needed. "},{"id":49,"href":"/docs/errors/sections/custom/","title":"Custom exceptions","section":"Errors","content":" Custom exception # Custom exceptions can be created by extending one of Java\u0026rsquo;s native exception types. For instance:\npublic class WrongNumberOfRowsException extends IllegalArgumentException { public WrongNumberOfRowsException(int numberOfRows) { super(\u0026#34;This sudoku grid has \u0026#34; + numberOfRows + \u0026#34; rows, whereas it should have 9\u0026#34;). } } A custom exception can be thrown like a regular one:\nif(sudokuGrid.length != 9){ throw new WrongNumberOfRowsException(sudokuGrid.length); } Observation. In this example, WrongNumberOfRowsException extends IllegalArgumentException, which extends RuntimeException. Recall that an instance of a subclass of RuntimeException is unchecked. Therefore an instance of WrongNumberOfRowsException is an unchecked exception.\n"},{"id":50,"href":"/docs/build/sections/dependencies/","title":"Dependencies","section":"Build automation","content":" Dependencies # Maven (like Gradle) acts both as a build automation tool and as a package manager.\nAs a package manager, Maven (like Gradle) relies by default a software repository called Maven Central. This repository contains more than 260.000 artifacts (more than 6 million when counting versions), with over a trillion downloads in 2023.\nAn artifact on Maven Central is identified by its coordinates.\nFinding a library\u0026rsquo;s coordinates # The coordinates of a library are often provided as part of its documentation. For instance, this is the case of Google\u0026rsquo;s Guava library.\nAlternatively, this website can be used to search for the coordinates of an artifact on Maven Central (as well as 1990 other repositories). For instance, here are the coordinates for the latest version of the Smile library for machine learning.\nLocal repository # By default, Maven caches project dependencies (as jars) in a hidden directory with path \u0026lt;homeFolder\u0026gt;/.m2 (or \u0026lt;homeFolder\u0026gt;\\.m2 on Windows). In Maven\u0026rsquo;s terminology:\nthis directory is called the local repository, an artifact is installed when it is added the local repository. When a project is build, Maven searches for each dependency in the local repository. If the corresponding artifact is not installed, then it is downloaded (e.g. from Maven central) and installed.\nGradle proceeds in a similar way (but the cache is under \u0026lt;homeFolder\u0026gt;/.gradle).\nNote. The local repository can contain different versions of the same artifact.\nNote. By default, when installing an artifact, Maven also installs all its missing dependencies, transitively. Gradle proceeds in a similar way.\nWarning. Maven (like Gradle) does not support cyclic dependencies, i.e. an artifact cannot depend on itself (directly or transitively).\nExercise Does this imply that the dependencies of an artifact form a tree?\nSolution No. A tree is a rooted acyclic graph, but the converse does not hold.\nTo display the dependency graph of a project (unraveled as a tree), run:\nmvn dependency:tree If a project depends (transitively) on two versions of the same artifact, then the \u0026ldquo;closest\u0026rdquo; version (in the dependency graph) is chosen (or the first declared in case of a tie).\nNote. If a project depends on a SNAPSHOT version, then the installed artifact is automatically updated on a regular basis (by default once per day), by both Maven and Gradle.\nDeclaring a dependency # Maven # A dependency can be declared by adding the following to the pom.xml file, inside the \u0026lt;dependencies\u0026gt; tag:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt; XXX \u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt; XXX \u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt; XXX \u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; In addition, the attribute \u0026lt;scope\u0026gt;test\u0026lt;\\scope\u0026gt; can be added to indicate that the dependency is needed for unit tests only (other scopes can be specified).\nExample. Here is how to declare dependencies on Guava, Smile and JUNIT 5, while specifying that the latter is only needed for unit tests:\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.guava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;guava\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;33.1.0-jre\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.haifengl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;smile-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.10.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Gradle # There are several alternative syntaxes to declare a dependency with Gradle (these may depend on the project\u0026rsquo;s configuration).\nExample. If you chose the board game as your project, then you can declare a dependency in the file core/build.gradle as follows. Within:\ndependencies { ... } add a line:\nimplementation group: XXX, name: XXX, version: XXX For instance:\nimplementation group: \u0026#39;com.google.guava\u0026#39;, name: \u0026#39;guava\u0026#39;, version: \u0026#39;33.1.0-jre\u0026#39; To specify that the dependency is only needed for unit tests, replace implementation with testImplementation.\nUsing an external library # Once a dependency is declared, the classes and interfaces of the corresponding library can be used in the source code of the project, with a regular import statement.\nExample. Guava provides a convenient class ImmutableList for lists that cannot be modified. It can be used as follows:\nimport com.google.common.collect.ImmutableList; public class MyClass { String name; ImmutableList\u0026lt;Integer\u0026gt; values; public MyClass(String name, ImmutableList\u0026lt;Integer\u0026gt; values){ this.name = name; this.values = values; } ... } Hint. Import statements like the one above can be automatically generated by your IDE.\n"},{"id":51,"href":"/docs/objects/sections/tostring/","title":"Displaying objects","section":"Objects and classes","content":" Displaying objects # The class Object # Java has a native class called Object with 11 instance methods. Every Java class implicitly extends Object, including user-defined classes. Therefore any Java class inherits these methods.\nThe method toString # toString is one of the methods of the class Object. Here is (part of) its specification:\n/** Returns a string representation of the object. * In general, the toString method returns a string that \u0026#34;textually represents\u0026#34; this object. */ public String toString(); This is the preferred way to display information about an object. For instance, the debugger of your IDE probably relies on this method to display a string that represents an object.\nThis method is also called by many (native or not) methods and operators. For instance, the following program\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); System.out.println(myUnicorn); String message = \u0026#34;Hello \u0026#34; + myUnicorn; is equivalent to\nUnicorn myUnicorn = new Unicorn(\u0026#34;green\u0026#34;); System.out.println(myUnicorn.toString()); String message = \u0026#34;Hello \u0026#34; + myUnicorn.toString(); Overriding toString # The default implementation of toString (in the class Object) displays very little information about the object:\npublic String toString() { return getClass().getName() + \u0026#34;@\u0026#34; + Integer.toHexString(hashCode()); } Warning. The output of hashCode() in this example is not the reference (a.k.a. \u0026ldquo;memory address\u0026rdquo;) of the object.\nSo a common practice consists in overriding toString. For instance, here is a possible implementation of the method toString within a class Unicorn:\npublic class Unicorn { String color; int health; ... @Override public String toString() { return \u0026#34;Unicorn{\u0026#34; + \u0026#34;color=\u0026#34; + color + \u0026#34;, \u0026#34; + \u0026#34;health=\u0026#34; + health + \u0026#34;}\u0026#34;; } } Or better (if MobileUnit is a superclass of Unicorn and Butterfly, as in our previous example):\npublic class MobileUnit extends Unit { String color; ... @Override public String toString() { return getClass().getName() + \u0026#34;{\u0026#34; + \u0026#34;color=\u0026#34; + color + \u0026#34;, \u0026#34; + \u0026#34;health=\u0026#34; + health + \u0026#34;}\u0026#34;; } } Hint. Your IDE can generate such a method.\nRecursion # A naive implementation of toString (e.g. generated by an IDE) may have unexpected effects.\nExercise Consider an implementation of our game where units (on each side of the board) are grouped by column. This implementation may use a class Column to represent a column and the adjacent one(s), as follows:\npublic class Column { Unit[] units; // null if this is the left-most column Column leftAdjacentColumn; // null if this is the right-most column Column rightAdjacentColumn; public Column(Unit[] units){ this.units = units; } @Override public String toString() { return \u0026#34;Column{\u0026#34; + \u0026#34;units=\u0026#34; + units + \u0026#34;, \u0026#34; + \u0026#34;left=\u0026#34; + leftAdjacentColumn + \u0026#34;, \u0026#34; + \u0026#34;right=\u0026#34; + rightAdjacentColumn + \u0026#34;}\u0026#34;; } } Then a board may be created as follows:\nUnit[] a1 = new Unit[]{ new Unicorn(\u0026#34;green\u0026#34;) }; Column c1 = new Column(a1); Unit[] a2 = new Unit[]{ new Butterfly(\u0026#34;yellow\u0026#34;) }; Column c2 = new Column(a2); c1.rightAdjacentColumn = c2; c2.leftAdjacentColumn = c1; System.out.println(c1); There is an issue with this program. Can you identify it?\nSolution The program does not terminate, because toString is (implicitly) recursive, and each of the two columns refers to the other.\n"},{"id":52,"href":"/docs/env/sections/os/","title":"Operating system","section":"Development environment","content":" Operating system (OS) # Your computer does not bind you to one OS. You can run multiple OSs on the same computer by:\npartitioning your disk, or booting from an external drive, or using virtualisation. Depending on what you are developing, one operating system may be more convenient than another.\nWe review below some benefits and drawbacks of developing under Windows, macOS and Linux.\nWindows # Benefits and drawbacks # Here are some benefits of using Windows as your OS for software development:\nit comes pre-installed on most PCs, it is compatible out-of-the-box with most hardware, it provides a fully integrated development suite for the .NET framework (C#, F#, Visual Basic), and to a lesser extent C/C++. And some drawbacks:\nfor general-purpose development, Windows is less friendly to new programmers (compared to Linux or macOS), the usage of an (OS-wise) package manager is (still) not the norm, it sometimes favors backwards compatibility over compliance with modern standards. When to use Windows (and when not) # Windows is the OS of choice for developing software meant to run on Windows only, or cross-platform software written in one of the .NET languages (mostly C#). C# is notably used for game development (e.g. for Unity) and graphical interfaces (although Javascript-based graphical frameworks may have become more popular lately).\nVisual studio (not VSCode!) offers a fully integrated development suite for the .NET languages, and is also commonly used for C/C++.\nFor other programming languages, using Windows may require extra efforts or precautions (compared to Linux or macOS), especially for new developers.\nIn particular:\nsoftware installation/upgrade/removal can be complex and error-prone, writing scripts (e.g. for two programs to interact) can also be more involved, due to multiple shells. Besides, additional care must be taken to write platform-independent code. Here are two frequent sources of errors made by students:\nPath separators (see the dedicated section),\nLine breaks (see the dedicated section).\nFor this course # You should be able to complete all assignments and write your project using Windows (even if your collaborators use other OSs).\nHowever, you may need to pay extra attention, for instance to path names (as explained above). Installing and configuring the necessary software may also be more complex (again, we recommend using a package manager when possible).\nIf you do not manage to set up your working environment for this course (see the requirements) in a short amount of time, then consider using a Linux distribution instead (see the dedicated section below for using Linux alongside Windows).\nmacOS # Here are some benefits of using macOS as your OS for software development:\nit comes pre-installed with an Apple computer, it is POSIX-compliant (since 2001), thus offering easier interoperability with Linux/BSD/Android/IOS the Homebrew package manager is relatively mature. And some drawbacks:\nsome software may not be available, your working environment is not easily customizable. When to use macOS (and when not) # MacOS is rarely used on hardware other than Apple computers.\nIt is often a good choice for new developers. In particular, Homebrew offers an easy way to install/update/remove programs needed for general-purpose development (compilers, interpreters, other package managers, etc.).\nA number of more experienced developers also work with macOS, notably for web development (Node.js/Javascript) or data science (Python).\nA Linux distribution may be more convenient in some situations, e.g. when developing a program meant to run on a server, or when working with Docker containers.\nFor this course # If you have a Apple laptop, then you should not need an OS other than macOS for this course (even if your collaborators use Windows or Linux).\nLinux # Here are some benefits of using Linux as your OS for software development:\nit is primarily designed for developers, it is relatively lightweight, it has an important (and high-quality) online community support, it is used by most web servers, (OS) package managers are mature and easy to use, your working environment can be easily customized and/or configured. And some drawbacks:\nLinux rarely comes pre-installed on a computer, there is sometimes too much choice (distributions, programs, configuration options, etc.), Linux distributions are (arguably) not as friendly to desktop users as Windows or macOS, Hardware support (e.g. for peripherals) is (still) more limited than for Windows. When to use Linux (and when not) # Linux is often the OS of choice for developing programs meant to run on web servers. It is also a good choice for writing cross-platform software.\nLinux (together with macOS) is also a good environment to learn the basics of programming, due to native compatibility with a wide range of technologies for general-purpose development (e.g. Docker). Software installation, configuration, upgrade and removal is also made easier by mature package managers. Besides, the Linux shell is a versatile yet relatively simple tool that can ease process management or interaction between programs.\nLinux is arguably not the best choice for developing Desktop applications that target a specific OS (such as Windows or macOS), or in some specific domains such as game development.\nFor this course # You should be able to complete all assignments and write your project using a Linux distribution (even if your collaborators use other OSs).\nIn particular, if you face important issues when setting up your working environment (git, JDK, Maven, Gradle, etc. ) on Windows, we recommend using a Linux distribution instead (this may save you time). Keep in mind however that this will not solve issues related to the configuration of your IDE.\nNot that you can use Linux (for development) and Windows (for other purposes) on the same computer.\nWhich distribution to choose # You can use any (reasonably mainstream) all-purposes Linux distribution for this course (and other courses).\nThe choice may seem overwhelming at first sight, but most distributions are forks of a few popular ones (Debian, Fedora, Arch, \u0026hellip;), and are relatively similar to each other. Besides, Linux environments are highly customizable: for instance, the choice of a distribution does not bind you to its default desktop environment. Available software is also very similar from one distribution to another: regardless of the distribution, you will have access to openJDK, git, Maven, etc. via a package manager.\nDesktop oriented distributions # Distributions that are more desktop-oriented can be more friendly to newcomers (especially non-developers), but also come with unnecessary software. Two popular distributions in this category (for new users) are Linux Mint and Zorin OS. Both are forks of Ubuntu, which is itself a fork of Debian.\nLightweight distributions # For a (slightly) more lightweight distribution, MX Linux is currently a popular choice. It is also based on Debian.\nHow to install a Linux distribution # Most distributions provide detailed instructions on their web page.\nRegardless of the distribution, you have are (at least) three possible options:\nVirtual machine (such as VirtualBox). This is the simplest option in terms of installation. But also the most expensive computationally, so only suited to a relatively powerful computer. Performance is also suboptimal.\nA virtual machine is often good way to test a distribution before properly installing it.\nBootable drive. You can store your Linux distribution on an external hard drive, and boot on Linux when the hard drive is connected to your computer. Compared to the third option below, this may affect the performance of disk access.\nPartition (with dual boot). You can dedicate a certain amount of space to a Linux distribution your hard drive. A minimum of 30 GB is often recommended (this can be adjusted later on). When starting your computer, it will let you choose which OS to boot on. This is the best option in terms of performance.\nNote. For the third option (dual boot), the installation procedure has become slightly more involved on some recent computers, due to encrypted disks or so-called \u0026ldquo;secure boot\u0026rdquo;. So make sure that the instructions that you follow are up-to-date.\n"},{"id":53,"href":"/docs/intro/sections/bibliography/","title":"Additional resources","section":"This course","content":" Additional resources # You are free to use additional resources (web sites, IDE generated code, Copilot, etc.) to solve the course\u0026rsquo;s assignments and/or develop your project.\nHowever, make sure that you understand the code that you submit.\nJava\u0026rsquo;s syntax # This website contains Java code snippets that illustrate how to perform certain operations. However, this documentation is far from exhaustive (on purpose).\nWhen it comes to syntax, the first two sources of complementary material for this course are:\nthe Javadoc of the libraries (standard and auxiliary) used in projects and assignments. An IDE is often the fastest way to navigate through it, and the web. Books # An (optional) reading list for this course is available in the catalogue of the Unibz\u0026rsquo;s library. All books can be accessed via the library (either physically or digitally).\nAmong these books, we highlight the following three:\nIntroductory textbooks # Java : the complete reference (11th edition) by Herbert Schildt McGraw-Hill Education, 2019\nThis is a general introductory book to Java and object oriented programming. It covers most topics seen in this course (and a lot more).\nHead First Java (3rd edition) by Kathy Sierra, Bert Bates and Trisha Gee O\u0026rsquo;Reilly Media, 2022\nThis is an alternative introductory book, less comprehensive, but with more emphasis on problem solving (rather than syntax).\nGood practices (intermediate level) # Effective Java (3rd edition)\nby Joshua Bloch\nAddison-Wesley Professional, 2017\nThis is a reference book for best practices and common pitfalls when programming in Java (and more generally in an object-oriented language).\n"},{"id":54,"href":"/docs/build/sections/building/","title":"Building","section":"Build automation","content":" Building # Cleaning # The command\nmvn clean attempts to delete all content generated during a previous build (in particular, .class files).\nExample. Let us assume that MyClass.java is compiled into MyClass.class, and then renamed MyNewClass.java. In this scenario, mvn clean allows eliminating the file MyClass.class from the target directory.\nThe default lifecycle # Maven\u0026rsquo;s default lifecycle is a sequence of 23 operations (called phases) that can be executed during a build.\nThese include (in order):\nvalidate: checks if all the information needed for the build is present compile: compiles the source code of the project test-compile: compiles the source code of the unit tests of the project test: runs the unit tests package: packages the compiled code in its distributable format (such as a jar) install: installs the package into the local repository (for use as a dependency in other local projects) Each phase can be executed via command-line with mvn \u0026lt;phaseName\u0026gt;. For instance:\nmvn package Warning. Executing any of these phases triggers the execution of all phases that precede it.\nFor instance, executing the test phase triggers the execution of validate, compile and test-compile (among others).\nGoals and plugins # A build phase (like package) consists of so-called goals.\nA goal can be declared, configured and associated to a specific phase via a so-called plugin.\nIn a POM:\na plugin is specified within the \u0026lt;plugin\u0026gt;\u0026lt;/plugin\u0026gt; tag, and plugins are declared within: \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; ... \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; For instance, here is the plugin called maven-jar-plugin, as it is inherited from the Super POM:\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; ... \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;default-jar\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;jar\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; ... \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; This plugin assigns the goal jar to the phase package. Intuitively, this specifies that the phase package must produce a jar file (as opposed to other formats like war or ear).\nIn order to make this jar executable (and specify the main class of the application), we can add information to this inherited plugin, in the pom.xml file of the project, as follows:\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; ... \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;addClasspath\u0026gt;true\u0026lt;/addClasspath\u0026gt; \u0026lt;mainClass\u0026gt;org.example.Main\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; ... \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; The effective POM in this example contains:\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; ... \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;default-jar\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;jar\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;addClasspath\u0026gt;true\u0026lt;/addClasspath\u0026gt; \u0026lt;mainClass\u0026gt;org.example.Main\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; ... \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; A plugin can contain several goals, and these may or may not be assigned to a specific phase.\nBesides, a goal can be executed independently from a phase, with the command:\nmvn myplugin:myGoal For instance, the javafx maven plugin has a goal run to start a JavaFX application. It can be executed with:\nmvn javafx:run Installing a plugin # Maven plugins are available for a variety of tasks, like code analysis, Javadoc generation, parser generation, etc.\nAn plugin is a Maven artifact. Similarly to a dependency, an external plugin can be downloaded from Maven Central and installed into the local repository , as follows:\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; ... \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt; XXX \u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt; XXX \u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt; XXX \u0026lt;/version\u0026gt; ... \u0026lt;/plugin\u0026gt; ... \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; However, as illustrated above, additional XML attributes may be needed to configure the plugin. These are often specific to a plugin.\nUseful plugins # The assembly plugin # The assembly plugin allows building a Ã¼ber jar (i.e. including dependencies), as opposed to the maven-jar-plugin, which can build a thin jar.\nThis is a simple way to distribute an end-user application (as opposed to a library).\n\u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-assembly-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.7.1\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;single\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;mainClass\u0026gt;org.example.MainClass\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;descriptorRefs\u0026gt; \u0026lt;descriptorRef\u0026gt;jar-with-dependencies\u0026lt;/descriptorRef\u0026gt; \u0026lt;descriptorRef\u0026gt;src\u0026lt;/descriptorRef\u0026gt; \u0026lt;/descriptorRefs\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; In this example, the execution of the goal (called single) is attached to the phase package, so the Ã¼ber jar can be produced like a regular jar, with:\nmvn package The source plugin # The source plugin can package source code as a jar. This allows:\ndistributing a Java library alongside its source code, and/or installing the library in the local repository together with the source (and navigate through it with an IDE). \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-source-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.1\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;attach-sources\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;verify\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;jar-no-fork\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; In this example, the execution of the goal (called jar-no-fork) is attached to the phase verify.\nThe Javadoc plugin # \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-javadoc-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.6.3\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;17\u0026lt;/source\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; This plugin has many goals, which are often executed independently (i.s. not bound to a phase).\nFor instance:\nmvn javadoc:javadoc generates Javadoc for the project in the folder target/site.\n"},{"id":55,"href":"/docs/objects/sections/comparing/","title":"Cast and equality","section":"Objects and classes","content":" Cast and Equality # Cast # Java (as well as C# and C++) provides mechanisms to change the type associated with an object $o$, using either a supertype of $o$ (this is an upcast), or a subtype of $o$ (this is a downcast).\nUpcast # Explicit upcasts are uncommon, but may still be useful in some scenarios, e.g. to disambiguate two method calls.\nImplicit upcasts on the other hand are very frequent, when the type of an object cannot be determined at compile time.\nExample. Consider the following classes:\nNow consider the following program, where the method getUnits produces an array of units that depends on the player\u0026rsquo;s input. The type of objects in this array (Unicorn or Butterfly) cannot be determined at compile time. Thanks to the implicit upcast, they can nonetheless be referred to as (underspecified) units.\nUnit[] units = getUnits(); for (Unit unit: units){ ... } Downcast # Downcasting in Java is frequent for objects whose type cannot be determined at compile time. However, this may not be safe. For instance, in the above example, downcasting a unit from Unit to Unicorn may cause a ClassCastException (at runtime), because this unit is a instance of Butterfly. This is why downcasting is often used in combination with the instanceof operator. For instance the above example can be modifed as follows:\nUnit[] units = getUnits(); for (Unit unit: units){ if(unit instanceof Unicorn){ ((Unicorn) unit).regen(); } } Here the operation (Unicorn) unit is a downcast. This allows the call to the method regen.\nObject equality # As we saw in a previous chapter, a constructor in Java creates an object in memory and returns a (fresh) reference to that object. Since two objects have different locations in memory, their respective references must differ, even if the content of the two objects is identical.\nExample. Consider (a simplified version of) the class City that we saw earlier.\npublic class City { String name; int zipCode; public City(String name, int zipCode){ this.name = name; this.zipCode = zipcode; } } The following program will output false:\nCity city1 = new City(\u0026#34;Florence\u0026#34;, 50100); City city2 = new City(\u0026#34;Florence\u0026#34;, 50100); System.out.println(city1 == city2); However, in some scenarios, it may be useful to compare the content of two objects, rather than their references. Java provides a native method called equals for this purpose.\nLike the method toString that we saw earlier, the equals is an instance method of the native Java class Object, which is an (implicit) superclass of every other class. So every (user-defined of native) class inherits equals.\nHere is the source code of Object.equals:\npublic boolean equals(Object obj) { return (this == obj); } In other words, by default, this method behaves like the == operator. In order to use this method to check whether two objects are equal, it has to be overriden.\nFor instance, here is a prototypical implementation of the method equals within our class City:\n@Override public boolean equals(Object o) { if (this == o) { // same reference return true; } if (o == null || getClass() != o.getClass()) return false; // o is null or has a different type } City downcastObject = (City) o; return zipCode == downcastObject.zipCode \u0026amp;\u0026amp; name.equals(downcastObject.name); } Hint. Your IDE can generate such a method.\nNote in this example:\nthe (safe) downcast from Object to City, and the recursive call to equals (because the attribute name has type String). Recursion # Warning. Similarly to what we saw with the method toString, beware of naive (recursive) implementations of equals if your program can create an object that refers to itself (directly or indirectly).\nBuilt-in implementations # Several native Java classes have their own implementation of equals. We will encounter several of them during this course, notably for the class String and for the implementations of the interface Set.\nThe method hashCode # The method equals is usually overridden together with another method of the class Object, called hashCode. In particular, this is needed for the method equals of the class HashSet to behave correctly. We will explore this topic later in this course, when we introduce the notion of a hash table.\n"},{"id":56,"href":"/docs/errors/","title":"Errors","section":"Docs","content":" Errors # We all make mistakes when we write code.\nDeveloping efficient strategies to identify mistakes is an essential part of programming.\nCompile time vs runtime errors # In (pre)compiled languages (like Java, C/C++, C#, Python, Rust, Go, etc.), a distinction is generally made between compile time errors and runtime errors.\nA compile time error prevents a program from compiling. It can be thought of as a \u0026ldquo;syntactic\u0026rdquo; error. A runtime error (a.k.a. bug) occurs during the execution of a program. It may depend on the input of the program. Hint. Compile time errors tend to be (much) easier to fix than bugs, especially in large projects. Besides, an IDE can identify some compile time errors (and highlight them) before the program is even compiled.\nSo it is often good practice to write your code in such a way that a maximal number of errors can be identified at compile time.\nNote. For interpreted languages (like Javascript, Lua, etc.), the term \u0026ldquo;compile time error\u0026rdquo; is meaningless. However, a distinction can still be made between errors that can be preemptively identified (e.g. highlighted by an IDE), and errors that can only be detected at runtime.\nError messages # A precise error message can significantly simplify debugging.\nAs a toy example, consider the following Java program:\npublic class City { String name; int zipCode; public City(String name, int zipCode) { this.name = name; this.zipCode = zipCode; } } 1 2 3 4 5 6 7 8 9 10 public class MyClass{ void myMethod(City[] cities){ City firstCity = cities[0]; if(firstCity.zipCode \u0026gt;= 20000) { System.out.println(firstCity.name.length()); } } } Exercise In this program, there are several reasons why the method MyClass.myMethod may fail at runtime. Can you identify some of them?\nSolution the input array may be null, the input array may have length 0, the input array may be empty, the first city in this array may have a zip code $\\ge$ 20 000 and no name. In the above example, if we execute the following,\nmyMethod(null); then we obtain this error message:\njava.lang.NullPointerException: Cannot load from object array because \u0026#34;cities\u0026#34; is null at MyClass.myMethod(MyClass.java:5) Note that this message provides a clear indication of:\nthe file (MyClass.java), method in this file (MyClass.myMethod) and line of code (5) that caused the error, the type of error (NullPointerException), the cause of the error (the variable city has value null). Hint. A NullPointerException in Java often indicates an attempt to access an object (or array) via a pointer (e.g. a variable) whose value is null.\nSimilarly, if the method is called with an empty array,\nmyMethod(new City[]{}); we get the following error message:\njava.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0 at MyClass.myMethod(MyClass.java:5) Exercise Which type of error will the following call to myMethod produce?\nmyMethod(new City[]{ new City(30100, null) }); Solution java.lang.NullPointerException: Cannot invoke \u0026#34;String.length()\u0026#34; because \u0026#34;firstCity.name\u0026#34; is null at MyClass.myMethod(MyClass.java:7) Anticipation # Consider the following method:\nint least(int x, int y){ return x \u0026lt;= y ? x : y; } This method has two desirable features (shared with mathematical functions):\nany arguments for this method (i.e. any pair of integers in this example) are a valid input, its execution only depends on its arguments, i.e. if the method is called twice with the same arguments, then it has the same behavior. However, this is not the case of all methods.\nIf one of these two condition does not hold, then it may be useful to write your own error messages, in anticipation. This may benefit:\nusers of the program, and collaborators (including your future self!) who will maintain (debug, extend, etc.) the program. Example. For instance, consider a method\nboolean isSolvable (int[][] grid); that takes as input a grid of sudoku, and returns true iff it is solvable, meaning that this grid admits a unique solution. A valid input for this problem could be a 9 x 9 array of integers with values between 0 and 9 (where 0 indicate the absence of value). However, Java does not provide such a precise data type.\nIt may be useful to produce an (informative) error message if the input array:\nis not 9 x 9, or contains a value \u0026lt; 0 or \u0026gt; 9. Controlled environment # Anticipating all types of invalid inputs/scenarios (and producing error messages for these) may induce a lot of boilerplate code. If you have control over the input and/or execution environment of a method, then this may not be necessary. For instance, in the case of auxiliary methods (i.e. methods that are not visible to other classes or components).\nExample (continued). Consider the method boolean isSolvable (int[][] grid) described above. Let us assume that it is private, and called only by a method generateGrid that generates a grid pseudo-randomly.\nIt may be safe to assume that the implementation of generateGrid only produces 9 x 9 arrays with values between 0 and 9. In this scenario, there is probably no need to implement error messages in isSolvable.\n"},{"id":57,"href":"/docs/env/sections/requirements/","title":"Requirements for this course","section":"Development environment","content":" Requirements for this course # For this course, you will need:\nGit Version 2.2 or higher A Java Development Kit (JDK) for Java 21 (e.g. openJDK) Maven Version 3.6 or higher In addition, if you choose the board game as project, you will need:\nGradle Version 7.2 or higher Again, we recommend using a package manager to install these programs if possible.\nFor Windows users. Maven is not available on the Winget repository. But you can find it on the Chocolatey repository.\nYou will also need:\na text editor (possibly your IDE) an IDE a terminal emulator (possibly your IDE) "},{"id":58,"href":"/docs/input/sections/serialize/","title":"Serialization","section":"I/O and serialization","content":" Serialization # Serializing an object (resp. data structure) means converting it into a form that can be stored or transmitted, and such that the object (resp. data structure) can be later reconstructed (a.k.a. deserialized).\nin Java # Java provides a native mechanism to serialize an object (including information about the type of the object). The serialization format is not (meant to be) human-readable.\nThe process is JVM independent, meaning that an object can be serialized on one platform and deserialized on another.\nTransient # In Java, an instance attribute can be marked with the keyword transient. For instance:\npublic class MyClass { String serializedAttribute; transient int transientAttribute; ... } Transient attributes are excluded from the serialization process (meaning that a serialized object contains no value for its transient attribute).\nWarning. When an object is deserialized (i.e. converted back to an object), default values are assigned to each of its transient attributes: null for a reference, 0 for an int, false for a boolean, etc.\nSerializable # In Java:\na value with primitive type (e.g. int) is serializable, an array is serializable if its elements are serializable, an object is serializable if: its class implements the interface Serializable, and each of its attributes is serializable or marked as transient. Note. Implementing the interface Serializable does not require implementing any method.\nExample. Instances of the following class are not serializable, because Country does not implement Serializable.\npublic class Country { String name; public Country(String name) { this.name = name; } } Instances of the following class are not serializable either, because the attribute country has type Country, which does not implement Serializable.\npublic class City implements Serializable { String name; int zipCode; Country country; public City(String name, int zipCode, Country country) { this.name = name; this.zipCode = zipCode; this.country = country; } } However, if we replace\nCountry country; with\ntransient Country country; then instances of the class City become serializable, because:\nthe attribute name has type String, which implements Serializable, and the attribute zipCode has a primitive type, and the attribute country is now declared as transient. Note. Most native implementations of the Java interfaces Collection (ArrayList, LinkedList, HashSet, TreeSet, etc.) and Map (HashMap, TreeMap, etc.) also implement Serializable.\nserialVersionUID # If a class implements the interface Serializable, it is recommended to add a field: private static final long serialVersionUID (annotated with @Serial) and initialize it. For instance:\npublic class City implements Serializable { @Serial private static final long serialVersionUID = 0; ... } The value is irrelevant, but is meant to be updated if the (instance) attributes of the class are modified.\nFor an explanation, we refer to this page.\nSerialization (and deserialization) methods # The class ObjectOutputStream allows serializing an object, with the method:\nvoid writeObject(Object x) throws IOException Similarly, the class ObjectInputStream allows deserializing an object (i.e. loading it back into memory), with the method:\nObject readObject() throws IOException, ClassNotFoundException Note. The return type of readObject is Object, so the returned object needs to be cast to its appropriate data type.\nExample. Let us continue with the example above (assuming that the attribute City.country is marked as transient).\nA instance of City can be serialized to a file as follows:\nString path = \u0026#34;path/to/file.ser\u0026#34;; Country italy = new Country(\u0026#34;Italy\u0026#34;); City bologna = new City(\u0026#34;Bologna\u0026#34;, 40100, italy); try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(path))) { out.writeObject(bologna); } catch (IOException e) { throw new RuntimeException(e); } And deserialized as follows:\nCity deserializedBologna; try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(path))) { deserializedBologna = (City) in.readObject(); } catch (IOException | ClassNotFoundException e ) { throw new RuntimeException(e); } // Ouputs \u0026#39;Deserialized city: { name: Bologna, zipCode: 40100, country: null }\u0026#39; System.out.printf( \u0026#34;Deserialized city: { name: %s, zipCode: %d, country: %s }\u0026#34;, deserializedBologna.name, deserializedBologna.zipCode, deserializedBologna.country ); Observe that the attribute country after deserialization has value null (because it is marked as transient).\n"},{"id":59,"href":"/docs/git/sections/branches/","title":"Branches","section":"git","content":" Branches # Listing branches # The command\ngit branch allows you to list all local branches (for the current repository).\nCreating a branch # To create a new branch, run\ngit branch \u0026lt;branchName\u0026gt; Then you can switch to this branch with\ngit checkout \u0026lt;branchName\u0026gt; Alternatively, you can perform both operations with a single command:\ngit checkout -b \u0026lt;branchName\u0026gt; Deleting a branch # You can delete a (local) branch other than the current branch with\ngit branch -d \u0026lt;branchName\u0026gt; Merging a branch # To merge a branch \u0026lt;branchToMerge\u0026gt; into a branch \u0026lt;receivingBranch\u0026gt;, switch first to the receiving branch:\ngit checkout \u0026lt;receivingBranch\u0026gt; Then run\ngit merge \u0026lt;branchToMerge\u0026gt; If possible, a fast-forward merge will be performed.\nOtherwise a regular merge will be attempted. If this cannot be done (due to merge conflicts), then you will be asked to fix the merge conflicts. After fixing the conflicts, you can finalize the merge with\ngit commit "},{"id":60,"href":"/docs/objects/sections/classesasobjects/","title":"Classes as objects","section":"Objects and classes","content":" Classes as objects # Some object-oriented languages (like Java, C# or C++) provide ways to access or manipulate classes (almost) as if they were objects.\nStatic attributes and methods # Static attributes # Java (as well as C# and C++) supports attributes that do not belong to a specific instance, but to a class instead. These are often called static attributes (or sometimes class attributes or class variables), as opposed to the attributes that we have seen so far, called instance attributes (or member variables).\nStatic attributes are marked with the keyword static.\nExample. Consider a version of our game where characteristics for each unit type (e.g. default health, etc.) can be declared manually, in a text file. The path to this file could be stored as a static attribute, as follows:\npublic class Unicorn { static String configFile = \u0026#34;units/unicorn.txt\u0026#34;; int health; public Unicorn(){ health = getHealthFromConfigFile(configFile); } public regen(){ health++; } } Each instance of Unicorn carries its own value for the attribute health. But the value of configFile is unique.\nFor instance, the following program creates in memory a unique string for configFile, which is carried by the class.\nUnicorn u1 = new Unicorn(); Unicorn u2 = new Unicorn(); Static methods # Similarly to a static attribute, a static method does not depend on a specific object, as opposed to an instance method.\nExample (continued).\nWe can add to our class Unicorn a static method that checks whether the configuration file exists:\npublic class Unicorn{ ... static boolean configFileExists() { return Files.exists(Paths.get(configFile)); } } (note that the method getHealthFromConfigFile also may also be static, if its execution is identical for all instances of Unicorn).\nRemember that an instance method can be called outside of the class where it is declared, using an instance of the class followed by .:\nUnicorn myUnicorn = new Unicorn(); myUnicorn.regen(); A static method can (syntactically) be called in the same way, for instance:\nUnicorn myUnicorn = new Unicorn(); boolean valid = myUnicorn.configFileExists(); However, this is often discouraged, because this syntax can be misleading (in this example, configFileExists can be mistaken for an instance method).\nAlternatively, since the method depends on the class (rather than an instance), the call can be prefixed with the class name. This syntax is often preferred, because it leaves no ambiguity. For instance:\nboolean valid = Unicorn.configFileExists(); Note that there may be several instances of a same class in memory during the execution of a program, or no instance at all. This is why a static method cannot access an instance attribute or instance method. For instance, adding the following static method to our class would cause a compilation error, because health is an instance attribute.\npublic class Unicorn { static void reduceHealth(){ health--; } } Inheritance # Two static methods with the same name and signature can be declared in a class and a superclass. In Java\u0026rsquo;s terminology, this is not called method overriding, but instead method hiding. An important difference is that dynamic dispatch (a.k.a. runtime polymorphism) does not apply to this case (the method to be called is determined at compile time, rather than run time).\nExample (continued).\nLet us extend our example with a subclass of Unicorn that hides the static method configFileExists.\npublic class EvilUnicorn extends Unicorn { static boolean configFileExists(){ return false; } } Now consider the following program, where the method getUnicorns produces an array of unicorns that depend on the player\u0026rsquo;s input. The specific type of objects in this array (Unicorn or EvilUnicorn) cannot be determined at compile time.\nUnicorn[] unicorns = getUnicorns(); for (Unicorn unicorn: unicorns){ System.out.println(unicorn.configFileExists()); } } In this example, the method of the superclass (i.e. Unicorn.configFileExists) will be executed for each object in the array, regardless of its type.\nThis is another reason why calling a static method via an instance (rather than via a class name) is often discouraged. In this example, writing Unicorn.configFileExists() (with a capital U) would make it clear that this loop serves no purpose (the same method is executed unicorns.length times).\nJava interfaces # Since Java 8 (2014), an interface can also carry static methods and attributes.\nReflection # Java (as well as C#) offers a mechanism called reflection to intuitively treat classes analogously to objects. Precisely, each class of a program (e.g. the class Unicorn) is associated with an object that represents it. This object is itself an instance of the Java class called Class. It can be accessed either:\nvia an instance of the class: Unicorn myUnicorn = new Unicorn(); Class unicornClass = myUnicorn.getClass(); or via the qualified name of the class (assuming for instance that the file Unicorn.java is in the folder \u0026lt;workingDirectory\u0026gt;/src/main/java/org/units): Class unicornClass = Class.forName(\u0026#34;org.units.Unicorn\u0026#34;); The instance methods of the class Class are listed here. Among others, they allow:\nlisting the attributes of the class, retrieving its immediate superclass, or the interfaces that it implements, creating a new instance of this class, etc. Reflection is a powerful feature. It is rarely used in everyday code, but can be helpful in specific situations. Notably, it is used (internally) by numerous Java frameworks such as Spring, Jackson or JUnit.\n"},{"id":61,"href":"/docs/errors/sections/errors/","title":"Java errors","section":"Errors","content":" Java errors # Aside from exceptions, a Java program can throw a so-called Error.\nAccording to the Javadoc for the class Error:\nAn Error [\u0026hellip;] indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions.\nFor instance, some subclasses or Error are OutOfMemoryError and StackOverflowError.\n"},{"id":62,"href":"/docs/git/sections/sharing/","title":"Synchronization: remote, push, pull","section":"git","content":" Synchronization: remote, push, pull # List remotes # To list the remote(s) associated to your repository (name and address of each remote), you can run\ngit remote -v Upload # If the current branch is already shared with a remote, you can upload it with\ngit push Otherwise, you can share this branch (and its commits) with\ngit push -u \u0026lt;remoteName\u0026gt; \u0026lt;branchName\u0026gt; To delete a remote branch, run\ngit push \u0026lt;remoteName\u0026gt; -d \u0026lt;branchName\u0026gt; Alternatively, you can delete a remote branch using the web interface of your hosting service.\nDownload # If your current branch is shared with your remote, you can update your local copy with\ngit pull Warning. When pulling, git will try to perform a fast-forward merge of the remote branch into your local copy. If you follow the basic workflow presented earlier, then this fast-forward merge should succeed. If it does not, then git will suggest you a command to perform a classical merge instead.\n"},{"id":63,"href":"/docs/env/sections/text_editor/","title":"Text editor","section":"Development environment","content":" Text editor # Text file # A text file stores a sequence of characters. These are typically Unicode characters, encoded in UTF-8 (or sometimes UTF-32 or UTF-64).\nMost of the files that programmers edit are text files.\nExercise Which of the following are text files?\nfile type conventional file name extension an MP3 file .mp3 a JPEG file .jpeg a PDF document .pdf a Microsoft Excel spreadsheet .xls or .xlsx a CSV file .csv a JSON file .json a Microsoft Word document .doc or .docx an Apple Pages document .pages a LibreOffice Writer document .odt a Python source file .py a Java source file .java a compiled Java class .class a Windows executable file .exe a bash script .sh Solution file type conventional file name extension is it a text file? an MP3 file .mp3 no a JPEG file .jpeg no a PDF document .pdf no a Microsoft Excel spreadsheet .xls or .xlsx no a CSV file .csv yes a JSON file .json yes a Microsoft Word document .doc or .docx no an Apple Pages document .pages no a LibreOffice Writer document .odt no a Python source file .py yes a Java source file .java yes a compiled Java class .class no a Windows executable file .exe no a bash script .sh yes Warning. A space is a character. So is a tab, a line break, etc.\nTherefore a file ending with a new line is different from the same file without this new line!\nEditor # A text editor is a program used to edit text files.\nAs a result, a text editor can open any file produced with another text editor (regardless of the file\u0026rsquo;s extension).\nMost operating systems come with one or several text editor(s) pre-installed, such as Notepad++ (Windows), TextEdit (macOS), gedit (default Ubuntu), etc.\nWarning (for Windows). Traditionally, text editors for Windows encode a line separator as two Unicode characters (\\r\\n), against a single character (\\n) on most modern systems. On Windows, this is typically hidden to regular users, because many programs apply line breaks normalization procedures (which may depend on the underlying OS).\nHowever, this is a source of bugs for developers, in certain scenarios. For instance:\nwhen generating code, when dealing with virtual environments (e.g. a Docker image), when sharing code via unconventional means (i.e. not via git), etc. Usage # Your IDE is an (enhanced) text editor, so you can use it as such. But it some scenarios, it can be useful to use a lighter program, for instance for:\nediting the configuration file of a program, modifying a small script (or even a single command-line instruction) copy-pasted from the web, etc. Among other reasons:\nopening an IDE can take time, if your IDE has autosave enabled, you may accidentally add unrelated files to your current project, Advanced text editors # For this course, a basic text editor is sufficient. But depending on your workflow, you may want to try a more advanced one.\nVSCode # VSCode is introduced in the section dedicated to IDEs.\nvi and Emacs # These are two keyboard-centric editors. Both were developed in the 70\u0026rsquo;s (before the mouse became a widespread peripheral) but are still commonly used today (in some form) by developers.\nWe do not recommend learning vi or Emacs at this (early) stage of your studies, because it requires time (and you arguably have more fundamental thing to learn). But you may give them a try at some point of your career, because they can significantly improve your productivity.\nvi/vim/neovim # vi was initially released 1978, as part of the first BSD distribution. The original program is rarely used today, but vim (for \u0026ldquo;vi improved\u0026rdquo;), released in 1991, and neovim, released in 2015 are still popular among developers. For instance, 22% (resp. 12%, non-exclusive) of respondents to the 2023 Stack Overflow developer survey use vim (resp. neovim) as a code editor.\nvi/vim/neovim is a so-called modal editor, meaning that users can switch between different modes. In one mode, pressing a standard key inserts the corresponding character, whereas in another mode, pressing the same key has a different functionality (navigation, copy, paste, etc.). These functionalities are referred to as vi keybindings or vi motions, and allow performing a variety of text editing operations in an efficient way.\nvi keybindings are commonly used in applications other than vi/vim/neovim, with dedicated plugins. For instance, most code editors/IDEs (VSCode, IntelliJ IDEA, Emacs, etc.), terminal emulators or even web browsers have plugins for vi keybindings.\nNote. vim and neovim are very customizable, with comprehensive collections of (community-developed) plugins, which allows using them as IDEs. We do not recommend trying this at this stage of your studies, because configuration may require a significant time investment (more than VSCode for instance).\nWarning. The original vi still comes pre-installed on many operating systems (Windows, macOS, Linux, \u0026hellip;), and may be the default text editor opened by terminal-based applications (e.g. git) on your system. If this is the case (and if you do not know the vi keybindings), then we recommend changing this setting.\nEmacs # Emacs was initially written in 1976. The most popular version is GNU Emacs, released in 91, was notably co-developed by Richard Stallman.\nEmacs is partly responsible for popularizing (sequences of) combinations of keys (e.g. Ctrl+\u0026lt;letter\u0026gt;), as opposed to modal editors like vi. GNU Emacs has more than 10 000 built-in commands, and also provides a (limited) mouse interface.\n5% of respondents to the 2023 Stack Overflow developer survey use Emacs as a code editor.\nEmacs is also very customizable, with a comprehensive collections of (community-developed) plugins (probably more comprehensive than vim), and dedicated software repositories. Notably, Emacs tends to serve as a unique user interface for a variety of tasks (code editing, terminal emulation, email management, web browsing, playing music/videos, etc.).\nNote. Emacs can be used as an IDE, but for the same reason as for vim or neovim, we do not recommend trying this at this stage of your studies.\n"},{"id":64,"href":"/docs/git/sections/backtracking/","title":"Backtracking","section":"git","content":" Backtracking # We already saw how a file can be unstaged (with git reset) before it is committed.\nIf the file was committed by mistake, then there are at least three scenarios.\nReset # If the commits that contain the file have not been shared yet with a remote, then these commits can be cancelled locally. The command\ngit reset \u0026lt;ID\u0026gt; moves the pointer for the current branch \u0026ldquo;back in time\u0026rdquo; to the commit \u0026lt;ID\u0026gt;. This has the effect of deleting all posterior commits.\nRevert # If the commits that contain the file have been shared with a remote, then git revert is often recommended by default.\nThis command does not affect the history of a branch (as opposed to git reset). Instead, if adds a commit to the history that reverts the k last commits on the current branch.\nFor instance\ngit revert HEAD adds a commit that reverts the latest one.\nAnd\ngit revert HEAD~3.. adds a commit that reverts the 3 latest ones.\nRewriting history # In some (rare) scenarios, one may need to rewrite the history of a branch that has already been shared.\nFor instance, sensitive information (passwords, etc.) or a large dataset may have been committed by mistake.\nDedicated tools may be used in such scenarios.\n"},{"id":65,"href":"/docs/env/sections/ide/","title":"IDE","section":"Development environment","content":" Integrated development environment (IDE) # An IDE is a text editor with additional functionalities for programmers.\nClassical functionalities of an IDE include:\ncode parsing and coloration, code completion, type checking (for typed languages), navigation to variable/method/class/interface declaration, navigation to variable/method/class/interface usage, refactoring (e.g. renaming a variable/method/class/interface in a whole project), diagnostics (e.g. in case of a parsing or typing error), a debugger, integration with built automation tools (e.g. Maven and Gradle for Java). For this course, you can use any IDE (or enhanced text editor) for Java with the features above. In this section, we give a brief overview of the most popular options.\nVisual Studio Code (VSCode) # Warning. VSCode and Visual Studio are two independent programs, and serve different purposes. In particular, Visual Studio does not natively support Java anymore (although this may technically be achieved with an LSP server and a DAP debugger, as explained below).\nVSCode is a (mostly) open-source project, primarily developed by Microsoft. Precisely, Code-OSS is a (fully) open source editor, and VSCode is a distribution of Code-OSS with additional features.\nVSCode is a general-purpose code editor, initially designed with a focus on web development (Node.js/Javascript). VSCode has probably become the most popular code editor among developers. For instance, it is used by 74% of respondents of the 2023 StackOverflow developer survey.\nNote. VSCode is often categorized as a \u0026ldquo;code editor\u0026rdquo; rather than an IDE. For this course, VSCode (together with some plugins) can serve as a Java IDE, so we will refer to it as an IDE for simplicity.\nExtensibility # The success of VSCode is often explained by its rich repository of (community-developed) plugins. At least two factors played a role:\nWeb development stack # VSCode is based on Electron, which allows writing plugins in Javascript, taking advantage of a vast ecosystem of code written for web applications (notably for graphical components).\nLSP and DAP # VSCode developers introduced standardized protocols for some IDE functionalities (like the ones listed above): the Language Server Protocol (LSP) and the Debug Adapter Protocol (DAP). These protocols specify (programming language independent) interfaces for communication between a code editor and a so-called \u0026ldquo;language server\u0026rdquo; (for LSP) or a debugger (for DAP).\nThis led to the development of LSP servers and DAP debuggers (or more often interfaces for existing debuggers) for a variety of programming languages (a list of LSP servers and features they implement can be found here).\nAn additional benefit is that other editors (notably neovim, Emacs and Visual Studio) have developed support LSP servers and DAP debuggers.\nfor Java # VSCode can be used as a Java IDE (at least to some extent) thanks to some plugins. For this course, you may use the extension pack for Java. If you choose the board game as your project, you may also need a plugin for Gradle, such as this one.\nIn some cases, using VSCode may require a little bit more configuration than a Java-centric IDE.\nEclipse, Netbeans and Intellij IDEA # These three editors have similar functionalities, and any of these three can be used for this course. All three were designed with Java in mind, and thus offer advanced integration with a variety of Java frameworks. Each of them also supports other programming languages, but the list varies from one editor to the other.\nAs of today, Intellij IDEA (IntelliJ for short) is probably the most popular Java-centric editor. This is a closed-source project, thus offering more limited customization than the other two.\nEclipse is an open-source project with a large ecosystem. It is known for its community support and its advanced plugin system, which led to the development of multiple extensions over the years (including support for C/C++, Python, etc.). Note that for performance reasons, Eclipse comes with its own Java Virtual Machine (JVM), which in some (rare) cases may not behave like other JVMs.\nNetbeans is also an open-source project. Notably, Netbeans provides a graphical tool to design Graphical User Interfaces (GUIs) for the Java Swing framework. However, we do not recommended using it for an advanced GUI (multiple windows, etc.), because the generated code can be very difficult to maintain or debug.\n"},{"id":66,"href":"/docs/input/sections/json/","title":"JSON Serialization","section":"I/O and serialization","content":" JSON serialization # A number of (external) libraries allow transforming Java objects into JSON objects and conversely. For instance Jackson, Gson, JSON-java, JSON-B and JSON-P.\nIn this section, we focus on Jackson.\nNote. Jackson was initially designed for JSON, but extensions of Jackson allow manipulating other formats: XML, TOML, YAML, CSV and Java property files.\nInstall # Jackson can be used within a Maven project, by declaring the following dependency\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.17.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; And similarly for Gradle:\nimplementation group: \u0026#39;com.fasterxml.jackson.core\u0026#39;, name: \u0026#39;jackson-databind\u0026#39;, version: 2.17.0 For the latest version, search Maven Central.\nInstalling this dependency will transitively install:\njackson-annotations jackson-core Basic syntax # Many tutorials can be found online about Jackson: for instance Jackson in N minutes on the GitHub page of the jackson-databind library.\nWe focus here on some simple features of the library.\nAn ObjectMapper can be used to map a Java object (or array or value) to some JSON string, and conversely.\nObjectMapper mapper = new ObjectMapper(); // Optional: indent the output JSON strings (and adds line breaks) when applicable mapper.enable(SerializationFeature.INDENT_OUTPUT); Convert a value # Serialize # // Outputs 15 System.out.println(mapper.writeValueAsString(15)); // Outputs \u0026#34;abcd\u0026#34; System.out.println(mapper.writeValueAsString(\u0026#34;abcd\u0026#34;)); Deserialize # // Creates an Integer with value 15 Integer integer = mapper.readValue(\u0026#34;15\u0026#34;, Integer.class); Convert an array or collection # Serialize # // Outputs [2,3] System.out.println(mapper.writeValueAsString(new int[]{2, 3})); // Outputs either [2,3] or [3,2] System.out.println(mapper.writeValueAsString(Set.of(2, 3))); Map\u0026lt;String, Integer\u0026gt; studentToAge = Map.of( \u0026#34;Alice\u0026#34;, 20, \u0026#34;Bob\u0026#34;, 19 ); /* Outputs { \u0026#34;Alice\u0026#34; : 20, \u0026#34;Bob\u0026#34; : 19 } */ System.out.println(mapper.writeValueAsString(studentToAge)); Map\u0026lt;String, List\u0026lt;Integer\u0026gt;\u0026gt; studentToMarks = Map.of( \u0026#34;Alice\u0026#34;, List.of(8,9), \u0026#34;Bob\u0026#34;, List.of(6,10) ); /* Outputs { \u0026#34;Alice\u0026#34; : [ 8, 9 ], \u0026#34;Bob\u0026#34; : [ 6, 10 ] } */ System.out.println(mapper.writeValueAsString(studentToMarks)); Deserialize # // Creates an array with values [2,3,2] int[] integers = mapper.readValue(\u0026#34;[2,3,2]\u0026#34;, int[].class); // Creates an Arraylist with values [2,3,2] List\u0026lt;Integer\u0026gt; list = mapper.readValue(\u0026#34;[2,3,2]\u0026#34;, List.class); // Creates a HashSet with values {2,3} Set\u0026lt;Integer\u0026gt; set = mapper.readValue(\u0026#34;[2,3,2]\u0026#34;, Set.class); // Creates a LinkedHashMap with values {\u0026#34;Alice\u0026#34; -\u0026gt; 20, \u0026#34;Bob\u0026#34; -\u0026gt; 19} Map\u0026lt;String, Integer\u0026gt; map = mapper.readValue(\u0026#34;{\\\u0026#34;Alice\\\u0026#34;: 20, \\\u0026#34;Bob\\\u0026#34;: 19}\u0026#34;, Map.class); Convert an object # Serialize # public class City { public String name; public Country country; public City(String name, Country country) { this.name = name; this.country = country; } } public class Country { public String name; public City capital; public Country(String name, City capital) { this.name = name; this.capital = capital; } } Country italy = new Country(\u0026#34;Italy\u0026#34;, null); City rome = new City(\u0026#34;Rome\u0026#34;, italy); /* Outputs: { \u0026#34;name\u0026#34; : \u0026#34;Rome\u0026#34;, \u0026#34;country\u0026#34; : { \u0026#34;name\u0026#34; : \u0026#34;Italy\u0026#34;, \u0026#34;capital\u0026#34; : null } */ System.out.println(mapper.writeValueAsString(rome)); However, recall that a JSON object cannot contain a reference to another JSON object. As a consequence, some Java objects cannot be finitely represented in JSON:\nitaly.capital = rome; // Throws a JsonMappingException: Document nesting depth (1001) exceeds the maximum allowed mapper.writeValueAsString(rome); By default, Jackson serializes:\npublic (instance) attributes, non-public fields that have a getter method. However, it is also possible to force serialization of other attributes, either for all classes:\nmapper.setVisibility(PropertyAccessor.FIELD, Visibility.ANY); or for a specific class:\n@JsonAutoDetect(fieldVisibility = Visibility.ANY) public class MyClass { ... } Warning. If a public attribute attribute and a getter getAttribute coexist, then the latter takes precedence.\nSome public attributes can also be explicitly ignored:\n@JsonIgnoreProperties(\u0026#34;name\u0026#34;) public class MyClass { public String name; ... } Deserialize # In order to create a Java object out of a JSON object, the attributes (a.k.a. \u0026ldquo;keys\u0026rdquo;) of the JSON object must be mapped to attributes of the targeted class.\nThis can be done by adding (Jackson-specific) annotations to a constructor for the class. For instance:\npublic class City { public String name; public int zipCode; @JsonCreator public City(@JsonProperty(\u0026#34;name\u0026#34;) String name, @JsonProperty(\u0026#34;code\u0026#34;) int zipCode) { this.name = name; this.zipCode = zipCode; } } String jsonCity = \u0026#34;{\\\u0026#34;name\\\u0026#34; : \\\u0026#34;Bologna\\\u0026#34;, \\\u0026#34;code\\\u0026#34; : 40100 }\u0026#34;; // Contains the object City{ name: \u0026#34;Bologna\u0026#34;, zipCode: 40100 } City bologna = mapper.readValue(jsonCity, City.class); In the example above, the annotations @JsonProperty(\u0026quot;name\u0026quot;) and @JsonProperty(\u0026quot;code\u0026quot;) indicate which JSON attributes are used to create an instance of Country. Note that the name of the JSON attribute and the name of the constructor argument can differ (e.g. \u0026ldquo;code\u0026rdquo; and zipCode in this example).\nThese annotations can also be used to populate more complex structures, such as nested objects, arrays, collections, etc. For instance:\npublic class Country { String name; @JsonCreator public Country(@JsonProperty(\u0026#34;name\u0026#34;) String name) { this.name = name; } } String jsonCountries = \u0026#34;[ \u0026#34; + \u0026#34;{\\\u0026#34;name\\\u0026#34; : \\\u0026#34;Italy\\\u0026#34;}, \u0026#34; + \u0026#34;{\\\u0026#34;name\\\u0026#34; : \\\u0026#34;Austria\\\u0026#34;} \u0026#34; + \u0026#34;]\u0026#34;; /* Contains the objects Country{ name: \u0026#34;Italy\u0026#34; } and Country{ name: \u0026#34;Austria\u0026#34; }, in this order. */ Country[] countries = mapper.readValue(jsonCountries, Country[].class); Exercise What does the following program print?\npublic class City { public String name; public Country country; @JsonCreator public City(@JsonProperty(\u0026#34;name\u0026#34;) String name, @JsonProperty(\u0026#34;country\u0026#34;) Country country) { this.name = name; this.country = country; } } public class Country { public String name; @JsonCreator public Country(@JsonProperty(\u0026#34;name\u0026#34;) String name){ this.name = name; } } Country italy = new Country(\u0026#34;Italy\u0026#34;); City rome = new City(\u0026#34;Rome\u0026#34;, italy); City bologna = new City(\u0026#34;Bologna\u0026#34;, italy); City[] cities = new City[]{rome, bologna}; // count countries System.out.println(countCountries(cities)); // serialize String serializedCities = mapper.writeValueAsString(cities); // deserialize City[] deserializedCities = mapper.readValue(serializedCities, City[].class); // count countries System.out.println(countCountries(deserializedCities)); // Counts the number of distinct countries that appear in the input array private int countCountries(City[] cities) { Set\u0026lt;Country\u0026gt; countries = new HashSet\u0026lt;\u0026gt;(); for(City city: cities){ countries.add(city.country); } return countries.size(); } Writing to or reading from a file # The ObjectMapper class provides utility methods to write (resp. read) the JSON output (resp. input) directly to (resp. from) a file. In particular, in the examples above:\nwriteValueAsString(o) can be replaced with writeValue(file, o), readValue(string, class) can be replaced with readValue(file, class). For instance:\n// Serialize try { mapper.writeValue(new File(\u0026#34;path/to/file.json\u0026#34;), rome); } catch (IOException e) { throw new RuntimeException(e); } // Deserialize City myCity; try { myCity = mapper.readValue(new File(\u0026#34;path/to/file.json\u0026#34;), City.class); } catch (IOException e) { throw new RuntimeException(e); } "},{"id":67,"href":"/docs/objects/sections/quasi-objects/","title":"Quasi-objects","section":"Objects and classes","content":" Quasi-objects # Enumerated types # Most imperative languages allow the creation of so-called enumerated types.\nAn enumerated type is a datatype for a finite set or enumerated values. For instance, if our game only allows \u0026ldquo;blue\u0026rdquo;, \u0026ldquo;green\u0026rdquo; and \u0026ldquo;red\u0026rdquo; as unit colors, then we may create a dedicated type that only allows these three values.\nIn Java # An enumerated type in Java is a set of constants. These constants are effectively static, meaning that they depends on the class (or interface) where the enumerated type is declared (similarly to a static attribute). The name of an enumerated type can generally be used like a regular reference type. For instance\npublic class Unit { enum UnitColor {BLUE, GREEN, RED} int health; UnitColor color; public Unit(int health, UnitColor color){ this.health = health; this.color = color; } ... } Note. In the above example, the enumerated type UnitColor could equivalently be represented with an integer. For instance, 0 for blue, 1 for green and 2 for red. However, with such an encoding, a conditional statement (e.g. if or switch) that checks the color of a unit would also need to handle the case of values \u0026lt; 0 or \u0026gt; 2. So (besides readability), a benefit of the enumerated type in this case is that it restricts possible inputs to valid ones.\nHint. Enumerated types in Java are significantly more expressive than their counterparts in some other languages. Notably, a Java enum can have its own constructor and methods.\nRecords # A record is an object whose attributes cannot be modified.\nin Java # Records were introduced in Java 14 (2020). They are a convenient way to avoid boilerplate code. Records provide a concise syntax for \u0026ldquo;lightweight\u0026rdquo; classes that are only meant to hold data.\nFor instance, here is the full implementation of a record City:\npublic record City(String name, int zipCode) {} This record has an implicit constructor, and implements equals, hashcode and toString in the expected way. For instance:\nCity florence = new City(\u0026#34;Florence\u0026#34;, 50100); City florenceAgain = new City(\u0026#34;Florence\u0026#34;, 50100); // Outputs true. System.out.println(florence.equals(florenceAgain)); The attributes of a record cannot be modified. For instance, the following program does not compile:\nCity florence = new City(\u0026#34;Florence\u0026#34;, 50100); florence.zipCode = 50121; A record is often declared inside a class or interface. For instance, in our game:\npublic class Board { public record TileCoordinates(int X, int Y){}; ... } Records are convenient for methods that need to return more than one value. For instance:\nTileCoordinates getOngoingMove(); Strings # Interning # Many modern languages (such as Java, C#, Python, Ruby, JavaScript, Go, etc.) use an optimization technique called interning in order to manage strings (or sometimes integers, etc.) in memory. This consists in storing only one copy of each distinct string created during the execution of a program. These strings are stored in a shared pool, and each of them is an immutable object (meaning that it cannot be modified).\nSome benefits are faster string comparisons, lower memory footprint, etc.\nin Java # In Java, a string is an object. Like for regular objects, comparing two variables of type String with == compares their references:\nString myString = new String(\u0026#34;foo\u0026#34;); String sameString = new String(\u0026#34;foo\u0026#34;); // Outputs false, because the two variables hold different references. System.out.println(myString == sameString); A string can be explicitly interned (i.e. added to the shared pool) with the (instance) method intern. This method:\ntries to add the string to the pool, and then returns a reference to the (only) version of the string contained in the pool. For instance, consider the following program:\n// Creates a string \u0026#34;foo\u0026#34;, String myString = new String(\u0026#34;foo\u0026#34;) // adds it to the pool, myString = myString.intern(); // Creates another string \u0026#34;foo\u0026#34;, String sameString = new String(\u0026#34;foo\u0026#34;); // Outputs false. System.out.println(myString == sameString); // Tries to add \u0026#34;foo\u0026#34; to the pool once again. // Because the pool already contains a version of \u0026#34;foo\u0026#34;, returns a reference to it. sameString = sameString.intern(); // Outputs true, because the two variables now hold the same reference. System.out.println(myString == sameString); A string that is initialized without constructor (i.e. directly with \u0026quot; \u0026ldquo;) is interned. For instance\nString myString = \u0026#34;foo\u0026#34;; String sameString = \u0026#34;foo\u0026#34;; // Outputs true, because of (implicit) interning System.out.println(myString == sameString); In order to support interning, string in Java are immutable.\nIn particular, the instance methods of the class String do not modify the current string, even if the names of some of these methods (substring, replace, etc.) suggest that they do. Instead, these methods (may) return (a reference to) a different object. For instance:\nString foo = new String(\u0026#34;foo\u0026#34;); String copy = foo; // Outputs true, because the two variables hold the same object reference. System.out.println(copy == foo); foo = foo.replace(\u0026#39;o\u0026#39;,\u0026#39;O\u0026#39;); // Outputs false, because the method \u0026#39;replace\u0026#39; returns a reference // to another object. System.out.println(copy == foo); The class String overrides the method equals so that it implements string comparison in the expected way. For instance:\nString myString = new String(\u0026#34;foo\u0026#34;); String sameString = new String(\u0026#34;foo\u0026#34;); // Outputs false. System.out.println(myString == sameString); // Outputs true. System.out.println(myString.equals(sameString)); Hint. By default, you can always use equals to compare the values of two strings. This is less error-prone than == (albeit less efficient if the two strings differ).\nJava boxed types # Java has 8 primitive types: byte, short, int, long, float, double, boolean and char.\nFor each primitive type, Java has a so-called boxed or (wrapper) type: Byte, Short, Integer, Long, Float, Double, Boolean and Character.\nThese types can be used in Java collections (Set, List, etc.), whereas primitive types cannot. Some boxed types also offer additional functionalities, via instance methods (e.g. an Integer can represent a positive numbers up to $2^{32} - 1$.\nConstructors for boxed types are deprecated. Instead, instances can be created via so-called autoboxing, for instance:\nInteger myInteger = 2; Character myCharacter = \u0026#39;a\u0026#39;; Several Java operators (like +, ==, \u0026lt;=, etc.) are also overloaded so that they behave with boxed types as they would with primitive types. For instance:\nInteger i = 1; i += 1; Integer j = 2; // Outputs true System.out.println(i == j); Like strings, instances of boxed types are immutable. This can affect performance. For instance:\nfor (Integer i = 0; i \u0026lt; 1000000 ; i++){ ... } may create up to 1 million objects in memory. This is one of the reasons why it is usually recommended to use primitive types whenever possible (see for instance Effective Java, Item 61). Some boxed types are (partially) interned, analogously to strings.\n"},{"id":68,"href":"/docs/objects/sections/clone/","title":"Duplicating objects","section":"Objects and classes","content":" Duplicating objects # In some scenarios, it may be useful to duplicate an object.\nIn Java, as we saw earlier, copying the value of a variable with reference type does not copy the object that it references. For instance, the following program outputs \u0026ldquo;yellow\u0026rdquo;:\nUnicorn unicorn = new Unicorn(\u0026#34;green\u0026#34;); Unicorn theSameUnicorn = unicorn; unicorn.color = \u0026#34;yellow\u0026#34;; System.out.println(theSameUnicorn.color); The need to duplicate objects may notably appear in a program that relies on concurrency.\nExercise In our game, the \u0026ldquo;view\u0026rdquo; component is in charge of rendering the game visually.\nThis component exposes a method called drawSnapshot that takes as input a game snapshot and draws this snapshot on screen. The backend calls this method whenever a snapshot must be drawn. However, the backend may send these snapshots faster than they can be displayed (due to the duration of on-screen animations).\nTo deal with this scenario, the \u0026ldquo;view\u0026rdquo; buffers the snapshots that it receives (displaying a new snapshot only after all previously submitted ones have been displayed). For the sake of this exercise, you can think of this buffer as an array with type Snapshot[].\nNow consider the following method deleteUnit(int x, int y), executed by our backend each time it receives the instruction to delete a unit:\npublic class Backend implements EventHandler { Snapshot currentSnapshot; ... public void deleteUnit(int x, int y){ // if there is a unit on the tile if(currentSnapshot.getBoard().getUnit(x,y).isPresent()){ removeUnitFromTile(x, y); drawSnapshot(currentSnapshot); shiftUnitsInColumn(x); drawSnapshot(currentSnapshot); performUnitMerges(); drawSnapshot(currentSnapshot); ... } } } where the auxiliary methods removeUnitFromTile, shiftUnitsInColumn and performUnitMerges may modify the object currentSnapshot.\nObserve that the method deleteUnit calls drawSnapshot three times.\nNow let us assume that the buffer of the \u0026ldquo;view\u0026rdquo; is nonempty when this method is executed, so that the 3 snapshots are added to the buffer, before any of them can be rendered on screen.\nHow many of these 3 snapshots will be drawn on screen?\nSolution Only the third snapshot will be drawn (three times), because the buffer contains three references to the same object.\nShallow, deep and hybrid copy # Copying a reference to an object can be viewed as the shallowest possible form of copy. As we saw already, this is what happens in Java when a variable with reference type is passed as argument.\nAt the other end of the spectrum is a so-called deep copy, where all attributes of the copied object are duplicated, recursively. In this case, the copy or any object that it references (recursively) can be modified without affecting their original counterparts.\nBetween these two extremes:\na shallow copy creates a new object (with fresh attributes), but does not copy referenced objects recursively, a hybrid copy is anything between a shallow copy and a deep copy. in Java # Copy constructor # A copy can be performed in Java with a so-called copy constructor. This is an additional constructor that takes an instance of the class as input, and returns a copy of this instance.\nFor example:\npublic class Hero { int health; // standard constructor public Hero(){ this.health = 10; } // copy constructor public Hero(Hero original){ this.health = original.health; } } In order to perform a deep(er) copy, a copy constructor may call another copy constructor. For example:\npublic class Snapshot { Hero firstHero; Hero secondHero; Board board; int remainingActions; // standard constructor public Snapshot(Hero firstHero, Hero secondHero, Board board, int remainingActions){ // some code here ... } // copy constructor public Snapshot(Snapshot original){ this.firstHero = new Hero(original.firstHero); this.secondHero = new Hero(original.secondHero); this.board = new Board(original.board); this.remainingActions = original.remainingActions; } } Warning. Similarly to what we saw with the methods toString or equals, beware of recursive implementations of copy constructors, if your program can create an object that refers to itself (directly or indirectly).\nThe method clone # Java also provides a native method called clone to duplicate objects. Like the methods toString and equals that we saw earlier, clone is an instance method of the native Java class Object, which is an (implicit) superclass of every other class.\nOverriding clone can be more concise than using a copy constructor (especially for a class with a large number of attributes).\nWarning. Overriding clone can be error-prone, especially in presence of a class hierarchy (see Effective Java, Item 13 for further insight). Notably, the overriding class must implement the Cloneable interface (even though this interface has not method!), and an implementation of clone usually calls super.clone recursively (even for a class whose only superclass is Object). For these reasons, overriding clone is sometimes discouraged, in favor of conceptually simpler solutions (like copy constructors).\n"},{"id":69,"href":"/docs/env/sections/eval/","title":"Evaluation environment","section":"Development environment","content":" Evaluation environment # The evaluation environment for your project is a virtual machine (with Ubuntu 20) deployed on Microsoft Azure.\nYou are not supposed to develop on this machine, but your project must run in this environment to be evaluated.\nThe first lab provides instructions to use this virtual environment.\n"},{"id":70,"href":"/docs/labs/env/sections/eval/","title":"Evaluation environment","section":"First lab","content":" Evaluation environment # The evaluation environment for your project is a virtual machine (with Ubuntu 20) deployed on Microsoft Azure. You are not supposed to develop on this machine, but your project must run in this environment to be evaluated.\nEach student gets his or her own clone of the original machine. Maven, Gradle, git and a Java 21 JDK are already installed.\nYou can log in to this machine via ssh (using a terminal), or via RDP (using an RDP client). In the remainder of this section, we will use RDP.\nRDP client # In order to connect via RDP, you need an RDP client.\nHere is a (non-exhaustive) list of RDP clients:\nWindows:\nWindows Remote Desktop (installed by default), also called MSTSC Royal TS macOS:\nMicrosoft Remote Desktop Royal TS Linux:\nRemmina rdesktop Login # The registration link is shared on the Microsoft Team for this course. After logging in (with your Unibz credentials), you should see the following:\nToggling the button (bottom-left) will start your own clone of the virtual machine (this may take a few minutes).\nOnce your machine is running, click on the 3 dots (bottom right) and select \u0026ldquo;show RDP information\u0026rdquo;. This will give you the string (host name and port) needed by your RDP client to connect to the machine.\nThe credentials for logging in to the machine are shared on the Microsoft Team for this course.\nKeyboard layout # Once connected, you can select a keyboard layout (English, German or Italian) from the drop-down menu at the top right of the screen.\nStarting an application # You can use the super key (a.k.a. \u0026ldquo;Windows key\u0026rdquo;) or click on \u0026ldquo;Activities\u0026rdquo; (top left) to display the application menu below.\nTo launch a terminal, click on the terminal icon in this menu or press \u0026ldquo;Ctrl + Alt + t\u0026rdquo;.\n"},{"id":71,"href":"/docs/abstractdatatypes/sections/sorting/","title":"Sorting","section":"Abstract data types","content":" Sorting # Sorting a collection (of values or objects) is needed in a variety of scenarios.\nSorting criterion # In order to sort a collection of values (resp. objects), we need a sorting criterion, i.e. a way to compare two values (resp. objects).\nSome data types come with a natural way to compare two values. For instance, two real numbers can be compared w.r.t. $\\le$.\nObservation. Some data type have several natural sorting criteria. For instance, strings may be sorted alphabetically from left to right (in English, Hindi, Russian, etc.) or from right to left (in Arabic, Hebrew, Persian, etc.).\nQuestion. What about objects, i.e. which sorting criterion can be used to sort a collection of people, cities, sets, lists, trees, etc.?\nAnswer. Any total preorder (i.e. a total, reflexive and transitive binary relation) can be used to sort a collection.\nExercise Which of the following are total preorders (i.e. can be used as a sorting criterion)?\nCompare two real numbers w.r.t. to their absolute value. Compare two people w.r.t. to their age. Compare two people w.r.t. to their age and size, i.e. $\\qquad \\qquad p_1 \\preceq p_2$ iff $\\big(p_1.{\\text{age}} \\le p_2.{\\text{age}}$ and $p_1.{\\text{size}} \\le p_2.{\\text{size}}\\big)$.\nCompare two people w.r.t. to their age or size, i.e. $\\qquad \\qquad p_1 \\preceq p_2$ iff $\\big(p_1.{\\text{age}} \\le p_2.{\\text{age}}$ or $p_1.{\\text{size}} \\le p_2.{\\text{size}}\\big)$.\nCompare two people w.r.t. to their age, and then their size (if they have the same age). Compare two points w.r.t. to their X coordinate, and then their Y coordinate (if they have the same X coordinate). Compare two trees w.r.t. to their number of nodes. Compare two sets w.r.t. to set inclusion. Compare two sets of characters by first sorting each set (by alphabetical order), and then comparing the two resulting sequences lexicographically. Solution is a partial preorder, is not transitive, and is a partial order. The others are total preorders.\nTo see why 4. is not transitive, consider the example:\nPerson Age Height Alice 24 175 Bob 25 160 Carol 21 170 Properties of sorting algorithms # Sorting algorithms have been extensively studied. We will not cover them this semester (with one exception), because this is part of another course of the bachelor.\nWe only highlight some of their properties.\nStability # Definition. A sorting algorithm is stable if it preserves the initial order (in the input collection) of two elements that are equivalent w.r.t. the sorting criterion.\nExample. Consider an array [u1, u2] of type Unit[], where (the objects referenced by) u1 and u2 both have health 2. And let us sort the elements of this array by health.\nA stable sorting algorithm outputs [u1, u2]. A non-stable sorting algorithm may output [u1, u2] or [u2, u1]. In place # Definition. A sorting algorithm is in place if it does not use additional data structures.\nin Java # Comparing # Java provides several native ways to define a sorting criterion (a.k.a. total preorder). We highlight here two of them.\nComparable # A class T can implement the interface Comparable\u0026lt;T\u0026gt;.\nExample. We can create a class City that implements Comparable\u0026lt;City\u0026gt; as follows:\npublic class City implements Comparable\u0026lt;City\u0026gt; { ... } The interface Comparable\u0026lt;T\u0026gt; specifies a single method\nint compareTo (T otherObject); This method should define a total preorder $\\preceq$ over instances of T, as follows.\nLet $o_1$ be the current object (i.e. the instance used to call the method), and let $o_2$ be the other object (i.e. the argument of the method compareTo). Then this method should return:\na negative integer if $o_1 \\prec_o o_2$ (i.e. if $o_1 \\preceq_o o_2$ and $o_2 \\not\\preceq_o o_1$), 0 if $o_1 =_o o_2$ (i.e. if $o_1 \\preceq_o o_2$ and $o_2 \\preceq_o o_1$), a positive integer otherwise. Example (continued). Here is an implementation of the method compareTo where cities are compared by zip code:\npublic class City implements Comparable\u0026lt;City\u0026gt; { public String name; public int zipCode; public City(String name, int zipCode) { this.name = name; this.zipCode = zipCode; } @Override public int compareTo(City otherCity) { return zipCode - otherCity.zipCode; } } Hint. Some native Java classes already implement Comparable, in the expected way. For instance Integer, String (left to right alphabetical order), etc.\nHint. Comparator methods are also available for primitive types (like int, or bool). For instance, Integer has a static method compare(int x, int y) that behaves like compareTo. So the method compareTo in the example above can be simplified as follows:\npublic class City implements Comparable\u0026lt;City\u0026gt; { ... @Override public int compareTo(City otherCity) { return Integer.compare(zipCode, otherCity.zipCode); } } Warning. The method compareTo is implicitly used by some of Java\u0026rsquo;s native data structures (e.g. TreeSet). So it is usually recommended to implement compareTo in such a way that it \u0026ldquo;complies\u0026rdquo; with equals (and hashCode). This means that\n$\\qquad \\qquad $o1.compareTo(o2) should return 0 iff o1.equals(o2) returns true.\nIf you want to use a sorting criterion that does not satisfy this constraint (or if you want to use alternative sorting criteria for the same class), then we recommend using a Comparator instead (explained below).\nComparator # A Comparator in Java is intuitively a total preorder.\nThe Java interface Comparator\u0026lt;T\u0026gt; specifies one method that must be implemented by each instance, with signature:\nint compare(T o1, T o2) The return value (negative integer, 0 or positive integer) has the same meaning as the one of Comparable.compareTo.\nExample (continued). We can create another comparator for our class City, which uses the city\u0026rsquo; name rather than zip code.\npublic class CityNameComparator implements Comparator\u0026lt;City\u0026gt; { @Override public int compare(City c1, City c2) { return c1.name.compareTo(c2.name); } } Note. Observe that in this example, we used the instance method compareTo (described above) implemented in the class String.\nThe interface Comparator also provides convenient (default) methods. For instance, the method thenComparing returns the lexicographic product of two comparators.\nSorting # Java provides several methods to sort an array or collection. We highlight here a few of them.\nSorting an array # For an array of type T[], the static method Arrays.sort(T[] array) can be called as follows:\nExample.\nint[] integers = new integer[]{2,1,3,2}; Arrays.sort(integers) // Outputs [1,2,2,3] System.out.println(Arrays.toString(array)); This method sorts the array using the so-called \u0026ldquo;natural ordering\u0026rdquo; for type T. The \u0026ldquo;natural ordering\u0026rdquo; is:\nthe one expected for primitive types (like int), boxed types (like Integer) and a few other native types (like String or Date); a list can be found here, the one defined by T.compareTo if T implements Comparable, underspecified if T is a class that does not implement Comparable. The method Arrays.sort(T[] array, Comparator\u0026lt;? super T\u0026gt; c) is similar, but it uses the input comparator to sort the array.\nExample(continued).\nCity trento = new City(\u0026#34;Trento\u0026#34;, 38121); City bologna = new City(\u0026#34;Bologna\u0026#34;, 40100); City[] cities = new City[]{trento, bologna}; // After this, the array \u0026#39;cities\u0026#39; contains [bologna, trento] Arrays.sort(cities, new CityNameComparator()); Property. Both methods guarantee stable sorting. For instance:\nCity trento1 = new City(\u0026#34;Trento\u0026#34;, 38122); City bologna = new City(\u0026#34;Bologna\u0026#34;, 40100); City trento2 = new City(\u0026#34;Trento\u0026#34;, 38121); City[] cities = new City[]{trento1, bologna, trento2}; // After this, the array \u0026#39;cities\u0026#39; contains [bologna, trento1, trento2] Arrays.sort(cities, new CityNameComparator()); Note. For an array with primitive type (like int[]), these two methods use (a version of) the Quicksort algorithm, even though Quicksort is not stable. Stability is irrelevant for these types: for instance, permuting the elements of the array [5,5] yields the same array.\nHowever, for an array with (arbitrary) reference type (like City[]), these methods use (a version of) the MergeSort algorithm, which is stable.\nSorting a list # The class Collections provides a static method Collections.sort(List\u0026lt;T\u0026gt; list), whose behavior is analogous to Arrays.sort. In particular, it also guarantees stable sorting. Like Arrays.sort, it comes in two flavors (with and without comparator).\nExample(continued).\nCity bologna = new City(\u0026#34;Bologna\u0026#34;, 40100); City trento = new City(\u0026#34;Trento\u0026#34;, 38122); List\u0026lt;City\u0026gt; cities = new LinkedList(); cities.add(bologna); cities.add(trento); // After this, the list \u0026#39;cities\u0026#39; contains [trento, bologna], // due to the way \u0026#39;City\u0026#39; implements \u0026#39;compareTo\u0026#39;. Collections.sort(cities); // After this, the list \u0026#39;cities\u0026#39; contains [bologna, trento], Collections.sort(cities, new CityNameComparator()); The interface List also provides a default method sort that takes a comparator as argument. So in the above example, we could have used:\ncities.sort(new CityNameComparator()); instead of\nCollections.sort(cities, new CityNameComparator()); Usage # Exercise Consider the following class:\npublic class Hero { String name; int health; public Hero(String name, int health){ this.name = name; this.health = health; } } Write a Java method void printHeroesOcc(Hero[] heroes) that takes as input an array of type Hero[], and prints the number of occurrences of each hero in this array, where two heroes are considered identical if they have the same name and health.\nConstraint. For this exercise, you cannot use an associative array (a.k.a. Java Map).\nPossible solution Create a comparator (compare first by health, then by name):\npublic class HeroComparator implements Comparator\u0026lt;Hero\u0026gt; { @Override public int compare(Hero h1, Hero h2) { int healthComparison = Integer.compare(h1.health, h2.health); return healthComparison != 0 ? healthComparison : h1.name.compareTo(h2.name); } Sort the array and iterate over it to count the number of occurrences of each hero:\nvoid printHeroesOcc(Hero[] heroes) { if (heroes.length == 0) { return; } Comparator\u0026lt;Hero\u0026gt; comparator = new HeroComparator(); // sort the input array w.r.t. to the comparator Arrays.sort(heroes, comparator); // keeps track of the last hero seen so far Hero previousHero = heroes[0]; // occurrences of the last hero seen so far int occ = 1; // iterate over the array, starting fom the second hero for (int i = 1; i \u0026lt; heroes.length; i++) { // if the current hero and the previous one have the same // name and amount of health if (comparator.compare(previousHero, heroes[i]) == 0) { occ++; } else { printHero(previousHero, occ); previousHero = heroes[i]; occ = 1; } } printHero(previousHero, occ); } private void printHero(Hero hero, int occ) { System.out.println(hero.name + \u0026#34;,\u0026#34; + hero.health + \u0026#34;: \u0026#34; + occ); } Note. The solution to the exercise above relies on sorting the input array. But the same problem could be solved with an associative array, as follows:\noverride equals and hashCode in the class Hero, compute a Map\u0026lt;Hero, Integer\u0026gt; that maps each hero to its number of occurrences in the input array, iterates over the entries of this map and print them. When it comes to running time, the latter solution is more efficient on average (assuming a hash map), but less efficient in the worst case.\n"},{"id":72,"href":"/docs/input/","title":"I/O and serialization","section":"Docs","content":" I/O and serialization # This chapter mostly focuses on Java.\nIt provides (mostly syntactic) information about:\nnavigating or manipulating files and directories, reading from and writing to a file, property files, serializing (and deserializing) a Java object, either natively, or as a JSON object (via Jackson). "},{"id":73,"href":"/docs/env/sections/terminal/","title":"Terminal","section":"Development environment","content":" Terminal # Using a terminal can be necessary during development, in order to execute a program that does not have a graphical user interface (GUI).\nBut even when a GUI is available, a Command Line Interface (CLI) can still be the preferred way to interact with some programs. Possible benefits are:\nefficiency (thanks to autocompletion, there is very little to type), automation (via scripting), more transparency (a GUI may add a layer of obfuscation), stability over time (GUIs tend to change from one version of a program to another), a wider range of available actions (a GUI may allow you to execute a limited set of commands only), reproducibility (the same command performs the same action, with a limited reliance on memory), customizability. Shell # A shell interprets command typed in a terminal. It can also interpret programs (usually called scripts).\non Linux # The default shell on most Linux distributions is bash.\non macOS # The default shell on macOS is zsh. It extends bash with modern features (notably customization options, via plugins).\non Windows # Windows comes with two shells by default:\na (mostly) legacy shell called Command Prompt, a more modern shell called Windows PowerShell. Warning. PowerShell is a closely related (cross-platform) shell developed by Microsoft. It is not fully compatible with Windows PowerShell (they are currently meant to \u0026ldquo;coexist\u0026rdquo;).\nOther shells are commonly used by Windows developers that offer a (possibly partial) Linux-like shell experience. Popular options include:\ngit bash (often used to learn git), Cygwin, WSL, whose latest version runs a full (Arch) Linux virtual machine. Autocompletion # Modern shells provide at least two types of command autocompletion:\ncompletion based on your command history, and smart completion (a.k.a. \u0026ldquo;Tab-completion\u0026rdquo;) for possible arguments, paths, etc. As a result, using a terminal requires very little typing.\nBy default, autocompletion may not be activated (or installed) on your machine. We will see how to do it during the first lab.\n"},{"id":74,"href":"/docs/labs/env/sections/demo/","title":"Using a terminal (demo)","section":"First lab","content":" Using a terminal (demo) # The following demo is meant to (quickly) illustrate some benefits of a properly configured terminal, as well a few terminal-based applications.\nThis is not an introduction to bash or Linux core utilities.\nVirtual environment # For this demo, we deployed a virtual machine with a pre-configured terminal.\nThe instructions for connecting to this machine are identical to the one for the project evaluation environment.\nOnce you are connected to the virtual machine, you can follow the instructions below.\nWarning. The demo below is not meant to be executed with your own terminal. In particular, some software is needed that may not be installed on your computer.\nCreating a static website # As an exercise, we will create a static website, using a simple framework called Hugo.\nFirst, in our home folder, let us create a subfolder dedicated to our projects. For instance, we can call this subfolder workspace. To create this folder, open a terminal and run:\nmkdir workspace Then navigate to this folder with the command cd (you do not need to type the full name of the directory, just type cd w, and press the Tab key for autocompletion):\ncd workspace Next, we will (loosely) follow the quick start tutorial for Hugo. Explanations about some of the command below can be found here.\nCopy-paste the following instruction and press Enter:\nhugo new site mySite This will create a project in a fresh folder called mySite. Let us navigate to it (again, you can take advantage of autocompletion):\ncd mySite Now copy-paste the following commands to declare this folder as a git repository and download a graphical theme for our website:\ngit init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml Navigation # At any moment, you can run the command:\npwd to display the current directory. With this command, you can check that you are indeed in the folder mySite.\nTo get a overview of the content of the current folder, run:\nll To get a recursive overview of the content of this folder, run:\ntree In order to navigate to a certain subfolder in this tree, we can take advantage of the fuzzy finder. For instance, let us assume that we want to move to some folder called socials, but we forgot its exact path.\nRun:\nc This will display the paths to all directories in this tree. You can type characters to restrict your search, and use the up down arrow keys to select your destination. For instance, type the three character soc. The best matches are displayed at the bottom of the list. To select one of them, navigate up and down with the arrow keys and press Enter.\nNote. Thanks to fuzzy search, the characters that you type do not need to be contiguous in a path. For instance, when you typed soc, all paths containing these three letters (in that order, but not necessarily contiguous) were retained.\nNow let us navigate back to the mySite folder. Here we can use zoxide, which uses our path navigation history to allow faster navigation. Run:\nzi and then type (the beginning of) mySite.\nSimilarly, to go back to the socials subfolder that we previously went to, run:\nzi again and type (the beginning of) socials.\nAlternatively, you can switch between your current location and the previous one (thanks to zoxide still) with:\nzz Starting the web server # Navigate (back) to the mySite folder (you should know how to do this by now), and run:\nhugo server This will start a local development server for our website. To visualize the site, open Firefox (from the app menu), and use the address displayed in the terminal (it should be http://localhost:1313/)\nTo stop the server (or any Linux process running in a terminal), go back to the terminal an press Ctrl+C.\nNext, we will add content to our website, while keeping the server running.\nTo restart the server, we can use our command history. Type the first letters of the command that we used above to start the serve (e.g. hu). By pressing the up and down arrow keys, you can scroll through the commands that you already typed and start with these letters. Scroll until you find the command hugo server, and press Enter to restart the server.\nIn order to keep the server running, we will execute our next command in another terminal. You can create a new one by clicking on the boxed \u0026ldquo;+\u0026rdquo; icon:\nAdding content # Navigate to the (immediate) subfolder content of mysite. Then create a subfolder named posts:\nmkdir posts Navigate to this new folder. Then create a new text file called myPost.md. You can for instance do this with the command:\ngedit myPost.md which will open a new file with this name in the text editor \u0026ldquo;gedit\u0026rdquo;.\nNote. If you only type ge followed by Tab, the shell will suggest you a list of programs whose name starts with these letters. You can scroll through them by pressing Tab again, or add a letter to disambiguate your search.\nIn the text editor, copy-paste the following content:\n+++ title = \u0026#39;My First Post\u0026#39; date = 2024-01-14T07:07:07+01:00 +++ ## Introduction This is **bold** text, and this is *emphasized* text. ### Subsection This is a [link](https://gohugo.io) to the Hugo website. In this file, everything below the header (title/date) is written in Markdown.\nSave the file, and check with Firefox that your first post has been added to your website.\nWarning. To see your changes, you may need to force Firefox to clear its cache: in \u0026ldquo;Settings | Privacy \u0026amp; Security | Cookies and Site Data\u0026rdquo;, click on the \u0026ldquo;Clear Data\u0026rdquo; button.\nIf this does not work, then you can stop and restart the Hugo server, as explained above.\nAliases # The command c that we used above is an alias for a more complex command, namely cd $(find * -type d | fzf)\nWe declared this alias in the file ~/.zshrc (remember that ~ is a shortcut for your home folder).\nLet us open this file to see the declaration of this alias. Navigate to your home folder, for instance with:\ncd And list its content:\nll The file .zshrc should be there. Open this file with gedit:\ngedit .zshrc Note. Again, you can take advantage of autocompletion here. For instance, press ged followed by Tab followed by .z followed by Tab.\nTowards the end of this file, you will see the declaration of the alias:\nalias c=\u0026#39;cd $(find * -type d | fzf)\u0026#39; Let us create another useful alias. Ubuntu has a convenient command called xdg-open that opens a file with the default application associated to this file\u0026rsquo;s extension (this is the equivalent of a double-click in a graphical file browser). Let us set a simpler name than xdg-open to execute this command. For instance o (like \u0026ldquo;open\u0026rdquo;).\nFirst, let us check that the name o is not used already for another command. Open a new terminal and run:\no You should get a \u0026ldquo;command not found\u0026rdquo; message, which confirms that this command is free.\nNow let us add the following line to the .zshrc file:\nalias o=\u0026#39;xdg-open\u0026#39; Save the file and open a new terminal.\nYou can now use the o command to open any file.\nTo see this, let us navigate back to the socials folder that we were previously in (e.g. using zi, as explained above). If you list the files in this folder (with ll), then you will see that they have the .svg extension. To open one of these files, you can type o and the first letters of the name of the file, then Tab for autocompletion. This will open the file with the default image viewer application on this machine.\nScripts # If you want to use an alias to execute a (possibly complex) sequence of commands, then the preferred way is to write a script.\nFor instance, we could write a script that navigates to the mySite folder and then starts the hugo server. And we may use the alias ws (like \u0026ldquo;website\u0026rdquo;) to call this script (you can check that it is free).\nNavigate to the ~/bin folder, and create a text file called ws (for instance with gedit, as we did above for the post).\nIn this file, copy-paste the following:\n#! /bin/bash cd ~/workspace/mySite hugo server start Observe that these are the two instructions for the two tasks that we want to execute. Save the file, and make it executable by running:\nsudo chmod u+x ws To test your script, close all running instances of hugo (if any), e.g. with Ctrl + C, as explained above.\nNow regardless of your location, you can type ws to start the web server.\nNote. Linux shells (such as bash or zsh) support the same language for commands and scripts. This is a full-fledged programming language (with conditional statements, loops, etc.), where an instruction can also be a command.\nTerminal-based applications # To conclude the demo, we introduce a few convenient applications that run in a terminal. These may save you time (compared to similar applications that rely on a GUI).\nripgrep # ripgrep allows you to search files that contain certain words or regular expressions (your IDE offers a similar functionality). For instance, let us assume that we want to search for all files under mySite that contain the string \u0026ldquo;Canada\u0026rdquo;.\nNavigate to the mySite folder. Then run:\nrg Canada This will display the path to each (text) file that contains this word (in this example, there is only one match), and the corresponding line numbers.\nranger # ranger is a popular terminal-based file browser.\nTo open it, type:\nranger You can navigate within the current directory with the up and down arrow keys, and in the directory tree (from child to parent and conversely) with the left and right arrow keys. Note that it also displays previews of text files.\nTo quit ranger, you can press the letter q.\nhtop # htop allows you to monitor processes running on your machine. To open it, type:\nhtop The upper part of the interface displays memory and CPU usage, whereas the lower part displays running process (sorted by CPU usage by default). You can kill a process with F9.\nTo quit htop, you can press the letter q.\nncdu # ncdu allows you to visualize the amount of disk space taken by your files and programs.\nTo open it, type:\nncdu The folders and files in the current folder are sorted by disk space, and you can navigate the directory tree using the arrow keys (like with ranger).\nTo quit ranger, you can press the letter q.\n"},{"id":75,"href":"/docs/objects/sections/encapsulation/","title":"Encapsulation","section":"Objects and classes","content":" Encapsulation # Encapsulation is a (vague) principle in object-oriented programming that refers to \u0026ldquo;bundling\u0026rdquo; data with the code that operates on it, and restrict access to this code and data from other components of a system.\nFrom Wikipedia: \u0026ldquo;Essentially, encapsulation prevents external code from being concerned [\u0026hellip;]\u0026rdquo;\nEach component hides its internal logic by exposing only data and methods that other components may need.\nExample. As we saw earlier, in our game, the \u0026ldquo;view\u0026rdquo; component (which is in charge of rendering the game on screen) may buffer the game snapshots that it receives from the backend, if these snapshots are received faster than they can be displayed.\nAs a buffer, this component uses a structure called a queue. This queue is not exposed to other components, because they do not need to see it, and (most importantly) should not modify it. In other words, this queue is an implementation detail, internal to the \u0026ldquo;view\u0026rdquo; component.\nEncapsulation can have many benefits. Among others:\nEasier debugging. If our queue is internal to the \u0026ldquo;view\u0026rdquo; component, then we know that it cannot be responsible for the malfunction of another component. Easier collaboration. Carol may refactor the implementation of the \u0026ldquo;view\u0026rdquo; component, knowing that this will not affect Alice, who is currently working on the backend. This is why a common practice in object-oriented programming consists in hiding all attributes and methods of a new class by default. And make accessible only the ones that need to be (in particular, this is likely to be the default behavior of your IDE).\nEncapsulation also largely dictates how libraries are structured. For instance, when you create a String in Java, you do not have access to the internal representation of the string object.\nin Java # Each attribute or method of a class can have an access modifier, which specifies which other classes can access it. For instance, the keywords private and protected below are access modifiers.\nprivate int myAttribute; protected int myMethod(){ return 1; } Definition. There are four levels of access in Java:\nprivate restricts access to the current class, \u0026ldquo;package-private\u0026rdquo; relaxes private by also allowing access from the folder of the current class (in Java, a folder for source code is called a package), excluding subfolders, protected relaxes \u0026ldquo;package-private\u0026rdquo; by also allowing access from the subclasses of the current class, public does not restrict access. Warning. There is no keyword for the \u0026ldquo;package-private\u0026rdquo; level. Instead, this is the default level for an attribute or method without access modifier. For instance, in the example below, the attribute myAttribute is package-private:\nint myAttribute; Here is a recap table from the Oracle tutorials:\nkeyword class package subclasses world private yes no no no none yes yes no no protected yes yes yes no public yes yes yes yes Warning. A method declared in an interface is (implicitly) public.\nWarning. If a method m1 overrides (or implements) a method m2, then m1 must be at least as accessible as m2.\nExercise The following program does not compile. Can you see why, and how to fix this?\nâââ Run.java âââ units âââ Unit.java âââ impl âââ Unicorn.java public abstract class Unit { static String configFolder = \u0026#34;path/to/config\u0026#34;; } public class Unicorn extends Unit { String name; public Unicorn (String name){ this.name = name; } public static String getConfigFilePath (){ return configFolder + \u0026#34;/unicorn.properties\u0026#34;; } } public class Run { void testUnicorn(){ Unicorn myUnicorn = new Unicorn(\u0026#34;Storm\u0026#34;); myUnicorn.name = \u0026#34;Tornado\u0026#34;; } } Solution Unicorn.getConfigFilePath tries to access the package-private attribute Unit.configFolder (it should be made protected of public), Run.getConfigFilePath, tries to access the package-private attribute name of myUnicorn (it should be made public). Hint. Your IDE may suggest how to fix such compilation errors.\nTo improve encapsulation, it is good practice to restrict access whenever possible (i.e. without compromising compilation).\nHint. As a rule of thumb, in Java:\nuse private by default for all attributes and methods that you create, and if the program does not compile, then use your IDE to relax access. Exercise Encapsulation in this program can be improved. Can you see how?\nâââ Run.java âââ units âââ Unit.java âââ impl âââ Unicorn.java public abstract class Unit { public int health; public Unit(int health) { this.health = health; } public void attack(Unit defender){ health -= defender.health; defender.health = -health; } } public class Unicorn extends Unit { public Unicorn (){ super(1); } @Override public void attack(Unit defender){ regen(); super.attack(defender); } public void regen(){ health += 1; } } public class Run { void testUnicorn(){ Unicorn u1 = new Unicorn(); Unicorn u2 = new Unicorn(); u1.attack(u2); } } Solution Unit.health can be made protected, the constructor of Unit can be made protected, Unit.attack can be made protected, Unicorn.regen can be made private. Note. The constructor of an abstract class can always be made protected (since it can only be called in the constructor of a subclass).\nGetters and setters # For attributes, the notion of \u0026ldquo;access\u0026rdquo; can be refined. An attribute may be:\nneither visible nor modifiable, or only visible, or only modifiable, or both visible and modifiable. This can be achieved with private attributes and so-called \u0026ldquo;getter\u0026rdquo; and \u0026ldquo;setter\u0026rdquo; methods. For instance, in the following class, the attribute health has public visibility but is not modifiable.\npublic class Unicorn { private int health; public int getHealth(){ return health; } } Conversely, in the following class, the attribute health can be modified but is not visible.\npublic class Butterfly { private int health; public void setHealth(int health){ this.health = health; } } Hint. Getter and setter methods can be automatically generated by your IDE.\nTo go further: inheritance and encapsulation # Composition # Example (from Effective Java, Item 18).\nConsider a class MyHashSet that extends Java\u0026rsquo;s HashSet functionalities by keeping track of the number of times something has been added to the set (as opposed to the output of HashSet.size(), which returns the number of elements remaining in the set).\nThis class myHashSet may have a private attribute int counter (initialized to 0) that keeps track of the number of elements added to the set so far. And the class may be implemented by overriding add and addAll in the expected way, i.e.:\npublic class MyHashSet extends HashSet { private int counter; ... @Override public boolean add(E e){ counter++; return super.add(e); } @Override public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c){ counter += c.size(); return super.addAll(c); } } However, this implementation of addAll would count every insertion twice, because the implementation of HashSet.addAll calls the method add (which is overridden in this case).\nA design pattern called composition can be used to avoid such unintended effects. Intuitively, instead of extending the original class, use an instance of the original class as a (private) attribute of the new class (e.g. an instance Hashset named set in this example). However, this requires re-implementing all methods of the original class (albeit in a straightforward way), for instance:\npublic class MyHashSet { public boolean isEmpty(){ return set.isEmpty(); } } Prevent overriding or inheritance # As show by the example above, in order to improve encapsulation, one may want in some scenarios to forbid overriding a method or extending a class. In Java, this can be enforced with the keyword final, for instance:\npublic final class NonExtensibleClass { ... } public class MyClass{ public final void nonOverridableMethod(){ ... } } Warning. In Java, a variable can also be declared final. But this has a different meaning.\n"},{"id":76,"href":"/docs/git/sections/resources/","title":"To go further","section":"git","content":" To go further # Here is a brief selection of resources about git (among many):\na (short) video that goes beyond the content of this chapter, the Atlassian git tutorials, the GitHub training material, guidelines about how to write an informative (yet readable) commit message. Misc # Here is a link to git\u0026rsquo;s very first commit.\n"},{"id":77,"href":"/docs/intro/sections/quiz/","title":"Quiz","section":"This course","content":" Quiz # To answer the quiz (and check your answers), click here or scan this code:\nWe reproduce below the questions, for readability.\nHierarchical file system # On most modern computers, for a given user:\nthe desktop is a directory the desktop is the home directory the desktop is a sub-directory of the home directory the desktop is the root of the hierarchical file system the home directory is the root of the hierarchical file system the home directory may contain hidden files files outside of the home directory are hidden every file has an absolute path a file may have multiple absolute paths two files may share an absolute path an absolute path can contain .. Sets # Which of these are sets?\n\\( \\{a, b\\}\\) \\( (a, b) \\) \\( \\{a, b, a\\}\\) \\(\\{\\}\\) \\( \\{\\{a\\}\\} \\) \\( \\{\\{\\}\\} \\) \\((())\\) \\(\\{()\\}\\) \\(((a, b))\\) \\(\\{(a, b)\\}\\) \\(\\{(a, b), (c, d)\\}\\) \\(\\{(a, b), (a, b)\\}\\) \\(\\{(a, b), (b, a)\\}\\) \\(\\{\\{a\\}, \\{\\}\\}\\) \\((\\{a\\}, \\{\\})\\) \\(\\{\\{a\\}, \\{a\\}\\}\\) \\(\\{\\{a\\}, \\{a\\}, \\{b\\}\\}\\) \\(\\{\\{a, b\\}, \\{a\\}\\}\\) \\(\\{\\{a, b\\}, \\{b, a\\}\\}\\) \\(\\{\\{a, b\\}, \\{b, a\\}, \\{c\\}\\}\\) If $S$ is a finite set of size $n$, then the set of all subsets of $S$ has size:\n$0$ $n/2$ $n$ $n^2$ $2^n$ $n^n$ infinite I do not know the answer Trees # How many nodes in this picture are the root of a tree?\n$0$ $1$ $2$ $3$ $4$ $6$ $10$ infinitely many Boolean expressions\nThe boolean expression\n!( !( !(x = 5) \u0026amp; y \u0026lt;= 2) | z \u0026lt; 1) is equivalent to:\nx != 5 \u0026amp; y \u0026gt; 2 \u0026amp; z \u0026gt;= 1 x != 5 \u0026amp; y \u0026lt;= 2 \u0026amp; z \u0026gt;= 1 x != 5 | y \u0026gt; 2 | z \u0026gt;= 1 x != 5 | y \u0026lt;= 2 | z \u0026gt;= 1 x = 5 | y \u0026lt;= 2 | z \u0026gt;= 1 (x != 5 | y \u0026lt;= 2) \u0026amp; z \u0026gt;= 1 x != 5 | (y \u0026lt;= 2 \u0026amp; z \u0026gt;= 1) (x != 5 \u0026amp; y \u0026lt;= 2) | z \u0026lt; 1 (x = 5 \u0026amp; y \u0026lt;= 2) | z \u0026lt; 1 x = 5 \u0026amp; (y \u0026lt;= 2 | z \u0026lt; 1) I do not know the answer Java # In order to be executed, a Java program must be:\ncompiled interpreted either compiled or interpreted both compiled and interpreted neither compiled nor interpreted I do not know the answer What does the following Java program print?\nint a = 0; int b = 1; myMethod(a, b); System.out.println(a); System.out.println(b); void myMethod(int firstInteger, int secondInteger) { secondInteger = firstInteger; firstInteger = secondInteger; System.out.println(firstInteger); System.out.println(secondInteger); } a, b, 1, 0 a, b, 0, 0 1, 0, a, b 0, 0, a, b 1, 0, 1, 0 1, 0, 0, 1 0, 0, 0, 1 0, 0, 0, 0 0, 1, 1, 0 0, 1, 0, 0 Algorithm # Consider the following method (written in pseudocode).\nboolean myMethod(int x){ if (x == 0){ return true } if (x \u0026lt; 0){ return false } return myMethod(x - 3) } This method:\nis recursive may not terminate returns true iff x is a positive multiple of 3 returns true iff x is a positive power of 3 returns true iff x is a Fibonacci number returns true iff x is a multiple of the third Fibonacci number returns true iff x is a power of the third Fibonacci number returns true iff x is smaller than 2^3 returns true iff x is smaller than 9 returns true iff x is smaller than 3! "},{"id":78,"href":"/docs/env/","title":"Development environment","section":"Docs","content":" Development environment # As a developer, you will interact with a computer in ways that you may not be used to. You will often need a level of control and transparency that is not provided by regular (\u0026ldquo;phone-like\u0026rdquo;) or web applications.\nThis may include finer-grained control over:\nwhere a file is created or downloaded, when a program is updated, which commands are executed, etc. This chapter gives a brief overview of notions and tools that you will need to be familiar with, for this course and/or further programming activities.\nBuilding automation tools (such as Maven or Gradle) have their dedicated chapter, and so does git.\n"},{"id":79,"href":"/docs/git/","title":"git","section":"Docs","content":" Git # Git is a so-called distributed version control system, originally co-authored by Linus Torvalds to facilitate the development of the Linux kernel.\nIt was first released in 2005, and has become ubiquitous in software development. For instance, 93.87% of respondents to the 2022 Stack overflow survey declared using it.\nGit allows synchronizing the content of a directory (called a repository) across several machines. Notably:\neach machine contains a copy of the repository and its full history, git allows parallel histories to coexist (in so-called branches), and provides ways to reconcile them. Warning. Git is not suited to large datasets (more than 1 GB).\nScope of this chapter # Git has almost 150 commands, each of which may be called with multiple options. But in practice, most users use a handful of these commands on a regular basis.\nThis chapter only provides a basic introduction and a minimal set of commands, which you are likely to need during the development of you project. Additional resources can be found here.\nTerminology # A difficulty when discovering with git may be it terminology. Here is a very approximative map from git concepts to terms that you are familiar with:\nGlossary.\na repository: a directory (more exactly, the root directory of a project) a remote server: a non-local server (typically on the cloud) to clone: to copy (a repository) to commit: to save to push: to upload (to a remote server) to fetch: to download (from a remote server) a branch: an alternative history (in your favorite time-travel novel/series/movie) to merge: to reconcile two branches CLI or GUI # Many Graphical User Interfaces (GUI) are available for git, and many programs (e.g. probably your IDE) provide some form of git integration.\nHowever, git is mostly used (and almost exclusively taught) via its Command Line Interface (CLI). In addition, the documentation and help that you may find online overwhelmingly relies on its CLI.\nPossible explanations are efficiency (autocompletion, aliases, scripts, etc.), transparency, reproducibility, stability over time, etc.\nIf you use git via CLI, then we recommend using a modern shell for command autocompletion.\nIf you want a flavor of how a terminal can be configured (for git and other purposes), then you can follow the demo of the first lab.\nHosting service # To collaborate via git and/or back up your repositories, you need to use a git hosting service.\nPopular options are GitHub, Gitlab or Bitbucket.\nThe Unibz also offers a self-hosted Gitlab service.\n"},{"id":80,"href":"/docs/build/","title":"Build automation","section":"Docs","content":" Build automation # Building a piece of software means converting source code into a program that can be executed.\nBuilding a program may consists of many subtasks:\ngenerating code, compilation, linking, unit tests, file compression, generating documentation, creating an executable or an installer, integration tests, deployment, etc. Each of these subtasks may be performed numerous times during the development of a program. So it is natural to automate the build.\nA build automation tool is meant to facilitate the configuration of these tasks, and execute them automatically, typically as (one or several) \u0026ldquo;pipeline(s)\u0026rdquo;.\nFor instance, Maven is a build automation tool for Java. A Maven project is often build with a single command:\nmvn package Other popular build automation tools include:\nMake, CMake or Ninja for C/C++, MSBuild for C#, Grunt or Gulp for Javascript, Gradle (multi-language), sbt for scala etc. Note. Some subtasks of a build may be performed on a server (e.g. each time a developer pushes a git branch), as part of a process called continuous integration (CI). Popular frameworks to set up a CI server include Jenkins and Travis CI. CI is beyond the scope of this course.\nin Java: Maven vs Gradle # The two most popular build automation tools for Java are Maven and Gradle.\nBoth also act as package managers for Java libraries.\nMaven is slightly older (2004 vs 2008), and influenced the design of Gradle.\nMaven # Maven is (still?) more widely used than Gradle. It also has a gentler learning curve.\nIn particular, Maven relies on a number of implicit conventions (e.g. for directory layout). For a simple project, this often results in a quicker set up than with Gradle (but makes advanced customization more involved).\nDue to the popularity of Maven, some of these conventions (e.g. directory layout and artifact naming) have also been adopted in other contexts.\nAdditional strengths of Maven are:\nexcellent integration with IDEs, a vast ecosystem of plugins. A common criticism of Maven is the use of XML files to specify a project\u0026rsquo;s build, which can be verbose and difficult to parse (for a human being).\nIn this course. For simplicity, this chapter (mostly) focuses on Maven. In addition, the content is restricted to the bare minimum (i.e. what you are likely to need for your project).\nFor a more thorough introduction to Maven, a good entry point is the official getting started guide.\nGradle # Gradle is a multi-language build automation tool. Among others, it offers support for project written in Java and its main derivatives (Groovy, Kotlin and Scala), C/C++ and Javascript. Gradle has been selected by Google as the official build automation tool for Android applications.\nGradle has a more concise syntax than Maven (precisely two: one is a Groovy Domain Specific Language (DSL), the other is a Kotlin DSL). Re-building a project can also be faster with Gradle than than with Maven, thanks to more advanced caching strategies. Another strength of Gradle is its flexibility : a build can be easily customized, whereas Maven relies on conventions that can be hard to bypass.\nGradle is often considered more difficult to learn than Maven, especially for new programmers. Its syntax is also less stable (older project configurations need to be updated to comply with more recent releases).\nNote. If you chose the board game as your project, then you will use Gradle (at least by default).\nThe build is already configured. By default, you do not need to modify it, except maybe to declare dependencies.\n"},{"id":81,"href":"/docs/background/","title":"Background","section":"Docs","content":" Background # This chapter gathers basic notions that are used throughout other chapters.\n"},{"id":82,"href":"/docs/git/sections/ignore/","title":"Ignore","section":"git","content":"\u0026mdash;\u0026ndash; weight: 10 title: \u0026ldquo;Ignoring files\u0026rdquo; draft: false\nIgnoring files # You can add a file named .gitignore to the root folder of your repository.\nIt specifies files that cannot be staged.\nThis is commonly used to exclude from a repository:\ncompiled code (e.g. files with the extension .class in Java), dependencies (e.g. the content of the /node_modules folder in a Node.js project), IDE-generated files (e.g. the .idea/ folder for IntelliJ), OS-generated files (e.g. .DS_Store/ folders for macOS), etc. The .gitignore file uses a dedicated syntax to specify which files should be excluded.\nFor instance the pattern *.class excludes all files with the extension .class.\nHere is a quick tutorial about the syntax of .gitignore files.\nThis repository also contains a large collection of .gitignore patterns, for different programming languages, operating systems, programs, etc. For instance Java, Maven, VSCode, IntelliJ, Windows, macOS, Linux, etc.\n"},{"id":83,"href":"/docs/labs/env/","title":"First lab","section":"Docs","content":" First lab: working environment # Terminal and text editor Shell autocompletion Installing software with a package manager ssh key Default text editor for git Evaluation environment Using a terminal (demo) "}]