[{"id":0,"href":"/docs/simplify/sections/factorization/","title":"Factorizing","section":"Simplifying code","content":" Factorizing # Duplicate code # Duplicate code within a same project has undesirable consequences. In particular:\nDuplicate code means duplicate bugs. The application may be harder to extend: adding a new feature may require modifying several nearly identical copies of the same method and/or class. Factorizing # By code factorization, we mean eliminating duplicate statements or expressions, by analogy to the factorization of an algebraic expression (e.g. ab + ac can be rewritten a(b+c)).\nThis usually comes down to simple techniques. We illustrate here a few of them.\nConditional statement # Exercise Factorize the following program:\nif(\u0026lt;condition 1\u0026gt;){ \u0026lt;code block 1\u0026gt; \u0026lt;code block 3\u0026gt; } else if(\u0026lt;condition 1\u0026gt; \u0026amp;\u0026amp; \u0026lt;condition 2\u0026gt;){ \u0026lt;code block 1\u0026gt; \u0026lt;code block 2\u0026gt; \u0026lt;code block 3\u0026gt; } else { \u0026lt;code block 3\u0026gt; } Solution if(\u0026lt;condition 1\u0026gt;){ \u0026lt;code block 1\u0026gt; if(\u0026lt;condition 2\u0026gt;){ \u0026lt;code block 2\u0026gt; } } \u0026lt;code block 3\u0026gt; Auxiliary method # Exercise Factorize the following Java class:\npublic class Extractor { String extractId(String text){ Matcher matcher = Pattern.compile(\u0026#34;^[A-Z]?\\\\d+\u0026#34;).matcher(text); return matcher.find()? matcher.group(0): null; } String extractSSN(String text){ Matcher matcher = Pattern.compile(\u0026#34;SSN:(\\\\d+)\u0026#34;).matcher(text); return matcher.find()? matcher.group(1): null; } } Possible solution public class Extractor { String extractId(String text){ return getFirstMatch(text, \u0026#34;^[A-Z]?\\\\d+\u0026#34;, 0); } String extractSSN(String text){ return getFirstMatch(text, \u0026#34;SSN:(\\\\d+)\u0026#34;, 1); } String getFirstMatch(String text, String regex, int group){ Matcher matcher = Pattern.compile(regex).matcher(text); return matcher.find()? matcher.group(group): null; } } Abstract class # Exercise Factorize the following Java classes:\npublic class Unicorn extends Unit { public void wait(){ \u0026lt;code block 1\u0026gt; \u0026lt;code block 2\u0026gt; } } public class Buttterfly extends Unit { public void wait(){ \u0026lt;code block 1\u0026gt; \u0026lt;code block 3\u0026gt; } } public class Wall extends Unit { public void wait(){ \u0026lt;code block 4\u0026gt; } } Possible solution public abstract class MobileUnit extends Unit { public abstract void wait(){ \u0026lt;code block 1\u0026gt; } } public class Unicorn extends MobileUnit { @Override public void wait(){ super.wait(); \u0026lt;code block 2\u0026gt; } } public class Buttterfly extends Unit { @Override public void wait(){ super.wait(); \u0026lt;code block 3\u0026gt; } } public class Wall extends Unit { public void wait(){ \u0026lt;code block 4\u0026gt; } } "},{"id":1,"href":"/docs/intro/sections/schedule/","title":"Schedule","section":"This course","content":" Schedule # The course consists of 60 hours of lectures and 30 hours of labs.\nLectures # By default, lectures are scheduled:\nMonday 13:30 - 15:30 Tuesday 08:30 - 10:30 Wednesday 08:30 - 10:30 All students attend the same lectures.\nLabs # By default, labs are scheduled:\nMonday 15:30 - 17:30 Wednesday 13:30 - 15:30 Students are split in two groups (to be determined) for the labs, with identical content. Students who collaborate on the same group project are expected to attend the same lab.\nMost labs will be dedicated to the assignments for this course. Two labs will be dedicated to a presentation and discussion of the advancement of the group projects.\nTimetable # Some weeks will see fewer lectures/labs, and schedules or room numbers may vary from one week to the other. So make sure to check the timetable.\n"},{"id":2,"href":"/docs/intro/","title":"This course","section":"Docs","content":" Structure and organization of the course # This chapter explains how the course is structured and provides a brief overview of its content.\n"},{"id":3,"href":"/docs/project/sections/board_game/","title":"Option 2: board game","section":"Project","content":" Option 2: board game # The second project option available to you consists in developing a video game with mechanics analogous to the ones of Might \u0026amp; Magic: Clash of Heroes or Legend of Solgard.\nStudents who choose this option you will be provided:\na basic graphical user interface (GUI) that they can reuse and/or customize, examples during lectures that they may adapt to their project. Requirements # The minimal requirement to submit this project is a player vs player game playable on a single machine.\nBut of course, you are free to go further and add your own features. Among other possibilities, you could for instance:\nimplement new mechanics (e.g. a rock-paper-scissor logic for unit encounters, events that may affect the board, etc.), make the game deterministic (i.e. eliminate randomness), create units with specific behaviors, implements scripted encounters (\u0026ldquo;boss fights\u0026rdquo;), implement a story, character progression, etc., develop a player vs bot mode, etc, Note. If you choose the last options in the list above (player vs bot), then you may benefit from an algorithm seen in the chapter on recursion. Besides, if several groups choose this option, we may organize a competition between bots (provided that they play by the same rules).\nGuidelines # GUI # The source code for the GUI can be cloned from GitHub. The project is designed so that:\nyou can develop a fully functional game (player vs player or player vs bot) by focusing exclusively on the backend (i.e. the mechanics of the game), without modifying the GUI. backend and frontend are decoupled. Communication between frontend and backend is specified via Java interfaces. It revolves around the notion of a game snapshot, which contains all the information needed to describe a state of the game (equivalently, you can think of a snapshot as a save state). In particular, snapshots are independent of a specific GUI.\nFor instance, a method is available that allows you to pass a snapshot to the GUI component. When you call this method, the snapshot will be drawn on screen, replacing the previous one (if any).\nAs input, your code receives the next action of the active player (for instance, delete the unit present on a specific tile). These are again specified by an interface. Your code should react accordingly: modify the current snapshot, and then send it the GUI component for display.\nThe README.md file (at the root of the project) contains a description of the different components and interfaces, as well as building instructions, and explains where your code could fit. Read it carefully before you start working on your project!\nNote. You are of course free to modify the interfaces that come with the project. But this may require modifying the implementation of the GUI.\nDisclaimer. By design, the project compromises performance for simplicity and modularity. This is not how a resource intensive game would be implemented.\nMore generally, this exercise is not meant to teach game development, but general-purpose programming and problem solving.\n"},{"id":4,"href":"/docs/intro/sections/lecturers/","title":"Teaching staff","section":"This course","content":" Teaching staff # Julien Corman will teach the lectures and one lab.\nDjamila Oukharijane will teach the other lab.\nOffice hours # If you need additional help with the content of the course, the assignments and/or your project, you can ask for office hours with any (or both) of us.\nThese appointments must be scheduled via email (follow the links above for our email addresses).\n"},{"id":5,"href":"/docs/intro/sections/evaluation/","title":"Evaluation","section":"This course","content":" Evaluation # Evaluation for this course is based on:\nassignments: up to 30 points, a group project: up to 60 points, and an oral exam: up to 10 points. Your final grade is the sum of the above, multiplied by 0.3.\nAssignments # There will be 7 or 8 assignments for this course. These are standard programming exercises, related to notions seen during the lectures. The labs are (mostly) dedicated to these assignments.\nThe assignments are individual (do not submit the code of another student).\nThe release of each assignment is announced via Teams.\nAssignments are submitted via GitHub classroom. You can submit an assignment multiple times (but only before its deadline).\nNote. In order to submit your assignments (and your project), you will need a GitHub account. If you do not have one already, please create one and communicate it to the lecturer, preferably via Teams. Make sure that you use a single GitHub account for all your assignments and your project.\nGroup project # Guidelines for the content of the project are in the dedicated chapter. We focus here on organization and evaluation.\nEach group must consist of 3 to 4 students. Groups should be decided by March 20, and communicated via mail or Teams to the lecturer.\nProjects are delivered via GitHub.\nThe project\u0026rsquo;s code is expected to apply techniques seen during the lectures, but only if relevant. Please do not add artificial functionalities to your project for the sole purpose of illustrating a certain technique.\nGrades for a project are awarded individually, based on each student\u0026rsquo;s contribution. Students are expected to work on different computers. Make sure that:\neach student uses a different (and only one) GitHub account, and each student commits (via git) his/her own code. Among other evaluation criteria, we consider:\nquantity of work, non-trivial logic, appropriate data types and data structures, structure of the code (no code duplication, good usage of methods, classes, interfaces, inheritance, etc.) readability, documentation, naming, collaboration, integration with the rest of project, evidence of testing, etc. Oral exam # The oral exam is individual.\nNo revision is needed.\nWe will ask you questions about your code and/or involvement in the project.\nFor instance:\nwhich design choices you made, which difficulties you encountered, the expected behavior of a certain method, how some portions of the code may be improved, etc. In particular, we will check whether you have a good understanding of the code that you submitted. If not, then your mark for the project may be reevaluated.\n"},{"id":6,"href":"/docs/objects/","title":"Objects and classes","section":"Docs","content":" Objects and classes # This chapter introduces some basic notions of (class-based) object-oriented programming.\n"},{"id":7,"href":"/docs/intro/sections/content/","title":"Content","section":"This course","content":" Content of the course # This is a beginner\u0026rsquo;s course on imperative and (class-based) object oriented programming, with an emphasis on practice and collaboration.\nThe course relies on Java as main programming language. However, many concepts seen in this course are relevant to other (imperative and/or object-oriented) programming languages: C/C++, C#, Javascript, Go, Kotlin, Lua, Perl, PHP, Python, Rust, Ruby, Typescript, Visual Basic, etc.\nPrerequisites # Students are expected to have completed the Computer Programming course (INF/01 76203).\nTherefore the following topics are not covered in this course:\nvariables, assignments, variable scope, basic data types (int, char, boolean, etc.). conditional statements (\u0026ldquo;if/then/else\u0026rdquo;) and loops, expression evaluation, methods/functions, arrays, etc. Students are also expected to have played the board game used as a running example throughout the lectures.\nOutcomes # After completing this course, students should be able to:\ndevelop a prototype application in Java, write structured, documented and easily maintainable code, collaborate with other developers. Focus # Foundations # Most lectures put an emphasis on problem solving, rather than providing syntax or (mechanical) recipes.\nFor conciseness, pseudocode may be used in some sections rather than Java code.\nSome lectures also focus on more abstract (albeit simple) notions. These includes elementary mathematical objects or structures: set, tuple, map, relation, preorder, graph, tree, etc.\nThe purpose is twofold:\ngeneralize techniques seen in this course to programming languages other than Java, provide a widely accepted vocabulary to document/explain your code. Collaboration # The course introduces basic coding practices to ease development within a team. In particular:\nstructuring a project (components, interfaces, encapsulation, etc.), factorizing code (inheritance, reuse of methods, etc.), test-driven development, collaboration via git. Note. What is considered good communication in computer science may differ from other disciplines. Emphasis is put on clarity, precision and conciseness.\nExercise Here is a (caricature of) a poorly documented method. Can you improve the method\u0026rsquo;s description and/or signature?\n/** The algorithm looks at the first collection, and is only guaranteed to * work if no number is present twice in this collection, in which case it * loops over the numbers contained in this collection (in no specific order) * and checks for each number whether it is also present in the second * collection (which is also expected to have distinct numbers). The code * written in this loop adds the current number (from the first collection) * to the output collection if this number is also present in the second * collection, and does nothing with this number otherwise. */ Collection\u0026lt;Integer\u0026gt; filterNumbersThatAreShared(Collection\u0026lt;Integer\u0026gt; c1, Collection\u0026lt;Integer\u0026gt; c2); Solution A simpler signature and description could be:\n/** * Returns the intersection of sets s1 and s2. */ Set\u0026lt;Integer\u0026gt; intersection(Set\u0026lt;Integer\u0026gt; s1, Set\u0026lt;Integer\u0026gt; s2); However, the following topics are beyond the scope of this course:\ncontinuous integration, project management (agile methodology, bug tracking, etc.), advanced git workflows, advanced design patterns, dependency injection, etc. Quizzes # Some lectures will include quizzes. These are anonymous, and therefore are not part of your evaluation. The purpose is to:\nmake lectures more interactive, and adapt the pace of the lectures based on students\u0026rsquo; answers. It is in your own interest to answer them without external resources (web, chatbots, IDE, etc.).\nHere is a link to the first quiz: https://forms.gle/7Y2MpzE7v5xzUJFy7.\nTopics covered # Due to limited time, many notions (such as asymptotic cost, regular languages, hash tables or multi-threading) are only briefly introduced in this course. However, some of them will be further discussed in other courses of the bachelor.\nProgramming techniques # An important part of the lectures is dedicated to the following core topics:\nobjects, classes and interfaces (inheritance, encapsulation, value vs reference, comparing objects, cloning objects, etc.), abstract data types (set, list, associative array, queue, etc.) and data structures (array, linked list, hash table, etc.), recursion. In addition, the following will be (briefly) introduced:\ngenerics, mutability, pure functions, lambda expressions and streams, multi-threading. Note. Some of these topics pertain to functional programming, but have been incorporated (in some form) to several imperative languages over the years.\nSoftware engineering # unit tests, exceptions, code factorization. Java # compilation/interpretation, bytecode, JVM and JDK, input/output, object serialization, JSON/XML serialization. Tools and tutorials # git, build automation (Maven and Gradle), using an IDE, using a terminal efficiently (introduction), etc. "},{"id":8,"href":"/docs/intro/sections/board_game/","title":"Board game","section":"This course","content":" Board game # In order to follow this course, you will need to play one of the two following video games:\nMight \u0026amp; Magic: Clash of Heroes, or Legend of Solgard. These two games have nearly identical mechanics. So by default, we will refer to them as a unique game (e.g. when we write \u0026ldquo;this game\u0026rdquo; or \u0026ldquo;our board game\u0026rdquo;).\nWhy this game # Turn-based board games (like chess, go, checkers, etc.) are traditionally a good playground to learn the basics of algorithmic thinking.\n**_Disclaimer._** This course is _not_ about video game development, but general-purpose programming. This game will only serve as _didactic support_. Precisely, this game will serve two purposes:\nwe will use it as a running example throughout the lectures, and students can choose to implement (their own version of) this game as their group project. By default, we will focus on the two player variant, where both players play by the same rules. These two players may be humans and/or bots.\nHow long to play # Students only need to play long enough to understand the basic mechanics of the game.\n1.5 to 2 hours should be sufficient.\n**_Warning._** In both games, mechanics are introduced gradually, so it is difficult to get a full overview by playing less than an hour. Which game to choose # Might and Magic clash of heroes (MMCoH) # This game was initially released in 2009 for Nintendo DS. It has then been ported to PC and several consoles, as well as Android and iOS.\nA free demo was available on Steam until July 2023. The game has been re-released since, by another editor. As a result, the demo is not available on Steam anymore.\nThe Android and iOS versions have also been removed from the Google Play store and App store respectively.\n**_Advantages._** - The mechanics of this game may be easier to understand (in a short amount of time). - The default mode is the (symmetric) 2 player mode (player vs bot or player vs player) that we will work on. **_Drawbacks._** - The touch-screen interface on Android and iOS is arguably dated. Legend of Solgard # This game was released in 2016 for Android and iOS. It is still available on the Google Play store and the App store.\nIt is free to play, with optional microtransactions (via so-called loot boxes).\n**_Warning._** For this course, _no_ transaction is needed. **_Advantages._** - Animations can be sped up. - The touch-screen interface is more modern than the one of MMCoH for Android and iOS. **_Drawbacks._** - Progression is based on a (complex) system of virtual currencies, which adds noise to the interface. - The game can only be played (for free) a limited amount of time per day (approximately 45 min). - The default mode is _not_ the (symmetric) 2 players mode that we will work on (it requires more playtime to be unlocked). So an extra effort of imagination may be needed. "},{"id":9,"href":"/docs/intro/sections/bibliography/","title":"Additional resources","section":"This course","content":" Additional resources # You can use additional resource to solve the assignments or develop your project: web sites, IDE generated code, Copilot, et. However, make sure that you understand the code that you submit.\nJava\u0026rsquo;s syntax # This website contains Java code snippets that illustrate how to perform certain operations. However, this documentation is far from exhaustive (on purpose).\nWhen it comes to syntax, the first two sources of complementary material for this course are:\nthe Javadoc of the libraries (standard and auxiliary) used in projects and assignments. An IDE is often the fastest way to navigate through it, the web. Books # An (optional) reading list for this course is available in the catalogue of the Unibz\u0026rsquo;s library. All books can be accessed via the library (either physically or digitally).\nAmong these books, we highlight the following three:\nIntroductory textbooks # Java : the complete reference (11th edition) by Herbert Schildt McGraw-Hill Education, 2019\nThis is a general introductory book to Java and object oriented programming. It covers most of the topics seen in this course (and a lot more).\nHead First Java (3rd edition) by Kathy Sierra, Bert Bates and Trisha Gee O\u0026rsquo;Reilly Media, 2022\nThis is an alternative introductory book, less comprehensive, but with a larger emphasis on problem solving (rather than syntax).\nGood practices (intermediate level) # Effective Java (3rd edition)\nby Joshua Bloch\nAddison-Wesley Professional, 2017\nThis is a reference book for best practices and common pitfalls when programming in Java.\n"}]