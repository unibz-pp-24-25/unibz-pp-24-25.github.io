[{"id":0,"href":"/docs/objects/sections/objects/","title":"Objects","section":"Objects and classes","content":" Objects # An object groups data in a meaningful way.\nA simple example: JSON objects # Here is a JSON object (in Javascript syntax) that describes the city of Florence:\n{ name: \u0026#34;Florence\u0026#34;, zipcode: 50100 } A JSON object may contain other objects, as well as arrays (of values, objects or arrays). For instance:\n{ name: \u0026#34;Alice\u0026#34;, age: 26, birthPlace: { name: \u0026#34;Florence\u0026#34;, zipcode: 50100 }, jobs: [ { employer: \u0026#34;Kolping\u0026#34;, start: 2021, end: 2022 }, { employer : \u0026#34;Eurac\u0026#34;, start: 2023 } ] } In JSON:\nan element can be either: a scalar (e.g. an integer), or an array of elements, or an object, an object is a finite set of key-value pairs, where keys are distinct, and each value is an element. Besides, a JSON element must have finite depth.\nEquivalently, a JSON object can be viewed as a function (with finite domain) that maps keys to JSON elements.\nObjects and programming languages # JSON objects do not exactly correspond to the objects that can be created in Java (and many other programming languages). We highlight here two important differences.\nTypes # Exercise Find a JSON object that satisfies the above description but cannot be represented as an object in a (strongly) typed language such as Java, C/C++, C#, etc.\nPossible solution { key: [1, \u0026#34;a\u0026#34;]; } In a typed language (like Java), the elements of an array must be of the same type.\nThis is not required in Javascript, Python, etc.\nReferences # A Java (or Python, C#, etc.) object does not contain objects or arrays, but references to objects or arrays. For instance, the equivalent in Java of the above object may be pictured as follows (abusing notation):\n_1: { name: _2, age: 26, birthPlace: _3, jobs: _4, } _2: [\u0026#39;A\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;e\u0026#39;] _3: { name: _5, zipcode: 50100 } _4: [ _6, _7 ] _5: [\u0026#39;F\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;e\u0026#39;] _6: { employer: _8, start: 2021, end: 2022 } _7: { employer: _9, start: 2023 } _8: [\u0026#39;K\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;g\u0026#39;] _9: [\u0026#39;E\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;] Each object or array has an ID (e.g. _1 in this example), which can be used to refer to it (you can think of this ID as an address in memory).\nAs a consequence, some objects can be created in Java that have no (finite) representation in JSON.\nExercise Find one of these objects.\nPossible solution _1: { name: _2, friends: _3 } _2: [\u0026#39;A\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;e\u0026#39;] _3: [ _4, _7 ] _4: { name: _5, friends: _6 } _5: [\u0026#39;B\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;b\u0026#39;] _6: [ _1, _8 ] If we try to represent this object in JSON, we get (assuming that we start with Alice):\n{ name: \u0026#34;Alice\u0026#34;, friends: [ { name: \u0026#34;Bob\u0026#34;, friends: [ { name: \u0026#34;Alice\u0026#34;, friends: [ ... ]}]}]} Cyclic references (like in this exercise) naturally occur in object-oriented code. Identifying them may be essential to debug a program that does not terminate or runs out of memory (stack overflow, \u0026hellip;).\n"},{"id":1,"href":"/docs/project/sections/free_project/","title":"Option 1: free project","section":"Project","content":" Option 1: free project # The first possible type of group projects is for students to develop a Java application of their choice.\nThis application is only a prototype, so it does not need a comprehensive list of features or functionalities.\nThe evaluation of the project will be mostly based on its backend (rather than the frontend). This means that the application:\ndoes not need a graphical user interface (but may have one), should perform non-trivial backend task(s) (e.g. writing and/or reading to/from files is not sufficient). Guidelines # Motivation # A good projects is driven by an idea.\nFeel free to design your application so that it matches your own interests. For instance:\nrelate it to a hobby (music, cinema, fashion, sport, games, social media, astronomy, etc.), use the project as an opportunity to explore a topic that you are curious about (natural language processing, computer vision, recommender systems, robotics, etc.), develop a functionality that one of your favorite applications is missing. Do not hesitate to be ambitious at first. You can restrict the scope of your project (to certain features or components) later on.\nSpecification # A frequent source of failure for this course is students focusing on tools (e.g. following tutorials) without having a precise objective. The short deadline (June 2025) does not give you this flexibility. Besides, without a precise objective, the amount of libraries that are available to you (especially in Java) can be overwhelming.\nSo we recommend you to clarify what your application should do, before thinking about how you could implement it. In other words, specify which problem(s) (i.e. input and expected output) your program and/or components should solve. Then only think about algorithms, libraries, tools and/or tutorials that can help you solve these problems.\nIn order to determine whether your specification is precise enough, you may check whether it leaves some doubt as to whether an output is correct or not.\nUser interface # Developing a Graphical User Interface (GUI) requires familiarity with a graphical framework. Learning the details of such a framework (terminology, syntax, setup, etc.) can be an important time investment, and this knowledge may not transfer to other graphical frameworks. In other words, developing a GUI may not require lot of thinking, but a lot of reading (and web browsing).\nBeware also that GUIs technologies are still rapidly evolving, and that recent innovation has largely been driven by web development. So learning a graphical framework for Java may not be a strategic investment of your time (compared to learning a Javascript framework like React or Angular). Note that even desktop and mobile applications are increasingly relying on web technologies for their GUIs (thanks to frameworks like Electron or React Native).\nThis is why we recommend you to think carefully before committing to a Java GUI, and to keep it minimal if you do. Note also that we will not evaluate your project based on aesthetic criteria.\nSo in order to design your interface, you may follow the following guidelines:\nAsk yourself whether your application really needs a GUI. A command-line interface (CLI) may be sufficient, because: your program takes files as input and produces files as output, or your program is (primarily) meant to be used by other programs (rather than human beings), or your program is meant to be used by other developers, or external programs with GUIs (such as IDEs) can easily call your application, or you leave the GUI for future work (again, your application is just a prototype), etc. If you really need a GUI, then: decouple frontend and backend (whenever possible), so that the backend could be used with another frontend, and conversely. Example. Many applications accessible via GUI have a natural decoupling of frontend and backend. For instance, consider an application that allows booking hotel rooms. The backend takes as input some data (e.g. number or guests, duration, etc.), and outputs data as well (available rooms, prices, etc.). These input and output are independent of the aspect or structure of the GUI (windows, menus, buttons, fields, etc.).\nExample. Even for some games, frontend and backend can easily be decoupled. Consider for instance a program that plays chess against a human opponent. The backend:\nkeeps track of the current state of the board, takes as input either a move from the white player, or a request to play as the (bot) black player, outputs the next state of the board. These input and output do not depend on a specific GUI (they can for instance be encoded using algebraic notation). So the backend can be implemented without any reference to graphical elements or controller inputs (mouse clicks, etc.).\ndevelop the backend first (and write unit tests for it),\ndevelop the frontend afterwards (if you have time for it).\nIf you really need a GUI, then try to keep it minimal. In particular, restrict the input to what is essential for your application (the more freedom the user is given, the more likely he/she is to input a sequence of actions that your program cannot handle). Illustrations # Here are some examples of (past and imaginary) possible projects:\na program that detects texts generated by a large language model, a program that takes as input a dataset of Tweets and identifies communities and/or influencers based on the network formed by re-tweets, a program that retrieves news articles about an input topic (using web APIs), and analyses their polarity (via sentiment analysis) together with their provenance (news outlet, country, etc.), a (toy) recommender system, a program that generates (solvable) sudoku grids with different sizes and/or level of difficulty, a game to help people improve their typing speed, a web crawler that retrieves sport-related statistics from various websites and exposes them via a web API, a classroom reservation system for the Unibz that can computes a default schedule for a whole semester, satisfying a set of constraints (room capacity, etc.) and/or preferences (minimize days of presence per week of a same group, etc.), a flashcard app that incorporates answers produced by a chatbot, an (Obsidian-like) note management application, a program to organize and manage coding contests (similar to this one), a password manager (with encryption), for instance similar to pass, where password update and synchronization are performed via git, a program that analyzes the commit and/or branching history of a git repository (e.g. contributions of the different users, frequency of commits, percentage of preserved code, etc.). "},{"id":2,"href":"/docs/intro/sections/schedule/","title":"Schedule","section":"This course","content":" Schedule # The course consists of 60 hours of lectures and 30 hours of labs.\nLectures # By default, lectures are scheduled:\nMonday 13:30 - 15:30 Tuesday 08:30 - 10:30 Wednesday 08:30 - 10:30 All students attend the same lectures.\nLabs # By default, labs are scheduled:\nMonday 15:30 - 17:30 Wednesday 13:30 - 15:30 Students are split in two groups (to be determined) for the labs, with identical content. Students who collaborate on the same group project are expected to attend the same lab.\nMost labs will be dedicated to the assignments for this course. Two labs will be dedicated to a presentation and discussion of the advancement of the group projects.\nTimetable # Some weeks will see fewer lectures/labs, and schedules or room numbers may vary from one week to the other. So make sure to check the timetable.\n"},{"id":3,"href":"/docs/intro/","title":"This course","section":"Docs","content":" Structure and organization of the course # This chapter explains how the course is structured and provides a brief overview of its content.\n"},{"id":4,"href":"/docs/project/sections/board_game/","title":"Option 2: board game","section":"Project","content":" Option 2: board game # The second project option available to you consists in developing a video game with mechanics analogous to the ones of Might \u0026amp; Magic: Clash of Heroes or Legend of Solgard.\nStudents who choose this option you will be provided:\na basic graphical user interface (GUI) that they can reuse and/or customize, examples during lectures that they may adapt to their project. Requirements # The minimal requirement to submit this project is a player vs player game playable on a single machine.\nBut of course, you are free to go further and add your own features. Among other possibilities, you could for instance:\nimplement new mechanics (e.g. a rock-paper-scissor logic for unit encounters, events that may affect the board, etc.), make the game deterministic (i.e. eliminate randomness), create units with specific behaviors, implements scripted encounters (\u0026ldquo;boss fights\u0026rdquo;), implement a story, character progression, etc., develop a player vs bot mode, etc, Note. If you choose the last options in the list above (player vs bot), then you may benefit from an algorithm seen in the chapter on recursion. Besides, if several groups choose this option, we may organize a competition between bots (provided that they play by the same rules).\nGuidelines # GUI # The source code for the GUI can be cloned from GitHub. The project is designed so that:\nyou can develop a fully functional game (player vs player or player vs bot) by focusing exclusively on the backend (i.e. the mechanics of the game), without modifying the GUI. backend and frontend are decoupled. Communication between frontend and backend is specified via Java interfaces. It revolves around the notion of a game snapshot, which contains all the information needed to describe a state of the game (equivalently, you can think of a snapshot as a save state). In particular, snapshots are independent of a specific GUI.\nFor instance, a method is available that allows you to pass a snapshot to the GUI component. When you call this method, the snapshot will be drawn on screen, replacing the previous one (if any).\nAs input, your code receives the next action of the active player (for instance, delete the unit present on a specific tile). These are again specified by an interface, with 7 method that you need to implement. Your implementation should react to each action, i.e. modify the current snapshot, and then send it the GUI component for display.\nThe README.md file (at the root of the project) contains a description of the different components and interfaces, as well as building instructions, and explains where your code could fit. Read it carefully before you start working on your project!\nNote. You are of course free to modify the interfaces that come with the project. But this may require modifying the implementation of the GUI.\nDisclaimer. By design, the project compromises performance for simplicity and modularity. This is not how a resource-intensive game would be implemented.\nMore generally, this exercise is not meant to teach game development, but general-purpose programming and problem solving.\n"},{"id":5,"href":"/docs/project/","title":"Project","section":"Docs","content":" Project # Students enrolled in this course are expected to deliver a group project.\nTwo alternative options # Students can develop either:\nA project of their choice, or Their own version of the board game used as our running example. Groups who choose the second option (board game), will benefit from:\na graphical user interface (so that it is sufficient to implement the mechanics of the game), additional content provided during the lectures (as illustrations), which can be incorporated to the project. Requirements # Here are some requirements common to both options (free project or board game).\nSource code # The source code for the project must be written in Java 21 or lower.\nThe code should be original (or mostly original). If a project incorporates external code, it has to be referenced clearly in the README.md file of the project. If the project takes inspiration from a tutorial or the source code of another project, then this should be referenced as well.\nThe source code must be submitted as a GitHub repository. The commit history must reflect the individual contribution of each member of the group. For this reason:\neach student should use a different (and only one) GitHub account, and each student should commit his/her own code. The repository should contain at its root a .gitignore file hat indicates files that should not be tracked. In particular, a repository should not contain:\ncompiled classes, jars, logs, run-time files, IDE-generated files (e.g. .idea/), OS-generated files (e.g. .DS_Store), etc. Dependencies, build and packaging # Any additional Java library can be used in a project.\nThe project should be build with either Maven or Gradle. It should run on the evaluation environment via command line instructions.\nFor instance (depending on how the project is designed), the instructions to build the executable may be:\nmvn package and the instruction to run the executable may be (assuming that the executable is called myJar.jar and that the program takes two strings as input):\njava -jar myJar.jar \u0026#34;firstInput\u0026#34; \u0026#34;secondInput\u0026#34; If the executable cannot be built in the evaluation environment, then an über-jar should be provided that can run in this environment (via command line still).\nDocumentation # README # The git repository should contain at its root a README.md file (written in Markdown). This file should contain at least the following information:\nmembers of the group and their respective GitHub identifiers, clear instructions for building and running the project, a description of the project, a user\u0026rsquo;s guide for the project (either a written guide, or a link to a video), a brief overview of the implementation of the project. This should include information on: the different (high-level) components and interfaces between components, which third-party libraries were used (if any), and some programming techniques (seen in the course or not) that were particularly relevant for this project. a description of the human experience in this project. This should include information on: how the workload was distributed between the members of the project, how git was used, and challenges that each member faced (at least one per person). For further information about what a README.md file usually contains, one may look at this web page.\nThe README should not document the methods of your code (this documentation should be part of the code itself).\nCode documentation # No need to document every method of the project. It is sufficient to document (i.e. add a short specification to) the methods that your code exposes.\nThese are typically:\nmethods declared in a Java interface, methods written by one member of the group and called by another, methods that are written in a certain class or component (e.g. in the backend) and called in another (e.g. the fronted), and/or if your project is a Java library, methods that you want to make available to the user. These methods are usually public. The other methods are usually private or protected, and can remain undocumented.\nYou may also add comments to the more complex portions of your code, if the code is not self-explanatory.\n"},{"id":6,"href":"/docs/intro/sections/lecturers/","title":"Teaching staff","section":"This course","content":" Teaching staff # Julien Corman will teach the lectures and one lab.\nDjamila Oukharijane will teach the other lab.\nOffice hours # If you need additional help with the content of the course, the assignments and/or your project, you can ask for office hours with any (or both) of us.\nThese appointments must be scheduled via email (follow the links above for our email addresses).\n"},{"id":7,"href":"/docs/intro/sections/evaluation/","title":"Evaluation","section":"This course","content":" Evaluation # Evaluation for this course is based on:\nassignments: up to 30 points, a group project: up to 60 points, and an oral exam: up to 10 points. Your final grade is the sum of the above, multiplied by 0.3.\nAssignments # There will be 7 or 8 assignments for this course. These are standard programming exercises, related to notions seen during the lectures. The labs are (mostly) dedicated to these assignments.\nThe assignments are individual (do not submit the code of another student).\nThe release of each assignment is announced via Teams.\nAssignments are submitted via GitHub classroom. You can submit an assignment multiple times (but only before its deadline).\nNote. In order to submit your assignments (and your project), you will need a GitHub account. If you do not have one already, please create one and communicate it to the lecturer, preferably via Teams. Make sure that you use a single GitHub account for all your assignments and your project.\nGroup project # Guidelines for the content of the project are in the dedicated chapter. We focus here on organization and evaluation.\nEach group must consist of 3 to 4 students. Groups should be decided by March 20, and communicated via mail or Teams to the lecturer.\nProjects are delivered via GitHub.\nThe project\u0026rsquo;s code is expected to apply techniques seen during the lectures, but only if relevant. Please do not add artificial functionalities to your project for the sole purpose of illustrating a certain technique.\nGrades for a project are awarded individually, based on each student\u0026rsquo;s contribution. Students are expected to work on different computers. Make sure that:\neach student uses a different (and only one) GitHub account, and each student commits (via git) his/her own code. Among other evaluation criteria, we consider:\nquantity of work, non-trivial logic, appropriate data types and data structures, structure of the code (no code duplication, good usage of methods, classes, interfaces, inheritance, etc.) readability, documentation, naming, collaboration, integration with the rest of project, evidence of testing, etc. Oral exam # The oral exam is individual.\nNo revision is needed.\nWe will ask you questions about your code and/or involvement in the project.\nFor instance:\nwhich design choices you made, which difficulties you encountered, the expected behavior of a certain method, how some portions of the code may be improved, etc. In particular, we will check whether you have a good understanding of the code that you submitted. If not, then your mark for the project may be reevaluated.\n"},{"id":8,"href":"/docs/objects/","title":"Objects and classes","section":"Docs","content":" Objects and classes # This chapter introduces some basic notions of (class-based) object-oriented programming.\n"},{"id":9,"href":"/docs/intro/sections/content/","title":"Content","section":"This course","content":" Content of the course # This is a beginner\u0026rsquo;s course on imperative and (class-based) object oriented programming, with an emphasis on practice and collaboration.\nThe course relies on Java as main programming language. However, many concepts seen in this course are relevant to other (imperative and/or object-oriented) programming languages: C/C++, C#, Javascript, Go, Kotlin, Lua, Perl, PHP, Python, Rust, Ruby, Typescript, Visual Basic, etc.\nPrerequisites # Students are expected to have completed the Computer Programming course (INF/01 76203).\nTherefore the following topics are not covered in this course:\nvariables, assignments, variable scope, basic data types (int, char, boolean, etc.). conditional statements (\u0026ldquo;if/then/else\u0026rdquo;) and loops, expression evaluation, methods/functions, arrays, etc. Students are also expected to have played the board game used as a running example throughout the lectures.\nOutcomes # After completing this course, students should be able to:\ndevelop a prototype application in Java, write structured, documented and easily maintainable code, collaborate with other developers. Focus # Foundations # Most lectures put an emphasis on problem solving, rather than providing syntax or (mechanical) recipes.\nFor conciseness, pseudocode may be used in some sections rather than Java code.\nSome lectures also focus on more abstract (albeit simple) notions. These includes elementary mathematical objects or structures: set, tuple, map, relation, preorder, graph, tree, etc.\nThe purpose is twofold:\ngeneralize techniques seen in this course to programming languages other than Java, provide a widely accepted vocabulary to document/explain your code. Collaboration # The course introduces basic coding practices to ease development within a team. In particular:\nstructuring a project (components, interfaces, encapsulation, inheritance, etc.), test-driven development, collaboration via git. Note. What is considered good communication in computer science may differ from other disciplines. Emphasis is put on clarity, precision and conciseness.\nExercise Here is a (caricature of) a poorly documented method. Can you improve the method\u0026rsquo;s description and/or signature?\n/** The algorithm looks at the first collection, and is only guaranteed to * work if no number is present twice in this collection, in which case it * loops over the numbers contained in this collection (in no specific order) * and checks for each number whether it is also present in the second * collection (which is also expected to have distinct numbers). The code * written in this loop adds the current number (from the first collection) * to the output collection if this number is also present in the second * collection, and does nothing with this number otherwise. */ Collection\u0026lt;Integer\u0026gt; filterNumbersThatAreShared(Collection\u0026lt;Integer\u0026gt; c1, Collection\u0026lt;Integer\u0026gt; c2); Solution A simpler signature and description could be:\n/** * Returns the intersection of sets s1 and s2. */ Set\u0026lt;Integer\u0026gt; intersection(Set\u0026lt;Integer\u0026gt; s1, Set\u0026lt;Integer\u0026gt; s2); However, the following topics are beyond the scope of this course:\ncontinuous integration, project management (agile methodology, bug tracking, etc.), advanced git workflows, advanced design patterns, dependency injection, etc. Quizzes # Some lectures will include quizzes. These are anonymous, and therefore are not part of your evaluation. The purpose is to:\nmake lectures more interactive, and adapt the pace of the lectures based on students\u0026rsquo; answers. It is in your own interest to answer them without external resources (web, chatbots, IDE, etc.).\nHere is a link to the first quiz: https://forms.gle/7Y2MpzE7v5xzUJFy7.\nTopics covered # Due to limited time, many notions (such as asymptotic cost, regular languages, hash tables or multi-threading) are only briefly introduced in this course. However, some of them will be further discussed in other courses of the bachelor.\nProgramming techniques # An important part of the lectures is dedicated to the following core topics:\nobjects, classes and interfaces (inheritance, encapsulation, value vs reference, comparing objects, cloning objects, etc.), abstract data types (set, list, associative array, queue, etc.) and data structures (array, linked list, hash table, etc.), recursion. In addition, the following will be (briefly) introduced:\ngenerics, mutability, pure functions, lambda expressions and streams, multi-threading. Note. Some of these topics pertain to functional programming, but have been incorporated (in some form) to several imperative languages over the years.\nSoftware engineering # unit tests, exceptions, code factorization. Java # input/output, object serialization, JSON/XML serialization. Tools and tutorials # git, build automation (Maven and Gradle), using an IDE, using a terminal efficiently (introduction), etc. "},{"id":10,"href":"/docs/intro/sections/board_game/","title":"Board game","section":"This course","content":" Board game # In order to follow this course, you will need to play one of the two following video games:\nMight \u0026amp; Magic: Clash of Heroes, or Legend of Solgard. These two games have nearly identical mechanics. So by default, we will refer to them as a unique game (e.g. when we write \u0026ldquo;this game\u0026rdquo; or \u0026ldquo;our board game\u0026rdquo;).\nWhy this game # Turn-based board games (like chess, go, checkers, etc.) are traditionally a good playground to learn the basics of algorithmic thinking.\nDisclaimer. The course is not about video game development, but general-purpose programming. This game is only used as didactic support.\nPrecisely, this game will serve two purposes:\nwe will use it as a running example throughout the lectures, and students can choose to implement (their own version of) this game as their group project. By default, we will focus on the two player variant, where both players play by the same rules. These two players may be humans and/or bots.\nHow long to play # Students only need to play long enough to understand the basic mechanics of the game.\n1.5 to 2 hours should be sufficient.\nWarning. In both games, mechanics are introduced gradually, so it is difficult to get a full overview by playing less than 1.5 hours.\nWhich game to choose # Might and Magic clash of heroes (MMCoH) # This game was initially released in 2009 for Nintendo DS. It has then been ported to PC and several consoles, as well as Android and iOS.\nA free demo was available on Steam until July 2023. The game has been re-released since, by another editor. As a side-effect, the demo is not available on Steam anymore.\nThe Android and iOS versions have also been removed from the Google Play store and App store respectively.\nAdvantages.\nThe mechanics of this game may be easier to understand (in a short amount of time). The default mode is the (symmetric) 2 player mode (player vs bot or player vs player) that we will work on. Drawbacks.\nThe touch-screen interface on Android and iOS is arguably dated. Legend of Solgard # This game was released in 2016 for Android and iOS. It is still available on the Google Play store and the App store.\nIt is free to play, with optional microtransactions (via so-called loot boxes).\nWarning. For this course, no transaction is needed.\nAdvantages.\nAnimations can be sped up. The touch-screen interface is more modern than the one of MMCoH for Android and iOS. Drawbacks.\nProgression is based on a (complex) system of virtual currencies, which adds noise to the interface. The game can only be played (for free) a limited amount of time per day (approximately 45 min). The default mode is not the (symmetric) 2 players mode that we will work on (it requires more playtime to be unlocked). So an extra effort of imagination may be needed. "},{"id":11,"href":"/docs/intro/sections/bibliography/","title":"Additional resources","section":"This course","content":" Additional resources # You are free to use additional resources to solve the course\u0026rsquo;s assignments and/or develop your project(web sites, IDE generated code, Copilot, etc.).\nHowever, make sure that you understand the code that you submit.\nJava\u0026rsquo;s syntax # This website contains Java code snippets that illustrate how to perform certain operations. However, this documentation is far from exhaustive (on purpose).\nWhen it comes to syntax, the first two sources of complementary material for this course are:\nthe Javadoc of the libraries (standard and auxiliary) used in projects and assignments. An IDE is often the fastest way to navigate through it, the web. Books # An (optional) reading list for this course is available in the catalogue of the Unibz\u0026rsquo;s library. All books can be accessed via the library (either physically or digitally).\nAmong these books, we highlight the following three:\nIntroductory textbooks # Java : the complete reference (11th edition) by Herbert Schildt McGraw-Hill Education, 2019\nThis is a general introductory book to Java and object oriented programming. It covers most of the topics seen in this course (and a lot more).\nHead First Java (3rd edition) by Kathy Sierra, Bert Bates and Trisha Gee O\u0026rsquo;Reilly Media, 2022\nThis is an alternative introductory book, less comprehensive, but with a larger emphasis on problem solving (rather than syntax).\nGood practices (intermediate level) # Effective Java (3rd edition)\nby Joshua Bloch\nAddison-Wesley Professional, 2017\nThis is a reference book for best practices and common pitfalls when programming in Java.\n"}]